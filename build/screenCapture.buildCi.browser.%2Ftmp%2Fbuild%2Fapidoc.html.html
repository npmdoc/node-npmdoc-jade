<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://jade-lang.com">jade (v1.11.0)</a>
</h1>
<h4>A clean, whitespace-sensitive template language for writing HTML</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade">module jade</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler">
            function <span class="apidocSignatureSpan">jade.</span>Compiler
            <span class="apidocSignatureSpan">(node, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer">
            function <span class="apidocSignatureSpan">jade.</span>Lexer
            <span class="apidocSignatureSpan">(str, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser">
            function <span class="apidocSignatureSpan">jade.</span>Parser
            <span class="apidocSignatureSpan">(str, filename, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.__express">
            function <span class="apidocSignatureSpan">jade.</span>__express
            <span class="apidocSignatureSpan">(path, options, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.compile">
            function <span class="apidocSignatureSpan">jade.</span>compile
            <span class="apidocSignatureSpan">(str, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.compileClient">
            function <span class="apidocSignatureSpan">jade.</span>compileClient
            <span class="apidocSignatureSpan">(str, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.compileClientWithDependenciesTracked">
            function <span class="apidocSignatureSpan">jade.</span>compileClientWithDependenciesTracked
            <span class="apidocSignatureSpan">(str, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.compileFile">
            function <span class="apidocSignatureSpan">jade.</span>compileFile
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.compileFileClient">
            function <span class="apidocSignatureSpan">jade.</span>compileFileClient
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.filters">
            function <span class="apidocSignatureSpan">jade.</span>filters
            <span class="apidocSignatureSpan">(name, str, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Block">
            function <span class="apidocSignatureSpan">jade.</span>nodes.Block
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.BlockComment">
            function <span class="apidocSignatureSpan">jade.</span>nodes.BlockComment
            <span class="apidocSignatureSpan">(val, block, buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Case">
            function <span class="apidocSignatureSpan">jade.</span>nodes.Case
            <span class="apidocSignatureSpan">(expr, block)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Code">
            function <span class="apidocSignatureSpan">jade.</span>nodes.Code
            <span class="apidocSignatureSpan">(val, buffer, escape)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Comment">
            function <span class="apidocSignatureSpan">jade.</span>nodes.Comment
            <span class="apidocSignatureSpan">(val, buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Doctype">
            function <span class="apidocSignatureSpan">jade.</span>nodes.Doctype
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Each">
            function <span class="apidocSignatureSpan">jade.</span>nodes.Each
            <span class="apidocSignatureSpan">(obj, val, key, block)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Filter">
            function <span class="apidocSignatureSpan">jade.</span>nodes.Filter
            <span class="apidocSignatureSpan">(name, block, attrs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Literal">
            function <span class="apidocSignatureSpan">jade.</span>nodes.Literal
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Mixin">
            function <span class="apidocSignatureSpan">jade.</span>nodes.Mixin
            <span class="apidocSignatureSpan">(name, args, block, call)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.MixinBlock">
            function <span class="apidocSignatureSpan">jade.</span>nodes.MixinBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Node">
            function <span class="apidocSignatureSpan">jade.</span>nodes.Node
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Tag">
            function <span class="apidocSignatureSpan">jade.</span>nodes.Tag
            <span class="apidocSignatureSpan">(name, block)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Text">
            function <span class="apidocSignatureSpan">jade.</span>nodes.Text
            <span class="apidocSignatureSpan">(line)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.render">
            function <span class="apidocSignatureSpan">jade.</span>render
            <span class="apidocSignatureSpan">(str, options, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.renderFile">
            function <span class="apidocSignatureSpan">jade.</span>renderFile
            <span class="apidocSignatureSpan">(path, options, fn)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan"></span>jade</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>Compiler.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>Lexer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>Parser.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>cache</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>doctypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.Block.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.BlockComment.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.Case.When.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.Case.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.Code.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.Comment.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.Doctype.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.Each.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.Filter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.Literal.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.Mixin.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.MixinBlock.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.Node.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.Tag.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.Text.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>runtime</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>selfClosing</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.Compiler">module jade.Compiler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.Compiler">
            function <span class="apidocSignatureSpan">jade.</span>Compiler
            <span class="apidocSignatureSpan">(node, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.Compiler.prototype">module jade.Compiler.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.attrs">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>attrs
            <span class="apidocSignatureSpan">(attrs, buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.buffer">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>buffer
            <span class="apidocSignatureSpan">(str, interpolate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.bufferExpression">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>bufferExpression
            <span class="apidocSignatureSpan">(src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.compile">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.prettyIndent">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>prettyIndent
            <span class="apidocSignatureSpan">(offset, newline)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.setDoctype">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>setDoctype
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visit">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visit
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitAttributes">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitAttributes
            <span class="apidocSignatureSpan">(attrs, attributeBlocks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitBlock">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitBlock
            <span class="apidocSignatureSpan">(block)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitBlockComment">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitBlockComment
            <span class="apidocSignatureSpan">(comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitCase">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitCase
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitCode">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitCode
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitComment">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitComment
            <span class="apidocSignatureSpan">(comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitDoctype">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitDoctype
            <span class="apidocSignatureSpan">(doctype)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitEach">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitEach
            <span class="apidocSignatureSpan">(each)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitFilter">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitFilter
            <span class="apidocSignatureSpan">(filter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitLiteral">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitLiteral
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitMixin">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitMixin
            <span class="apidocSignatureSpan">(mixin)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitMixinBlock">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitMixinBlock
            <span class="apidocSignatureSpan">(block)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitNode">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitTag">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitTag
            <span class="apidocSignatureSpan">(tag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitText">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitText
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitWhen">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitWhen
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.Lexer">module jade.Lexer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.Lexer">
            function <span class="apidocSignatureSpan">jade.</span>Lexer
            <span class="apidocSignatureSpan">(str, filename)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.Lexer.prototype">module jade.Lexer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.advance">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>advance
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.append">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>append
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.attributesBlock">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>attributesBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.attrs">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>attrs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.blank">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>blank
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.block">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>block
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.blockCode">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>blockCode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.bracketExpression">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>bracketExpression
            <span class="apidocSignatureSpan">(skip)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.call">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>call
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.case">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>case
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.className">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>className
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.code">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>code
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.colon">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>colon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.comment">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>comment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.conditional">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>conditional
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.consume">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>consume
            <span class="apidocSignatureSpan">(len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.default">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>default
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.defer">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>defer
            <span class="apidocSignatureSpan">(tok)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.deferred">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>deferred
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.doctype">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>doctype
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.dot">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>dot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.each">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>each
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.eos">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>eos
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.extends">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>extends
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.fail">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>fail
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.filter">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>filter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.id">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>id
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.include">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>include
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.includeFiltered">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>includeFiltered
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.indent">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>indent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.interpolation">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>interpolation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.lookahead">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>lookahead
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.mixin">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>mixin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.mixinBlock">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>mixinBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.next">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>next
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.pipelessText">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>pipelessText
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.prepend">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>prepend
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.scan">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>scan
            <span class="apidocSignatureSpan">(regexp, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.stashed">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>stashed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.tag">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>tag
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.text">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>text
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.textFail">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>textFail
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.tok">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>tok
            <span class="apidocSignatureSpan">(type, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.when">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>when
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.while">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>while
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.yield">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>yield
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.Parser">module jade.Parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.Parser">
            function <span class="apidocSignatureSpan">jade.</span>Parser
            <span class="apidocSignatureSpan">(str, filename, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.Parser.prototype">module jade.Parser.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.accept">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>accept
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.advance">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>advance
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.block">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>block
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>constructor
            <span class="apidocSignatureSpan">(str, filename, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.context">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>context
            <span class="apidocSignatureSpan">(parser)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.expect">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>expect
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.line">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>line
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.lookahead">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>lookahead
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parse">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseBlock">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseBlockCode">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseBlockCode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseBlockExpansion">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseBlockExpansion
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseCall">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseCall
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseCase">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseCase
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseCode">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseCode
            <span class="apidocSignatureSpan">(afterIf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseComment">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseComment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseDefault">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseDefault
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseDoctype">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseDoctype
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseEach">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseEach
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseExpr">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseExpr
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseExtends">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseExtends
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseFilter">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseFilter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseInclude">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseInclude
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseInlineTagsInText">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseInlineTagsInText
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseInterpolation">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseInterpolation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseMixin">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseMixin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseMixinBlock">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseMixinBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseTag">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseTag
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseText">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseText
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseTextBlock">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseTextBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseWhen">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseWhen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.peek">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>peek
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.resolvePath">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>resolvePath
            <span class="apidocSignatureSpan">(path, purpose)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.tag">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>tag
            <span class="apidocSignatureSpan">(tag)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.jade">module jade.jade</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.jade.Compiler">
            function <span class="apidocSignatureSpan">jade.jade.</span>Compiler
            <span class="apidocSignatureSpan">(node, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.jade.Lexer">
            function <span class="apidocSignatureSpan">jade.jade.</span>Lexer
            <span class="apidocSignatureSpan">(str, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.jade.Parser">
            function <span class="apidocSignatureSpan">jade.jade.</span>Parser
            <span class="apidocSignatureSpan">(str, filename, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.jade.__express">
            function <span class="apidocSignatureSpan">jade.jade.</span>__express
            <span class="apidocSignatureSpan">(path, options, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.jade.compile">
            function <span class="apidocSignatureSpan">jade.jade.</span>compile
            <span class="apidocSignatureSpan">(str, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.jade.compileClient">
            function <span class="apidocSignatureSpan">jade.jade.</span>compileClient
            <span class="apidocSignatureSpan">(str, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.jade.compileClientWithDependenciesTracked">
            function <span class="apidocSignatureSpan">jade.jade.</span>compileClientWithDependenciesTracked
            <span class="apidocSignatureSpan">(str, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.jade.compileFile">
            function <span class="apidocSignatureSpan">jade.jade.</span>compileFile
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.jade.compileFileClient">
            function <span class="apidocSignatureSpan">jade.jade.</span>compileFileClient
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.jade.filters">
            function <span class="apidocSignatureSpan">jade.jade.</span>filters
            <span class="apidocSignatureSpan">(name, str, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.jade.render">
            function <span class="apidocSignatureSpan">jade.jade.</span>render
            <span class="apidocSignatureSpan">(str, options, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.jade.renderFile">
            function <span class="apidocSignatureSpan">jade.jade.</span>renderFile
            <span class="apidocSignatureSpan">(path, options, fn)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.jade.</span>cache</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.jade.</span>doctypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.jade.</span>nodes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.jade.</span>runtime</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.jade.</span>selfClosing</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.jade.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes">module jade.nodes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Block">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Block
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.BlockComment">
            function <span class="apidocSignatureSpan">jade.nodes.</span>BlockComment
            <span class="apidocSignatureSpan">(val, block, buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Case">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Case
            <span class="apidocSignatureSpan">(expr, block)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Code">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Code
            <span class="apidocSignatureSpan">(val, buffer, escape)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Comment">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Comment
            <span class="apidocSignatureSpan">(val, buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Doctype">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Doctype
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Each">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Each
            <span class="apidocSignatureSpan">(obj, val, key, block)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Filter">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Filter
            <span class="apidocSignatureSpan">(name, block, attrs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Literal">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Literal
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Mixin">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Mixin
            <span class="apidocSignatureSpan">(name, args, block, call)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.MixinBlock">
            function <span class="apidocSignatureSpan">jade.nodes.</span>MixinBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Node">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Node
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Tag">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Tag
            <span class="apidocSignatureSpan">(name, block)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Text">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Text
            <span class="apidocSignatureSpan">(line)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Block">module jade.nodes.Block</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Block.Block">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Block
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Block.prototype">module jade.nodes.Block.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>isBlock</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Block.prototype.clone">
            function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Block.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>constructor
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Block.prototype.includeBlock">
            function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>includeBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Block.prototype.isEmpty">
            function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Block.prototype.push">
            function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>push
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Block.prototype.replace">
            function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>replace
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Block.prototype.unshift">
            function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>unshift
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.BlockComment">module jade.nodes.BlockComment</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.BlockComment.BlockComment">
            function <span class="apidocSignatureSpan">jade.nodes.</span>BlockComment
            <span class="apidocSignatureSpan">(val, block, buffer)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.BlockComment.prototype">module jade.nodes.BlockComment.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.BlockComment.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.BlockComment.prototype.</span>constructor
            <span class="apidocSignatureSpan">(val, block, buffer)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.BlockComment.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Case">module jade.nodes.Case</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Case.Case">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Case
            <span class="apidocSignatureSpan">(expr, block)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Case.When">
            function <span class="apidocSignatureSpan">jade.nodes.Case.</span>When
            <span class="apidocSignatureSpan">(expr, block)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Case.When.prototype">module jade.nodes.Case.When.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Case.When.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.Case.When.prototype.</span>constructor
            <span class="apidocSignatureSpan">(expr, block)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.Case.When.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Case.prototype">module jade.nodes.Case.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Case.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.Case.prototype.</span>constructor
            <span class="apidocSignatureSpan">(expr, block)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.Case.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Code">module jade.nodes.Code</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Code.Code">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Code
            <span class="apidocSignatureSpan">(val, buffer, escape)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Code.prototype">module jade.nodes.Code.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Code.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.Code.prototype.</span>constructor
            <span class="apidocSignatureSpan">(val, buffer, escape)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.Code.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Comment">module jade.nodes.Comment</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Comment.Comment">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Comment
            <span class="apidocSignatureSpan">(val, buffer)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Comment.prototype">module jade.nodes.Comment.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Comment.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.Comment.prototype.</span>constructor
            <span class="apidocSignatureSpan">(val, buffer)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.Comment.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Doctype">module jade.nodes.Doctype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Doctype.Doctype">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Doctype
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Doctype.prototype">module jade.nodes.Doctype.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Doctype.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.Doctype.prototype.</span>constructor
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.Doctype.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Each">module jade.nodes.Each</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Each.Each">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Each
            <span class="apidocSignatureSpan">(obj, val, key, block)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Each.prototype">module jade.nodes.Each.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Each.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.Each.prototype.</span>constructor
            <span class="apidocSignatureSpan">(obj, val, key, block)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.Each.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Filter">module jade.nodes.Filter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Filter.Filter">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Filter
            <span class="apidocSignatureSpan">(name, block, attrs)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Filter.prototype">module jade.nodes.Filter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Filter.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.Filter.prototype.</span>constructor
            <span class="apidocSignatureSpan">(name, block, attrs)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.Filter.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Literal">module jade.nodes.Literal</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Literal.Literal">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Literal
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Literal.prototype">module jade.nodes.Literal.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Literal.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.Literal.prototype.</span>constructor
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.Literal.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Mixin">module jade.nodes.Mixin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Mixin.Mixin">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Mixin
            <span class="apidocSignatureSpan">(name, args, block, call)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Mixin.prototype">module jade.nodes.Mixin.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Mixin.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.Mixin.prototype.</span>constructor
            <span class="apidocSignatureSpan">(name, args, block, call)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.Mixin.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.MixinBlock">module jade.nodes.MixinBlock</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.MixinBlock.MixinBlock">
            function <span class="apidocSignatureSpan">jade.nodes.</span>MixinBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.MixinBlock.prototype">module jade.nodes.MixinBlock.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.MixinBlock.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.MixinBlock.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.MixinBlock.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Node">module jade.nodes.Node</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Node.Node">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Node
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Node.prototype">module jade.nodes.Node.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Node.prototype.clone">
            function <span class="apidocSignatureSpan">jade.nodes.Node.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.Node.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Tag">module jade.nodes.Tag</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Tag.Tag">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Tag
            <span class="apidocSignatureSpan">(name, block)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Tag.prototype">module jade.nodes.Tag.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Tag.prototype.canInline">
            function <span class="apidocSignatureSpan">jade.nodes.Tag.prototype.</span>canInline
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Tag.prototype.clone">
            function <span class="apidocSignatureSpan">jade.nodes.Tag.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Tag.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.Tag.prototype.</span>constructor
            <span class="apidocSignatureSpan">(name, block)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Tag.prototype.isInline">
            function <span class="apidocSignatureSpan">jade.nodes.Tag.prototype.</span>isInline
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.Tag.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Text">module jade.nodes.Text</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Text.Text">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Text
            <span class="apidocSignatureSpan">(line)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Text.prototype">module jade.nodes.Text.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">jade.nodes.Text.prototype.</span>isText</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Text.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.Text.prototype.</span>constructor
            <span class="apidocSignatureSpan">(line)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.Text.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.runtime">module jade.runtime</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.runtime.DebugItem">
            function <span class="apidocSignatureSpan">jade.runtime.</span>DebugItem
            <span class="apidocSignatureSpan">(lineno, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.runtime.attr">
            function <span class="apidocSignatureSpan">jade.runtime.</span>attr
            <span class="apidocSignatureSpan">(key, val, escaped, terse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.runtime.attrs">
            function <span class="apidocSignatureSpan">jade.runtime.</span>attrs
            <span class="apidocSignatureSpan">(obj, terse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.runtime.cls">
            function <span class="apidocSignatureSpan">jade.runtime.</span>cls
            <span class="apidocSignatureSpan">(classes, escaped)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.runtime.escape">
            function <span class="apidocSignatureSpan">jade.runtime.</span>escape
            <span class="apidocSignatureSpan">(html)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.runtime.joinClasses">
            function <span class="apidocSignatureSpan">jade.runtime.</span>joinClasses
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.runtime.merge">
            function <span class="apidocSignatureSpan">jade.runtime.</span>merge
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.runtime.rethrow">
            function <span class="apidocSignatureSpan">jade.runtime.</span>rethrow
            <span class="apidocSignatureSpan">(err, filename, lineno, str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.runtime.style">
            function <span class="apidocSignatureSpan">jade.runtime.</span>style
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.utils">module jade.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.utils.merge">
            function <span class="apidocSignatureSpan">jade.utils.</span>merge
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.utils.stringify">
            function <span class="apidocSignatureSpan">jade.utils.</span>stringify
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.utils.walkAST">
            function <span class="apidocSignatureSpan">jade.utils.</span>walkAST
            <span class="apidocSignatureSpan">(ast, before, after)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade" id="apidoc.module.jade">module jade</a></h1>


    <h2>
        <a href="#apidoc.element.jade.Compiler" id="apidoc.element.jade.Compiler">
        function <span class="apidocSignatureSpan">jade.</span>Compiler
        <span class="apidocSignatureSpan">(node, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Compiler(node, options) {
  this.options = options = options || {};
  this.node = node;
  this.hasCompiledDoctype = false;
  this.hasCompiledTag = false;
  this.pp = options.pretty || false;
  if (this.pp &amp;&amp; typeof this.pp !== 'string') {
    this.pp = '  ';
  }
  this.debug = false !== options.compileDebug;
  this.indents = 0;
  this.parentIndents = 0;
  this.terse = false;
  this.mixins = {};
  this.dynamicMixins = false;
  if (options.doctype) this.setDoctype(options.doctype);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer" id="apidoc.element.jade.Lexer">
        function <span class="apidocSignatureSpan">jade.</span>Lexer
        <span class="apidocSignatureSpan">(str, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Lexer(str, filename) {
  this.input = str.replace(/\r\n|\r/g, '\n');
  this.filename = filename;
  this.deferredTokens = [];
  this.lastIndents = 0;
  this.lineno = 1;
  this.stash = [];
  this.indentStack = [];
  this.indentRe = null;
  this.pipeless = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser" id="apidoc.element.jade.Parser">
        function <span class="apidocSignatureSpan">jade.</span>Parser
        <span class="apidocSignatureSpan">(str, filename, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(str, filename, options){
  //Strip any UTF-8 BOM off of the start of `str`, if it exists.
  this.input = str.replace(/^\uFEFF/, '');
  this.lexer = new Lexer(this.input, filename);
  this.filename = filename;
  this.blocks = {};
  this.mixins = {};
  this.options = options;
  this.contexts = [this];
  this.inMixin = 0;
  this.dependencies = [];
  this.inBlock = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.__express" id="apidoc.element.jade.__express">
        function <span class="apidocSignatureSpan">jade.</span>__express
        <span class="apidocSignatureSpan">(path, options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__express = function (path, options, fn) {
  if(options.compileDebug == undefined &amp;&amp; process.env.NODE_ENV === 'production') {
    options.compileDebug = false;
  }
  exports.renderFile(path, options, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.compile" id="apidoc.element.jade.compile">
        function <span class="apidocSignatureSpan">jade.</span>compile
        <span class="apidocSignatureSpan">(str, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (str, options){
  var options = options || {}
    , filename = options.filename
      ? utils.stringify(options.filename)
      : 'undefined'
    , fn;

  str = String(str);

  var parsed = parse(str, options);
  if (options.compileDebug !== false) {
    fn = [
        'var jade_debug = [ new jade.DebugItem( 1, ' + filename + ' ) ];'
      , 'try {'
      , parsed.body
      , '} catch (err) {'
      , '  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno' + (options.compileDebug === true ? ',' + utils.stringify
(str) : '') + ');'
      , '}'
    ].join('\n');
  } else {
    fn = parsed.body;
  }
  fn = new Function('locals, jade', fn)
  var res = function(locals){ return fn(locals, Object.create(runtime)) };
  if (options.client) {
    res.toString = function () {
      var err = new Error('The `client` option is deprecated, use the `jade.compileClient` method instead');
      err.name = 'Warning';
      console.error(err.stack || /* istanbul ignore next */ err.message);
      return exports.compileClient(str, options);
    };
  }
  res.dependencies = parsed.dependencies;
  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

For full API, see [jade-lang.com/api](http://jade-lang.com/api/)

```js
var jade = require('jade');

// compile
var fn = jade.<span class="apidocCodeKeywordSpan">compile</span>('string of jade', options);
var html = fn(locals);

// render
var html = jade.render('string of jade', merge(options, locals));

// renderFile
var html = jade.renderFile('filename.jade', merge(options, locals));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.compileClient" id="apidoc.element.jade.compileClient">
        function <span class="apidocSignatureSpan">jade.</span>compileClient
        <span class="apidocSignatureSpan">(str, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileClient = function (str, options) {
  return exports.compileClientWithDependenciesTracked(str, options).body;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  fn = new Function('locals, jade', fn)
  var res = function(locals){ return fn(locals, Object.create(runtime)) };
  if (options.client) {
    res.toString = function () {
      var err = new Error('The `client` option is deprecated, use the `jade.compileClient` method instead');
      err.name = 'Warning';
      console.error(err.stack || /* istanbul ignore next */ err.message);
      return exports.<span class="apidocCodeKeywordSpan">compileClient</span>(str, options);
    };
  }
  res.dependencies = parsed.dependencies;
  return res;
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.compileClientWithDependenciesTracked" id="apidoc.element.jade.compileClientWithDependenciesTracked">
        function <span class="apidocSignatureSpan">jade.</span>compileClientWithDependenciesTracked
        <span class="apidocSignatureSpan">(str, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileClientWithDependenciesTracked = function (str, options){
  var options = options || {};
  var name = options.name || 'template';
  var filename = options.filename ? utils.stringify(options.filename) : 'undefined';
  var fn;

  str = String(str);
  options.compileDebug = options.compileDebug ? true : false;
  var parsed = parse(str, options);
  if (options.compileDebug) {
    fn = [
        'var jade_debug = [ new jade.DebugItem( 1, ' + filename + ' ) ];'
      , 'try {'
      , parsed.body
      , '} catch (err) {'
      , '  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno, ' + utils.stringify(str) + ');'
      , '}'
    ].join('\n');
  } else {
    fn = parsed.body;
  }

  return {body: 'function ' + name + '(locals) {\n' + fn + '\n}', dependencies: parsed.dependencies};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @param {String} str
* @param {Options} options
* @return {String}
* @api public
*/
exports.compileClient = function (str, options) {
 return exports.<span class="apidocCodeKeywordSpan">compileClientWithDependenciesTracked</span>(str, options).body;
};

/**
* Compile a `Function` representation of the given jade file.
*
* Options:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.compileFile" id="apidoc.element.jade.compileFile">
        function <span class="apidocSignatureSpan">jade.</span>compileFile
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileFile = function (path, options) {
  options = options || {};
  options.filename = path;
  return handleTemplateCache(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.compileFileClient" id="apidoc.element.jade.compileFileClient">
        function <span class="apidocSignatureSpan">jade.</span>compileFileClient
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileFileClient = function (path, options){
  var key = path + ':client';
  options = options || {};

  options.filename = path;

  if (options.cache &amp;&amp; exports.cache[key]) {
    return exports.cache[key];
  }

  var str = fs.readFileSync(options.filename, 'utf8');
  var out = exports.compileClient(str, options);
  if (options.cache) exports.cache[key] = out;
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.filters" id="apidoc.element.jade.filters">
        function <span class="apidocSignatureSpan">jade.</span>filters
        <span class="apidocSignatureSpan">(name, str, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filter(name, str, options) {
  if (typeof filter[name] === 'function') {
    return filter[name](str, options);
  } else {
    var tr;
    try {
      tr = jstransformer(require('jstransformer-' + name));
    } catch (ex) {}
    if (tr) {
      // TODO: we may want to add a way for people to separately specify "locals"
      var result = tr.render(str, options, options).body;
      if (options &amp;&amp; options.minify) {
        try {
          switch (tr.outputFormat) {
            case 'js':
              result = uglify.minify(result, {fromString: true}).code;
              break;
            case 'css':
              result = new CleanCSS().minify(result).styles;
              break;
          }
        } catch (ex) {
          // better to fail to minify than output nothing
        }
      }
      return result;
    } else if (transformers[name]) {
      if (!warned[name]) {
        warned[name] = true;
        if (name === 'md' || name === 'markdown') {
          var implementation = getMarkdownImplementation();
          console.log('Transformers.' + name + ' is deprecated, you must replace the :' +
                      name + ' jade filter, with :' +
                      implementation + ' and install jstransformer-' +
                      implementation + ' before you update to jade@2.0.0.');
        } else if (alternatives[name]) {
          console.log('Transformers.' + name + ' is deprecated, you must replace the :' +
                      name + ' jade filter, with :' +
                      alternatives[name] + ' and install jstransformer-' +
                      alternatives[name] + ' before you update to jade@2.0.0.');
        } else {
          console.log('Transformers.' + name + ' is deprecated, to continue using the :' +
                      name + ' jade filter after jade@2.0.0, you will need to install jstransformer-' +
                      name.toLowerCase() + '.');
        }
      }
      return transformers[name].renderSync(str, options);
    } else {
      throw new Error('unknown filter ":' + name + '"');
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Block" id="apidoc.element.jade.nodes.Block">
        function <span class="apidocSignatureSpan">jade.</span>nodes.Block
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Block(node){
  this.nodes = [];
  if (node) this.push(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.BlockComment" id="apidoc.element.jade.nodes.BlockComment">
        function <span class="apidocSignatureSpan">jade.</span>nodes.BlockComment
        <span class="apidocSignatureSpan">(val, block, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BlockComment(val, block, buffer) {
  this.block = block;
  this.val = val;
  this.buffer = buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Case" id="apidoc.element.jade.nodes.Case">
        function <span class="apidocSignatureSpan">jade.</span>nodes.Case
        <span class="apidocSignatureSpan">(expr, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Case(expr, block){
  this.expr = expr;
  this.block = block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Code" id="apidoc.element.jade.nodes.Code">
        function <span class="apidocSignatureSpan">jade.</span>nodes.Code
        <span class="apidocSignatureSpan">(val, buffer, escape)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Code(val, buffer, escape) {
  this.val = val;
  this.buffer = buffer;
  this.escape = escape;
  if (val.match(/^ *else/)) this.debug = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Comment" id="apidoc.element.jade.nodes.Comment">
        function <span class="apidocSignatureSpan">jade.</span>nodes.Comment
        <span class="apidocSignatureSpan">(val, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Comment(val, buffer) {
  this.val = val;
  this.buffer = buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Doctype" id="apidoc.element.jade.nodes.Doctype">
        function <span class="apidocSignatureSpan">jade.</span>nodes.Doctype
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Doctype(val) {
  this.val = val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Each" id="apidoc.element.jade.nodes.Each">
        function <span class="apidocSignatureSpan">jade.</span>nodes.Each
        <span class="apidocSignatureSpan">(obj, val, key, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Each(obj, val, key, block) {
  this.obj = obj;
  this.val = val;
  this.key = key;
  this.block = block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Filter" id="apidoc.element.jade.nodes.Filter">
        function <span class="apidocSignatureSpan">jade.</span>nodes.Filter
        <span class="apidocSignatureSpan">(name, block, attrs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Filter(name, block, attrs) {
  this.name = name;
  this.block = block;
  this.attrs = attrs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Literal" id="apidoc.element.jade.nodes.Literal">
        function <span class="apidocSignatureSpan">jade.</span>nodes.Literal
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Literal(str) {
  this.str = str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Mixin" id="apidoc.element.jade.nodes.Mixin">
        function <span class="apidocSignatureSpan">jade.</span>nodes.Mixin
        <span class="apidocSignatureSpan">(name, args, block, call)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Mixin(name, args, block, call){
  Attrs.call(this);
  this.name = name;
  this.args = args;
  this.block = block;
  this.call = call;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.MixinBlock" id="apidoc.element.jade.nodes.MixinBlock">
        function <span class="apidocSignatureSpan">jade.</span>nodes.MixinBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MixinBlock(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Node" id="apidoc.element.jade.nodes.Node">
        function <span class="apidocSignatureSpan">jade.</span>nodes.Node
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Node(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Tag" id="apidoc.element.jade.nodes.Tag">
        function <span class="apidocSignatureSpan">jade.</span>nodes.Tag
        <span class="apidocSignatureSpan">(name, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Tag(name, block) {
  Attrs.call(this);
  this.name = name;
  this.block = block || new Block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Text" id="apidoc.element.jade.nodes.Text">
        function <span class="apidocSignatureSpan">jade.</span>nodes.Text
        <span class="apidocSignatureSpan">(line)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Text(line) {
  this.val = line;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.render" id="apidoc.element.jade.render">
        function <span class="apidocSignatureSpan">jade.</span>render
        <span class="apidocSignatureSpan">(str, options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">render = function (str, options, fn){
  // support callback API
  if ('function' == typeof options) {
    fn = options, options = undefined;
  }
  if (typeof fn === 'function') {
    var res
    try {
      res = exports.render(str, options);
    } catch (ex) {
      return fn(ex);
    }
    return fn(null, res);
  }

  options = options || {};

  // cache requires .filename
  if (options.cache &amp;&amp; !options.filename) {
    throw new Error('the "filename" option is required for caching');
  }

  return handleTemplateCache(options, str)(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var jade = require('jade');

// compile
var fn = jade.compile('string of jade', options);
var html = fn(locals);

// render
var html = jade.<span class="apidocCodeKeywordSpan">render</span>('string of jade', merge(options, locals));

// renderFile
var html = jade.renderFile('filename.jade', merge(options, locals));
```

### Options
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.renderFile" id="apidoc.element.jade.renderFile">
        function <span class="apidocSignatureSpan">jade.</span>renderFile
        <span class="apidocSignatureSpan">(path, options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renderFile = function (path, options, fn){
  // support callback API
  if ('function' == typeof options) {
    fn = options, options = undefined;
  }
  if (typeof fn === 'function') {
    var res
    try {
      res = exports.renderFile(path, options);
    } catch (ex) {
      return fn(ex);
    }
    return fn(null, res);
  }

  options = options || {};

  options.filename = path;
  return handleTemplateCache(options)(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fn = jade.compile('string of jade', options);
var html = fn(locals);

// render
var html = jade.render('string of jade', merge(options, locals));

// renderFile
var html = jade.<span class="apidocCodeKeywordSpan">renderFile</span>('filename.jade', merge(options, locals));
```

### Options

- `filename`  Used in exceptions, and required when using includes
- `compileDebug`  When `false` no debug instrumentation is compiled
- `pretty`    Add pretty-indentation whitespace to output _(false by default)_
...</pre></li>
    </ul>




















































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.Compiler" id="apidoc.module.jade.Compiler">module jade.Compiler</a></h1>


    <h2>
        <a href="#apidoc.element.jade.Compiler.Compiler" id="apidoc.element.jade.Compiler.Compiler">
        function <span class="apidocSignatureSpan">jade.</span>Compiler
        <span class="apidocSignatureSpan">(node, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Compiler(node, options) {
  this.options = options = options || {};
  this.node = node;
  this.hasCompiledDoctype = false;
  this.hasCompiledTag = false;
  this.pp = options.pretty || false;
  if (this.pp &amp;&amp; typeof this.pp !== 'string') {
    this.pp = '  ';
  }
  this.debug = false !== options.compileDebug;
  this.indents = 0;
  this.parentIndents = 0;
  this.terse = false;
  this.mixins = {};
  this.dynamicMixins = false;
  if (options.doctype) this.setDoctype(options.doctype);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.Compiler.prototype" id="apidoc.module.jade.Compiler.prototype">module jade.Compiler.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.attrs" id="apidoc.element.jade.Compiler.prototype.attrs">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>attrs
        <span class="apidocSignatureSpan">(attrs, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attrs = function (attrs, buffer){
  var buf = [];
  var classes = [];
  var classEscaping = [];

  attrs.forEach(function(attr){
    var key = attr.name;
    var escaped = attr.escaped;

    if (key === 'class') {
      classes.push(attr.val);
      classEscaping.push(attr.escaped);
    } else if (isConstant(attr.val)) {
      if (buffer) {
        this.buffer(runtime.attr(key, toConstant(attr.val), escaped, this.terse));
      } else {
        var val = toConstant(attr.val);
        if (key === 'style') val = runtime.style(val);
        if (escaped &amp;&amp; !(key.indexOf('data') === 0 &amp;&amp; typeof val !== 'string')) {
          val = runtime.escape(val);
        }
        buf.push(utils.stringify(key) + ': ' + utils.stringify(val));
      }
    } else {
      if (buffer) {
        this.bufferExpression('jade.attr("' + key + '", ' + attr.val + ', ' + utils.stringify(escaped) + ', ' + utils.stringify(
this.terse) + ')');
      } else {
        var val = attr.val;
        if (key === 'style') {
          val = 'jade.style(' + val + ')';
        }
        if (escaped &amp;&amp; !(key.indexOf('data') === 0)) {
          val = 'jade.escape(' + val + ')';
        } else if (escaped) {
          val = '(typeof (jade_interp = ' + val + ') == "string" ? jade.escape(jade_interp) : jade_interp)';
        }
        buf.push(utils.stringify(key) + ': ' + val);
      }
    }
  }.bind(this));
  if (buffer) {
    if (classes.every(isConstant)) {
      this.buffer(runtime.cls(classes.map(toConstant), classEscaping));
    } else {
      this.bufferExpression('jade.cls([' + classes.join(',') + '], ' + utils.stringify(classEscaping) + ')');
    }
  } else if (classes.length) {
    if (classes.every(isConstant)) {
      classes = utils.stringify(runtime.joinClasses(classes.map(toConstant).map(runtime.joinClasses).map(function (cls, i) {
        return classEscaping[i] ? runtime.escape(cls) : cls;
      })));
    } else {
      classes = '(jade_interp = ' + utils.stringify(classEscaping) + ',' +
        ' jade.joinClasses([' + classes.join(',') + '].map(jade.joinClasses).map(function (cls, i) {' +
        '   return jade_interp[i] ? jade.escape(cls) : cls' +
        ' }))' +
        ')';
    }
    if (classes.length)
      buf.push('"class": ' + classes);
  }
  return '{' + buf.join(',') + '}';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    this.buf.push('}');
  }
}

if (attrsBlocks.length) {
  if (attrs.length) {
    var val = this.<span class="apidocCodeKeywordSpan">attrs</span>(attrs);
    attrsBlocks.unshift(val);
  }
  this.buf.push('attributes: jade.merge([' + attrsBlocks.join(',') + '])');
} else if (attrs.length) {
  var val = this.attrs(attrs);
  this.buf.push('attributes: ' + val);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.buffer" id="apidoc.element.jade.Compiler.prototype.buffer">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>buffer
        <span class="apidocSignatureSpan">(str, interpolate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buffer = function (str, interpolate) {
  var self = this;
  if (interpolate) {
    var match = /(\\)?([#!]){((?:.|\n)*)$/.exec(str);
    if (match) {
      this.buffer(str.substr(0, match.index), false);
      if (match[1]) { // escape
        this.buffer(match[2] + '{', false);
        this.buffer(match[3], true);
        return;
      } else {
        var rest = match[3];
        var range = parseJSExpression(rest);
        var code = ('!' == match[2] ? '' : 'jade.escape') + "((jade_interp = " + range.src + ") == null ? '' : jade_interp)";
        this.bufferExpression(code);
        this.buffer(rest.substr(range.end + 1), true);
        return;
      }
    }
  }

  str = utils.stringify(str);
  str = str.substr(1, str.length - 2);

  if (this.lastBufferedIdx == this.buf.length) {
    if (this.lastBufferedType === 'code') this.lastBuffered += ' + "';
    this.lastBufferedType = 'text';
    this.lastBuffered += str;
    this.buf[this.lastBufferedIdx - 1] = 'buf.push(' + this.bufferStartChar + this.lastBuffered + '");'
  } else {
    this.buf.push('buf.push("' + str + '");');
    this.lastBufferedType = 'text';
    this.bufferStartChar = '"';
    this.lastBuffered = str;
    this.lastBufferedIdx = this.buf.length;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */

buffer: function (str, interpolate) {
  var self = this;
  if (interpolate) {
    var match = /(\\)?([#!]){((?:.|\n)*)$/.exec(str);
    if (match) {
      this.<span class="apidocCodeKeywordSpan">buffer</span>(str.substr(0, match.index), false);
      if (match[1]) { // escape
        this.buffer(match[2] + '{', false);
        this.buffer(match[3], true);
        return;
      } else {
        var rest = match[3];
        var range = parseJSExpression(rest);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.bufferExpression" id="apidoc.element.jade.Compiler.prototype.bufferExpression">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>bufferExpression
        <span class="apidocSignatureSpan">(src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferExpression = function (src) {
  if (isConstant(src)) {
    return this.buffer(toConstant(src) + '', false)
  }
  if (this.lastBufferedIdx == this.buf.length) {
    if (this.lastBufferedType === 'text') this.lastBuffered += '"';
    this.lastBufferedType = 'code';
    this.lastBuffered += ' + (' + src + ')';
    this.buf[this.lastBufferedIdx - 1] = 'buf.push(' + this.bufferStartChar + this.lastBuffered + ');'
  } else {
    this.buf.push('buf.push(' + src + ');');
    this.lastBufferedType = 'code';
    this.bufferStartChar = '';
    this.lastBuffered = '(' + src + ')';
    this.lastBufferedIdx = this.buf.length;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      this.buffer(match[2] + '{', false);
      this.buffer(match[3], true);
      return;
    } else {
      var rest = match[3];
      var range = parseJSExpression(rest);
      var code = ('!' == match[2] ? '' : 'jade.escape') + "((jade_interp = " + range.src
 + ") == null ? '' : jade_interp)";
      this.<span class="apidocCodeKeywordSpan">bufferExpression</span>(code);
      this.buffer(rest.substr(range.end + 1), true);
      return;
    }
  }
}

str = utils.stringify(str);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.compile" id="apidoc.element.jade.Compiler.prototype.compile">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (){
  this.buf = [];
  if (this.pp) this.buf.push("var jade_indent = [];");
  this.lastBufferedIdx = -1;
  this.visit(this.node);
  if (!this.dynamicMixins) {
    // if there are no dynamic mixins we can remove any un-used mixins
    var mixinNames = Object.keys(this.mixins);
    for (var i = 0; i &lt; mixinNames.length; i++) {
      var mixin = this.mixins[mixinNames[i]];
      if (!mixin.used) {
        for (var x = 0; x &lt; mixin.instances.length; x++) {
          for (var y = mixin.instances[x].start; y &lt; mixin.instances[x].end; y++) {
            this.buf[y] = '';
          }
        }
      }
    }
  }
  return this.buf.join('\n');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

For full API, see [jade-lang.com/api](http://jade-lang.com/api/)

```js
var jade = require('jade');

// compile
var fn = jade.<span class="apidocCodeKeywordSpan">compile</span>('string of jade', options);
var html = fn(locals);

// render
var html = jade.render('string of jade', merge(options, locals));

// renderFile
var html = jade.renderFile('filename.jade', merge(options, locals));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.prettyIndent" id="apidoc.element.jade.Compiler.prototype.prettyIndent">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>prettyIndent
        <span class="apidocSignatureSpan">(offset, newline)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prettyIndent = function (offset, newline){
  offset = offset || 0;
  newline = newline ? '\n' : '';
  this.buffer(newline + Array(this.indents + offset).join(this.pp));
  if (this.parentIndents)
    this.buf.push("buf.push.apply(buf, jade_indent);");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  visitBlock: function(block){
    var len = block.nodes.length
, escape = this.escape
, pp = this.pp

    // Pretty print multi-line text
    if (pp &amp;&amp; len &gt; 1 &amp;&amp; !escape &amp;&amp; block.nodes[0].isText &amp;&amp; block.nodes[1].isText)
this.<span class="apidocCodeKeywordSpan">prettyIndent</span>(1, true);

    for (var i = 0; i &lt; len; ++i) {
// Pretty print text
if (pp &amp;&amp; i &gt; 0 &amp;&amp; !escape &amp;&amp; block.nodes[i].isText &amp;&amp; block.nodes[i-1].isText)
  this.prettyIndent(1, false);

this.visit(block.nodes[i]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.setDoctype" id="apidoc.element.jade.Compiler.prototype.setDoctype">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>setDoctype
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setDoctype = function (name){
  this.doctype = doctypes[name.toLowerCase()] || '&lt;!DOCTYPE ' + name + '&gt;';
  this.terse = this.doctype.toLowerCase() == '&lt;!doctype html&gt;';
  this.xml = 0 == this.doctype.indexOf('&lt;?xml');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  this.debug = false !== options.compileDebug;
  this.indents = 0;
  this.parentIndents = 0;
  this.terse = false;
  this.mixins = {};
  this.dynamicMixins = false;
  if (options.doctype) this.<span class="apidocCodeKeywordSpan">setDoctype</span>(options.doctype);
};

/**
 * Compiler prototype.
 */

Compiler.prototype = {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visit" id="apidoc.element.jade.Compiler.prototype.visit">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visit
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visit = function (node){
  var debug = this.debug;

  if (debug) {
    this.buf.push('jade_debug.unshift(new jade.DebugItem( ' + node.line
      + ', ' + (node.filename
        ? utils.stringify(node.filename)
        : 'jade_debug[0].filename')
      + ' ));');
  }

  // Massive hack to fix our context
  // stack for - else[ if] etc
  if (false === node.debug &amp;&amp; this.debug) {
    this.buf.pop();
    this.buf.pop();
  }

  this.visitNode(node);

  if (debug) this.buf.push('jade_debug.shift();');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @api public
 */

compile: function(){
  this.buf = [];
  if (this.pp) this.buf.push("var jade_indent = [];");
  this.lastBufferedIdx = -1;
  this.<span class="apidocCodeKeywordSpan">visit</span>(this.node);
  if (!this.dynamicMixins) {
    // if there are no dynamic mixins we can remove any un-used mixins
    var mixinNames = Object.keys(this.mixins);
    for (var i = 0; i &lt; mixinNames.length; i++) {
      var mixin = this.mixins[mixinNames[i]];
      if (!mixin.used) {
        for (var x = 0; x &lt; mixin.instances.length; x++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitAttributes" id="apidoc.element.jade.Compiler.prototype.visitAttributes">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitAttributes
        <span class="apidocSignatureSpan">(attrs, attributeBlocks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitAttributes = function (attrs, attributeBlocks){
  if (attributeBlocks.length) {
    if (attrs.length) {
      var val = this.attrs(attrs);
      attributeBlocks.unshift(val);
    }
    this.bufferExpression('jade.attrs(jade.merge([' + attributeBlocks.join(',') + ']), ' + utils.stringify(this.terse) + ')');
  } else if (attrs.length) {
    this.attrs(attrs, true);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// pretty print
if (pp &amp;&amp; !tag.isInline())
  this.prettyIndent(0, true);

if (tag.selfClosing || (!this.xml &amp;&amp; selfClosing[tag.name])) {
  this.buffer('&lt;');
  bufferName();
  this.<span class="apidocCodeKeywordSpan">visitAttributes</span>(tag.attrs, tag.attributeBlocks.slice());
  this.terse
    ? this.buffer('&gt;')
    : this.buffer('/&gt;');
  // if it is non-empty throw an error
  if (tag.block &amp;&amp;
      !(tag.block.type === 'Block' &amp;&amp; tag.block.nodes.length === 0) &amp;&amp;
      tag.block.nodes.some(function (tag) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitBlock" id="apidoc.element.jade.Compiler.prototype.visitBlock">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitBlock
        <span class="apidocSignatureSpan">(block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitBlock = function (block){
  var len = block.nodes.length
    , escape = this.escape
    , pp = this.pp

  // Pretty print multi-line text
  if (pp &amp;&amp; len &gt; 1 &amp;&amp; !escape &amp;&amp; block.nodes[0].isText &amp;&amp; block.nodes[1].isText)
    this.prettyIndent(1, true);

  for (var i = 0; i &lt; len; ++i) {
    // Pretty print text
    if (pp &amp;&amp; i &gt; 0 &amp;&amp; !escape &amp;&amp; block.nodes[i].isText &amp;&amp; block.nodes[i-1].isText)
      this.prettyIndent(1, false);

    this.visit(block.nodes[i]);
    // Multiple text nodes are separated by newlines
    if (block.nodes[i+1] &amp;&amp; block.nodes[i].isText &amp;&amp; block.nodes[i+1].isText)
      this.buffer('\n');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitBlockComment" id="apidoc.element.jade.Compiler.prototype.visitBlockComment">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitBlockComment
        <span class="apidocSignatureSpan">(comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitBlockComment = function (comment){
  if (!comment.buffer) return;
  if (this.pp) this.prettyIndent(1, true);
  this.buffer('&lt;!--' + comment.val);
  this.visit(comment.block);
  if (this.pp) this.prettyIndent(1, true);
  this.buffer('--&gt;');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitCase" id="apidoc.element.jade.Compiler.prototype.visitCase">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitCase
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitCase = function (node){
  var _ = this.withinCase;
  this.withinCase = true;
  this.buf.push('switch (' + node.expr + '){');
  this.visit(node.block);
  this.buf.push('}');
  this.withinCase = _;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitCode" id="apidoc.element.jade.Compiler.prototype.visitCode">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitCode
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitCode = function (code){
  // Wrap code blocks with {}.
  // we only wrap unbuffered code blocks ATM
  // since they are usually flow control

  // Buffer code
  if (code.buffer) {
    var val = code.val.trim();
    val = 'null == (jade_interp = '+val+') ? "" : jade_interp';
    if (code.escape) val = 'jade.escape(' + val + ')';
    this.bufferExpression(val);
  } else {
    this.buf.push(code.val);
  }

  // Block support
  if (code.block) {
    if (!code.buffer) this.buf.push('{');
    this.visit(code.block);
    if (!code.buffer) this.buf.push('}');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
    } else {
// Optimize attributes buffering
this.buffer('&lt;');
bufferName();
this.visitAttributes(tag.attrs, tag.attributeBlocks.slice());
this.buffer('&gt;');
if (tag.code) this.<span class="apidocCodeKeywordSpan">visitCode</span>(tag.code);
this.visit(tag.block);

// pretty print
if (pp &amp;&amp; !tag.isInline() &amp;&amp; 'pre' != tag.name &amp;&amp; !tag.canInline())
  this.prettyIndent(0, true);

this.buffer('&lt;/');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitComment" id="apidoc.element.jade.Compiler.prototype.visitComment">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitComment
        <span class="apidocSignatureSpan">(comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitComment = function (comment){
  if (!comment.buffer) return;
  if (this.pp) this.prettyIndent(1, true);
  this.buffer('&lt;!--' + comment.val + '--&gt;');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitDoctype" id="apidoc.element.jade.Compiler.prototype.visitDoctype">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitDoctype
        <span class="apidocSignatureSpan">(doctype)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitDoctype = function (doctype){
  if (doctype &amp;&amp; (doctype.val || !this.doctype)) {
    this.setDoctype(doctype.val || 'default');
  }

  if (this.doctype) this.buffer(this.doctype);
  this.hasCompiledDoctype = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  else self.buffer(name);
}

if ('pre' == tag.name) this.escape = true;

if (!this.hasCompiledTag) {
  if (!this.hasCompiledDoctype &amp;&amp; 'html' == name) {
    this.<span class="apidocCodeKeywordSpan">visitDoctype</span>();
  }
  this.hasCompiledTag = true;
}

// pretty print
if (pp &amp;&amp; !tag.isInline())
  this.prettyIndent(0, true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitEach" id="apidoc.element.jade.Compiler.prototype.visitEach">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitEach
        <span class="apidocSignatureSpan">(each)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitEach = function (each){
  this.buf.push(''
    + '// iterate ' + each.obj + '\n'
    + ';(function(){\n'
    + '  var $$obj = ' + each.obj + ';\n'
    + '  if (\'number\' == typeof $$obj.length) {\n');

  if (each.alternative) {
    this.buf.push('  if ($$obj.length) {');
  }

  this.buf.push(''
    + '    for (var ' + each.key + ' = 0, $$l = $$obj.length; ' + each.key + ' &lt; $$l; ' + each.key + '++) {\n'
    + '      var ' + each.val + ' = $$obj[' + each.key + '];\n');

  this.visit(each.block);

  this.buf.push('    }\n');

  if (each.alternative) {
    this.buf.push('  } else {');
    this.visit(each.alternative);
    this.buf.push('  }');
  }

  this.buf.push(''
    + '  } else {\n'
    + '    var $$l = 0;\n'
    + '    for (var ' + each.key + ' in $$obj) {\n'
    + '      $$l++;'
    + '      var ' + each.val + ' = $$obj[' + each.key + '];\n');

  this.visit(each.block);

  this.buf.push('    }\n');
  if (each.alternative) {
    this.buf.push('    if ($$l === 0) {');
    this.visit(each.alternative);
    this.buf.push('    }');
  }
  this.buf.push('  }\n}).call(this);\n');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitFilter" id="apidoc.element.jade.Compiler.prototype.visitFilter">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitFilter
        <span class="apidocSignatureSpan">(filter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitFilter = function (filter){
  var text = filter.block.nodes.map(
    function(node){ return node.val; }
  ).join('\n');
  filter.attrs.filename = this.options.filename;
  try {
    this.buffer(filters(filter.name, text, filter.attrs), true);
  } catch (err) {
    throw errorAtNode(filter, err);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitLiteral" id="apidoc.element.jade.Compiler.prototype.visitLiteral">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitLiteral
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitLiteral = function (node){
  this.buffer(node.str);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitMixin" id="apidoc.element.jade.Compiler.prototype.visitMixin">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitMixin
        <span class="apidocSignatureSpan">(mixin)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitMixin = function (mixin){
  var name = 'jade_mixins[';
  var args = mixin.args || '';
  var block = mixin.block;
  var attrs = mixin.attrs;
  var attrsBlocks = mixin.attributeBlocks.slice();
  var pp = this.pp;
  var dynamic = mixin.name[0]==='#';
  var key = mixin.name;
  if (dynamic) this.dynamicMixins = true;
  name += (dynamic ? mixin.name.substr(2,mixin.name.length-3):'"'+mixin.name+'"')+']';

  this.mixins[key] = this.mixins[key] || {used: false, instances: []};
  if (mixin.call) {
    this.mixins[key].used = true;
    if (pp) this.buf.push("jade_indent.push('" + Array(this.indents + 1).join(pp) + "');")
    if (block || attrs.length || attrsBlocks.length) {

      this.buf.push(name + '.call({');

      if (block) {
        this.buf.push('block: function(){');

        // Render block with no indents, dynamically added when rendered
        this.parentIndents++;
        var _indents = this.indents;
        this.indents = 0;
        this.visit(mixin.block);
        this.indents = _indents;
        this.parentIndents--;

        if (attrs.length || attrsBlocks.length) {
          this.buf.push('},');
        } else {
          this.buf.push('}');
        }
      }

      if (attrsBlocks.length) {
        if (attrs.length) {
          var val = this.attrs(attrs);
          attrsBlocks.unshift(val);
        }
        this.buf.push('attributes: jade.merge([' + attrsBlocks.join(',') + '])');
      } else if (attrs.length) {
        var val = this.attrs(attrs);
        this.buf.push('attributes: ' + val);
      }

      if (args) {
        this.buf.push('}, ' + args + ');');
      } else {
        this.buf.push('});');
      }

    } else {
      this.buf.push(name + '(' + args + ');');
    }
    if (pp) this.buf.push("jade_indent.pop();")
  } else {
    var mixin_start = this.buf.length;
    args = args ? args.split(',') : [];
    var rest;
    if (args.length &amp;&amp; /^\.\.\./.test(args[args.length - 1].trim())) {
      rest = args.pop().trim().replace(/^\.\.\./, '');
    }
    // we need use jade_interp here for v8: https://code.google.com/p/v8/issues/detail?id=4165
    // once fixed, use this: this.buf.push(name + ' = function(' + args.join(',') + '){');
    this.buf.push(name + ' = jade_interp = function(' + args.join(',') + '){');
    this.buf.push('var block = (this &amp;&amp; this.block), attributes = (this &amp;&amp; this.attributes) || {};');
    if (rest) {
      this.buf.push('var ' + rest + ' = [];');
      this.buf.push('for (jade_interp = ' + args.length + '; jade_interp &lt; arguments.length; jade_interp++) {');
      this.buf.push('  ' + rest + '.push(arguments[jade_interp]);');
      this.buf.push('}');
    }
    this.parentIndents++;
    this.visit(block);
    this.parentIndents--;
    this.buf.push('};');
    var mixin_end = this.buf.length;
    this.mixins[key].instances.push({start: mixin_start, end: mixin_end});
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitMixinBlock" id="apidoc.element.jade.Compiler.prototype.visitMixinBlock">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitMixinBlock
        <span class="apidocSignatureSpan">(block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitMixinBlock = function (block){
  if (this.pp) this.buf.push("jade_indent.push('" + Array(this.indents + 1).join(this.pp) + "');");
  this.buf.push('block &amp;&amp; block();');
  if (this.pp) this.buf.push("jade_indent.pop();");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitNode" id="apidoc.element.jade.Compiler.prototype.visitNode">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitNode = function (node){
  return this['visit' + node.type](node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Massive hack to fix our context
  // stack for - else[ if] etc
  if (false === node.debug &amp;&amp; this.debug) {
    this.buf.pop();
    this.buf.pop();
  }

  this.<span class="apidocCodeKeywordSpan">visitNode</span>(node);

  if (debug) this.buf.push('jade_debug.shift();');
},

/**
 * Visit `node`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitTag" id="apidoc.element.jade.Compiler.prototype.visitTag">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitTag
        <span class="apidocSignatureSpan">(tag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitTag = function (tag){
  this.indents++;
  var name = tag.name
    , pp = this.pp
    , self = this;

  function bufferName() {
    if (tag.buffer) self.bufferExpression(name);
    else self.buffer(name);
  }

  if ('pre' == tag.name) this.escape = true;

  if (!this.hasCompiledTag) {
    if (!this.hasCompiledDoctype &amp;&amp; 'html' == name) {
      this.visitDoctype();
    }
    this.hasCompiledTag = true;
  }

  // pretty print
  if (pp &amp;&amp; !tag.isInline())
    this.prettyIndent(0, true);

  if (tag.selfClosing || (!this.xml &amp;&amp; selfClosing[tag.name])) {
    this.buffer('&lt;');
    bufferName();
    this.visitAttributes(tag.attrs, tag.attributeBlocks.slice());
    this.terse
      ? this.buffer('&gt;')
      : this.buffer('/&gt;');
    // if it is non-empty throw an error
    if (tag.block &amp;&amp;
        !(tag.block.type === 'Block' &amp;&amp; tag.block.nodes.length === 0) &amp;&amp;
        tag.block.nodes.some(function (tag) {
          return tag.type !== 'Text' || !/^\s*$/.test(tag.val)
        })) {
      throw errorAtNode(tag, new Error(name + ' is self closing and should not have content.'));
    }
  } else {
    // Optimize attributes buffering
    this.buffer('&lt;');
    bufferName();
    this.visitAttributes(tag.attrs, tag.attributeBlocks.slice());
    this.buffer('&gt;');
    if (tag.code) this.visitCode(tag.code);
    this.visit(tag.block);

    // pretty print
    if (pp &amp;&amp; !tag.isInline() &amp;&amp; 'pre' != tag.name &amp;&amp; !tag.canInline())
      this.prettyIndent(0, true);

    this.buffer('&lt;/');
    bufferName();
    this.buffer('&gt;');
  }

  if ('pre' == tag.name) this.escape = false;

  this.indents--;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitText" id="apidoc.element.jade.Compiler.prototype.visitText">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitText
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitText = function (text){
  this.buffer(text.val, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitWhen" id="apidoc.element.jade.Compiler.prototype.visitWhen">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitWhen
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitWhen = function (node){
  if ('default' == node.expr) {
    this.buf.push('default:');
  } else {
    this.buf.push('case ' + node.expr + ':');
  }
  if (node.block) {
    this.visit(node.block);
    this.buf.push('  break;');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.Lexer" id="apidoc.module.jade.Lexer">module jade.Lexer</a></h1>


    <h2>
        <a href="#apidoc.element.jade.Lexer.Lexer" id="apidoc.element.jade.Lexer.Lexer">
        function <span class="apidocSignatureSpan">jade.</span>Lexer
        <span class="apidocSignatureSpan">(str, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Lexer(str, filename) {
  this.input = str.replace(/\r\n|\r/g, '\n');
  this.filename = filename;
  this.deferredTokens = [];
  this.lastIndents = 0;
  this.lineno = 1;
  this.stash = [];
  this.indentStack = [];
  this.indentRe = null;
  this.pipeless = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.Lexer.prototype" id="apidoc.module.jade.Lexer.prototype">module jade.Lexer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.advance" id="apidoc.element.jade.Lexer.prototype.advance">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>advance
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">advance = function (){
  return this.stashed()
    || this.next();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Return the next token object.
 *
 * @return {Object}
 * @api private
 */

advance: function(){
  return this.lexer.<span class="apidocCodeKeywordSpan">advance</span>();
},

/**
 * Single token lookahead.
 *
 * @return {Object}
 * @api private
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.append" id="apidoc.element.jade.Lexer.prototype.append">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>append
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">append = function () {
  var captures;
  if (captures = /^append +([^\n]+)/.exec(this.input)) {
    this.consume(captures[0].length);
    var mode = 'append'
      , name = captures[1]
      , tok = this.tok('block', name);
    tok.mode = mode;
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.yield()
|| this.doctype()
|| this.interpolation()
|| this["case"]()
|| this.when()
|| this["default"]()
|| this["extends"]()
|| this.<span class="apidocCodeKeywordSpan">append</span>()
|| this.prepend()
|| this.block()
|| this.mixinBlock()
|| this.include()
|| this.includeFiltered()
|| this.mixin()
|| this.call()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.attributesBlock" id="apidoc.element.jade.Lexer.prototype.attributesBlock">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>attributesBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attributesBlock = function () {
  var captures;
  if (/^&amp;attributes\b/.test(this.input)) {
    this.consume(11);
    var args = this.bracketExpression();
    this.consume(args.end + 1);
    return this.tok('&amp;attributes', args.src);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.tag()
|| this.filter()
|| this.blockCode()
|| this.code()
|| this.id()
|| this.className()
|| this.attrs()
|| this.<span class="apidocCodeKeywordSpan">attributesBlock</span>()
|| this.indent()
|| this.text()
|| this.comment()
|| this.colon()
|| this.dot()
|| this.textFail()
|| this.fail();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.attrs" id="apidoc.element.jade.Lexer.prototype.attrs">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>attrs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attrs = function () {
  if ('(' == this.input.charAt(0)) {
    var index = this.bracketExpression().end
      , str = this.input.substr(1, index-1)
      , tok = this.tok('attrs');

    assertNestingCorrect(str);

    var quote = '';
    var interpolate = function (attr) {
      return attr.replace(/(\\)?#\{(.+)/g, function(_, escape, expr){
        if (escape) return _;
        try {
          var range = characterParser.parseMax(expr);
          if (expr[range.end] !== '}') return _.substr(0, 2) + interpolate(_.substr(2));
          assertExpression(range.src)
          return quote + " + (" + range.src + ") + " + quote + interpolate(expr.substr(range.end + 1));
        } catch (ex) {
          return _.substr(0, 2) + interpolate(_.substr(2));
        }
      });
    }

    this.consume(index + 1);
    tok.attrs = [];

    var escapedAttr = true
    var key = '';
    var val = '';
    var interpolatable = '';
    var state = characterParser.defaultState();
    var loc = 'key';
    var isEndOfAttribute = function (i) {
      if (key.trim() === '') return false;
      if (i === str.length) return true;
      if (loc === 'key') {
        if (str[i] === ' ' || str[i] === '\n') {
          for (var x = i; x &lt; str.length; x++) {
            if (str[x] != ' ' &amp;&amp; str[x] != '\n') {
              if (str[x] === '=' || str[x] === '!' || str[x] === ',') return false;
              else return true;
            }
          }
        }
        return str[i] === ','
      } else if (loc === 'value' &amp;&amp; !state.isNesting()) {
        try {
          assertExpression(val);
          if (str[i] === ' ' || str[i] === '\n') {
            for (var x = i; x &lt; str.length; x++) {
              if (str[x] != ' ' &amp;&amp; str[x] != '\n') {
                if (characterParser.isPunctuator(str[x]) &amp;&amp; str[x] != '"' &amp;&amp; str[x] != "'") return false;
                else return true;
              }
            }
          }
          return str[i] === ',';
        } catch (ex) {
          return false;
        }
      }
    }

    this.lineno += str.split("\n").length - 1;

    for (var i = 0; i &lt;= str.length; i++) {
      if (isEndOfAttribute(i)) {
        val = val.trim();
        if (val) assertExpression(val)
        key = key.trim();
        key = key.replace(/^['"]|['"]$/g, '');
        tok.attrs.push({
          name: key,
          val: '' == val ? true : val,
          escaped: escapedAttr
        });
        key = val = '';
        loc = 'key';
        escapedAttr = false;
      } else {
        switch (loc) {
          case 'key-char':
            if (str[i] === quote) {
              loc = 'key';
              if (i + 1 &lt; str.length &amp;&amp; [' ', ',', '!', '=', '\n'].indexOf(str[i + 1]) === -1)
                throw new Error('Unexpected character ' + str[i + 1] + ' expected ` `, `\\n`, `,`, `!` or `=`');
            } else {
              key += str[i];
            }
            break;
          case 'key':
            if (key === '' &amp;&amp; (str[i] === '"' || str[i] === "'")) {
              loc = 'key-char';
              quote = str[i];
            } else if (str[i] === '!' || str[i] === '=') {
              escapedAttr = str[i] !== '!';
              if (str[i] === '!') i++;
              if (str[i] !== '=') throw new Error('Unexpected character ' + str[i] + ' expected `=`');
              loc = 'value';
              state = characterParser.defaultState();
            } else {
              key += str[i]
            }
            break;
          case 'value':
            state = characterParser.parseChar(str[i], state);
            if (state.isString()) {
              loc = 'string';
              quote = str[i];
              interpolatable = str[i];
            } else {
              val += str[i];
            }
            break;
          case 'string':
            state = characterParser.parseChar(str[i], state);
            interpolatable += str[i];
            if (!state.isString()) {
              loc = 'value';
              val += interpolate(interpolatable);
            }
            break;
        }
      }
    }

    if ('/' == this.input.char ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    this.buf.push('}');
  }
}

if (attrsBlocks.length) {
  if (attrs.length) {
    var val = this.<span class="apidocCodeKeywordSpan">attrs</span>(attrs);
    attrsBlocks.unshift(val);
  }
  this.buf.push('attributes: jade.merge([' + attrsBlocks.join(',') + '])');
} else if (attrs.length) {
  var val = this.attrs(attrs);
  this.buf.push('attributes: ' + val);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.blank" id="apidoc.element.jade.Lexer.prototype.blank">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>blank
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">blank = function () {
  var captures;
  if (captures = /^\n *\n/.exec(this.input)) {
    this.consume(captures[0].length - 1);
    ++this.lineno;
    if (this.pipeless) return this.tok('text', '');
    return this.next();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @return {Object}
 * @api private
 */

next: function() {
  return this.deferred()
    || this.<span class="apidocCodeKeywordSpan">blank</span>()
    || this.eos()
    || this.pipelessText()
    || this.yield()
    || this.doctype()
    || this.interpolation()
    || this["case"]()
    || this.when()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.block" id="apidoc.element.jade.Lexer.prototype.block">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>block
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block = function () {
  var captures;
  if (captures = /^block\b *(?:(prepend|append) +)?([^\n]+)/.exec(this.input)) {
    this.consume(captures[0].length);
    var mode = captures[1] || 'replace'
      , name = captures[2]
      , tok = this.tok('block', name);

    tok.mode = mode;
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.interpolation()
|| this["case"]()
|| this.when()
|| this["default"]()
|| this["extends"]()
|| this.append()
|| this.prepend()
|| this.<span class="apidocCodeKeywordSpan">block</span>()
|| this.mixinBlock()
|| this.include()
|| this.includeFiltered()
|| this.mixin()
|| this.call()
|| this.conditional()
|| this.each()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.blockCode" id="apidoc.element.jade.Lexer.prototype.blockCode">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>blockCode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">blockCode = function () {
  var captures;
  if (captures = /^-\n/.exec(this.input)) {
    this.consume(captures[0].length - 1);
    var tok = this.tok('blockCode');
    this.pipeless = true;
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.mixin()
|| this.call()
|| this.conditional()
|| this.each()
|| this["while"]()
|| this.tag()
|| this.filter()
|| this.<span class="apidocCodeKeywordSpan">blockCode</span>()
|| this.code()
|| this.id()
|| this.className()
|| this.attrs()
|| this.attributesBlock()
|| this.indent()
|| this.text()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.bracketExpression" id="apidoc.element.jade.Lexer.prototype.bracketExpression">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>bracketExpression
        <span class="apidocSignatureSpan">(skip)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bracketExpression = function (skip){
  skip = skip || 0;
  var start = this.input[skip];
  if (start != '(' &amp;&amp; start != '{' &amp;&amp; start != '[') throw new Error('unrecognized start character');
  var end = ({'(': ')', '{': '}', '[': ']'})[start];
  var range = characterParser.parseMax(this.input, {start: skip + 1});
  if (this.input[range.end] !== end) throw new Error('start character ' + start + ' does not match end character ' + this.input[
range.end]);
  return range;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Interpolated tag.
 */

interpolation: function() {
  if (/^#\{/.test(this.input)) {
    var match = this.<span class="apidocCodeKeywordSpan">bracketExpression</span>(1);

    this.consume(match.end + 1);
    return this.tok('interpolation', match.src);
  }
},

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.call" id="apidoc.element.jade.Lexer.prototype.call">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>call
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">call = function (){

  var tok, captures;
  if (captures = /^\+(\s*)(([-\w]+)|(#\{))/.exec(this.input)) {
    // try to consume simple or interpolated call
    if (captures[3]) {
      // simple call
      this.consume(captures[0].length);
      tok = this.tok('call', captures[3]);
    } else {
      // interpolated call
      var match = this.bracketExpression(2 + captures[1].length);
      this.consume(match.end + 1);
      assertExpression(match.src);
      tok = this.tok('call', '#{'+match.src+'}');
    }

    // Check for args (not attributes)
    if (captures = /^ *\(/.exec(this.input)) {
      var range = this.bracketExpression(captures[0].length - 1);
      if (!/^\s*[-\w]+ *=/.test(range.src)) { // not attributes
        this.consume(range.end + 1);
        tok.args = range.src;
      }
      if (tok.args) {
        assertExpression('[' + tok.args + ']');
      }
    }

    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...







(function(f){if(typeof exports==="object"&amp;&amp;typeof module!=="undefined"){module.exports=f()}else if
(typeof define==="function"&amp;&amp;define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g
=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}
g.jade = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof
require=="function"&amp;&amp;require;if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot
 find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].<span class="apidocCodeKeywordSpan">call</span>(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n
[o].exports}var i=typeof require=="function"&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[
function(require,module,exports){
(function (process){
'use strict';

/*!
* Jade
* Copyright(c) 2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt;
* MIT Licensed
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.case" id="apidoc.element.jade.Lexer.prototype.case">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>case
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">case = function () {
  return this.scan(/^case +([^\n]+)/, 'case');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.className" id="apidoc.element.jade.Lexer.prototype.className">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>className
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">className = function () {
  return this.scan(/^\.([\w-]+)/, 'class');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.each()
|| this["while"]()
|| this.tag()
|| this.filter()
|| this.blockCode()
|| this.code()
|| this.id()
|| this.<span class="apidocCodeKeywordSpan">className</span>()
|| this.attrs()
|| this.attributesBlock()
|| this.indent()
|| this.text()
|| this.comment()
|| this.colon()
|| this.dot()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.code" id="apidoc.element.jade.Lexer.prototype.code">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>code
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">code = function () {
  var captures;
  if (captures = /^(!?=|-)[ \t]*([^\n]+)/.exec(this.input)) {
    this.consume(captures[0].length);
    var flags = captures[1];
    captures[1] = captures[2];
    var tok = this.tok('code', captures[1]);
    tok.escape = flags.charAt(0) === '=';
    tok.buffer = flags.charAt(0) === '=' || flags.charAt(1) === '=';
    if (tok.buffer) assertExpression(captures[1])
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.call()
|| this.conditional()
|| this.each()
|| this["while"]()
|| this.tag()
|| this.filter()
|| this.blockCode()
|| this.<span class="apidocCodeKeywordSpan">code</span>()
|| this.id()
|| this.className()
|| this.attrs()
|| this.attributesBlock()
|| this.indent()
|| this.text()
|| this.comment()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.colon" id="apidoc.element.jade.Lexer.prototype.colon">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>colon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">colon = function () {
  var good = /^: +/.test(this.input);
  var res = this.scan(/^: */, ':');
  if (res &amp;&amp; !good) {
    console.warn('Warning: space required after `:` on line ' + this.lineno +
        ' of jade file "' + this.filename + '"');
  }
  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      || this.id()
      || this.className()
      || this.attrs()
      || this.attributesBlock()
      || this.indent()
      || this.text()
      || this.comment()
      || this.<span class="apidocCodeKeywordSpan">colon</span>()
      || this.dot()
      || this.textFail()
      || this.fail();
  }
};

},{"./utils":25,"character-parser":29}],7:[function(require,module,exports){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.comment" id="apidoc.element.jade.Lexer.prototype.comment">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>comment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comment = function () {
  var captures;
  if (captures = /^\/\/(-)?([^\n]*)/.exec(this.input)) {
    this.consume(captures[0].length);
    var tok = this.tok('comment', captures[2]);
    tok.buffer = '-' != captures[1];
    this.pipeless = true;
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      || this.code()
      || this.id()
      || this.className()
      || this.attrs()
      || this.attributesBlock()
      || this.indent()
      || this.text()
      || this.<span class="apidocCodeKeywordSpan">comment</span>()
      || this.colon()
      || this.dot()
      || this.textFail()
      || this.fail();
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.conditional" id="apidoc.element.jade.Lexer.prototype.conditional">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>conditional
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">conditional = function () {
  var captures;
  if (captures = /^(if|unless|else if|else)\b([^\n]*)/.exec(this.input)) {
    this.consume(captures[0].length);
    var type = captures[1]
    var js = captures[2];
    var isIf = false;
    var isElse = false;

    switch (type) {
      case 'if':
        assertExpression(js)
        js = 'if (' + js + ')';
        isIf = true;
        break;
      case 'unless':
        assertExpression(js)
        js = 'if (!(' + js + '))';
        isIf = true;
        break;
      case 'else if':
        assertExpression(js)
        js = 'else if (' + js + ')';
        isIf = true;
        isElse = true;
        break;
      case 'else':
        if (js &amp;&amp; js.trim()) {
          throw new Error('`else` cannot have a condition, perhaps you meant `else if`');
        }
        js = 'else';
        isElse = true;
        break;
    }
    var tok = this.tok('code', js);
    tok.isElse = isElse;
    tok.isIf = isIf;
    tok.requiresBlock = true;
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.prepend()
|| this.block()
|| this.mixinBlock()
|| this.include()
|| this.includeFiltered()
|| this.mixin()
|| this.call()
|| this.<span class="apidocCodeKeywordSpan">conditional</span>()
|| this.each()
|| this["while"]()
|| this.tag()
|| this.filter()
|| this.blockCode()
|| this.code()
|| this.id()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.consume" id="apidoc.element.jade.Lexer.prototype.consume">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>consume
        <span class="apidocSignatureSpan">(len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">consume = function (len){
  this.input = this.input.substr(len);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {Object}
 * @api private
 */

scan: function(regexp, type){
  var captures;
  if (captures = regexp.exec(this.input)) {
    this.<span class="apidocCodeKeywordSpan">consume</span>(captures[0].length);
    return this.tok(type, captures[1]);
  }
},

/**
 * Defer the given `tok`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.default" id="apidoc.element.jade.Lexer.prototype.default">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>default
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">default = function () {
  return this.scan(/^default */, 'default');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.defer" id="apidoc.element.jade.Lexer.prototype.defer">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>defer
        <span class="apidocSignatureSpan">(tok)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defer = function (tok){
  this.deferredTokens.push(tok);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var captures;
if (captures = /^(\w[-:\w]*)(\/?)/.exec(this.input)) {
  this.consume(captures[0].length);
  var tok, name = captures[1];
  if (':' == name[name.length - 1]) {
    name = name.slice(0, -1);
    tok = this.tok('tag', name);
    this.<span class="apidocCodeKeywordSpan">defer</span>(this.tok(':'));
    if (this.input[0] !== ' ') {
      console.warn('Warning: space required after `:` on line ' + this.lineno +
          ' of jade file "' + this.filename + '"');
    }
    while (' ' == this.input[0]) this.input = this.input.substr(1);
  } else {
    tok = this.tok('tag', name);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.deferred" id="apidoc.element.jade.Lexer.prototype.deferred">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>deferred
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deferred = function () {
  return this.deferredTokens.length
    &amp;&amp; this.deferredTokens.shift();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Return the next token object.
 *
 * @return {Object}
 * @api private
 */

next: function() {
  return this.<span class="apidocCodeKeywordSpan">deferred</span>()
    || this.blank()
    || this.eos()
    || this.pipelessText()
    || this.yield()
    || this.doctype()
    || this.interpolation()
    || this["case"]()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.doctype" id="apidoc.element.jade.Lexer.prototype.doctype">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>doctype
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doctype = function () {
  if (this.scan(/^!!! *([^\n]+)?/, 'doctype')) {
    throw new Error('`!!!` is deprecated, you must now use `doctype`');
  }
  var node = this.scan(/^(?:doctype) *([^\n]+)?/, 'doctype');
  if (node &amp;&amp; node.val &amp;&amp; node.val.trim() === '5') {
    throw new Error('`doctype 5` is deprecated, you must now use `doctype html`');
  }
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  next: function() {
return this.deferred()
  || this.blank()
  || this.eos()
  || this.pipelessText()
  || this.yield()
  || this.<span class="apidocCodeKeywordSpan">doctype</span>()
  || this.interpolation()
  || this["case"]()
  || this.when()
  || this["default"]()
  || this["extends"]()
  || this.append()
  || this.prepend()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.dot" id="apidoc.element.jade.Lexer.prototype.dot">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>dot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dot = function () {
  var match;
  if (match = this.scan(/^\./, 'dot')) {
    this.pipeless = true;
    return match;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      || this.className()
      || this.attrs()
      || this.attributesBlock()
      || this.indent()
      || this.text()
      || this.comment()
      || this.colon()
      || this.<span class="apidocCodeKeywordSpan">dot</span>()
      || this.textFail()
      || this.fail();
  }
};

},{"./utils":25,"character-parser":29}],7:[function(require,module,exports){
'use strict';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.each" id="apidoc.element.jade.Lexer.prototype.each">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>each
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">each = function () {
  var captures;
  if (captures = /^(?:- *)?(?:each|for) +([a-zA-Z_$][\w$]*)(?: *, *([a-zA-Z_$][\w$]*))? * in *([^\n]+)/.exec(this.input)) {
    this.consume(captures[0].length);
    var tok = this.tok('each', captures[1]);
    tok.key = captures[2] || '$index';
    assertExpression(captures[3])
    tok.code = captures[3];
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.block()
|| this.mixinBlock()
|| this.include()
|| this.includeFiltered()
|| this.mixin()
|| this.call()
|| this.conditional()
|| this.<span class="apidocCodeKeywordSpan">each</span>()
|| this["while"]()
|| this.tag()
|| this.filter()
|| this.blockCode()
|| this.code()
|| this.id()
|| this.className()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.eos" id="apidoc.element.jade.Lexer.prototype.eos">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>eos
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eos = function () {
  if (this.input.length) return;
  if (this.indentStack.length) {
    this.indentStack.shift();
    return this.tok('outdent');
  } else {
    return this.tok('eos');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {Object}
 * @api private
 */

next: function() {
  return this.deferred()
    || this.blank()
    || this.<span class="apidocCodeKeywordSpan">eos</span>()
    || this.pipelessText()
    || this.yield()
    || this.doctype()
    || this.interpolation()
    || this["case"]()
    || this.when()
    || this["default"]()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.extends" id="apidoc.element.jade.Lexer.prototype.extends">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>extends
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extends = function () {
  return this.scan(/^extends? +([^\n]+)/, 'extends');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.fail" id="apidoc.element.jade.Lexer.prototype.fail">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>fail
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fail = function () {
  throw new Error('unexpected text ' + this.input.substr(0, 5));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      || this.attributesBlock()
      || this.indent()
      || this.text()
      || this.comment()
      || this.colon()
      || this.dot()
      || this.textFail()
      || this.<span class="apidocCodeKeywordSpan">fail</span>();
  }
};

},{"./utils":25,"character-parser":29}],7:[function(require,module,exports){
'use strict';

var Node = require('./node');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.filter" id="apidoc.element.jade.Lexer.prototype.filter">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>filter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function () {
  var tok = this.scan(/^:([\w\-]+)/, 'filter');
  if (tok) {
    this.pipeless = true;
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.includeFiltered()
|| this.mixin()
|| this.call()
|| this.conditional()
|| this.each()
|| this["while"]()
|| this.tag()
|| this.<span class="apidocCodeKeywordSpan">filter</span>()
|| this.blockCode()
|| this.code()
|| this.id()
|| this.className()
|| this.attrs()
|| this.attributesBlock()
|| this.indent()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.id" id="apidoc.element.jade.Lexer.prototype.id">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>id
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">id = function () {
  return this.scan(/^#([\w-]+)/, 'id');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.conditional()
|| this.each()
|| this["while"]()
|| this.tag()
|| this.filter()
|| this.blockCode()
|| this.code()
|| this.<span class="apidocCodeKeywordSpan">id</span>()
|| this.className()
|| this.attrs()
|| this.attributesBlock()
|| this.indent()
|| this.text()
|| this.comment()
|| this.colon()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.include" id="apidoc.element.jade.Lexer.prototype.include">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>include
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">include = function () {
  return this.scan(/^include +([^\n]+)/, 'include');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.when()
|| this["default"]()
|| this["extends"]()
|| this.append()
|| this.prepend()
|| this.block()
|| this.mixinBlock()
|| this.<span class="apidocCodeKeywordSpan">include</span>()
|| this.includeFiltered()
|| this.mixin()
|| this.call()
|| this.conditional()
|| this.each()
|| this["while"]()
|| this.tag()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.includeFiltered" id="apidoc.element.jade.Lexer.prototype.includeFiltered">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>includeFiltered
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">includeFiltered = function () {
  var captures;
  if (captures = /^include:([\w\-]+)([\( ])/.exec(this.input)) {
    this.consume(captures[0].length - 1);
    var filter = captures[1];
    var attrs = captures[2] === '(' ? this.attrs() : null;
    if (!(captures[2] === ' ' || this.input[0] === ' ')) {
      throw new Error('expected space after include:filter but got ' + utils.stringify(this.input[0]));
    }
    captures = /^ *([^\n]+)/.exec(this.input);
    if (!captures || captures[1].trim() === '') {
      throw new Error('missing path for include:filter');
    }
    this.consume(captures[0].length);
    var path = captures[1];
    var tok = this.tok('include', path);
    tok.filter = filter;
    tok.attrs = attrs;
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this["default"]()
|| this["extends"]()
|| this.append()
|| this.prepend()
|| this.block()
|| this.mixinBlock()
|| this.include()
|| this.<span class="apidocCodeKeywordSpan">includeFiltered</span>()
|| this.mixin()
|| this.call()
|| this.conditional()
|| this.each()
|| this["while"]()
|| this.tag()
|| this.filter()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.indent" id="apidoc.element.jade.Lexer.prototype.indent">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>indent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indent = function () {
  var captures, re;

  // established regexp
  if (this.indentRe) {
    captures = this.indentRe.exec(this.input);
  // determine regexp
  } else {
    // tabs
    re = /^\n(\t*) */;
    captures = re.exec(this.input);

    // spaces
    if (captures &amp;&amp; !captures[1].length) {
      re = /^\n( *)/;
      captures = re.exec(this.input);
    }

    // established
    if (captures &amp;&amp; captures[1].length) this.indentRe = re;
  }

  if (captures) {
    var tok
      , indents = captures[1].length;

    ++this.lineno;
    this.consume(indents + 1);

    if (' ' == this.input[0] || '\t' == this.input[0]) {
      throw new Error('Invalid indentation, you can use tabs or spaces but not both');
    }

    // blank line
    if ('\n' == this.input[0]) {
      this.pipeless = false;
      return this.tok('newline');
    }

    // outdent
    if (this.indentStack.length &amp;&amp; indents &lt; this.indentStack[0]) {
      while (this.indentStack.length &amp;&amp; this.indentStack[0] &gt; indents) {
        this.stash.push(this.tok('outdent'));
        this.indentStack.shift();
      }
      tok = this.stash.pop();
    // indent
    } else if (indents &amp;&amp; indents != this.indentStack[0]) {
      this.indentStack.unshift(indents);
      tok = this.tok('indent', indents);
    // newline
    } else {
      tok = this.tok('newline');
    }

    this.pipeless = false;
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    || this.filter()
    || this.blockCode()
    || this.code()
    || this.id()
    || this.className()
    || this.attrs()
    || this.attributesBlock()
    || this.<span class="apidocCodeKeywordSpan">indent</span>()
    || this.text()
    || this.comment()
    || this.colon()
    || this.dot()
    || this.textFail()
    || this.fail();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.interpolation" id="apidoc.element.jade.Lexer.prototype.interpolation">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>interpolation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interpolation = function () {
  if (/^#\{/.test(this.input)) {
    var match = this.bracketExpression(1);

    this.consume(match.end + 1);
    return this.tok('interpolation', match.src);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  next: function() {
return this.deferred()
  || this.blank()
  || this.eos()
  || this.pipelessText()
  || this.yield()
  || this.doctype()
  || this.<span class="apidocCodeKeywordSpan">interpolation</span>()
  || this["case"]()
  || this.when()
  || this["default"]()
  || this["extends"]()
  || this.append()
  || this.prepend()
  || this.block()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.lookahead" id="apidoc.element.jade.Lexer.prototype.lookahead">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>lookahead
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookahead = function (n){
  var fetch = n - this.stash.length;
  while (fetch-- &gt; 0) this.stash.push(this.next());
  return this.stash[--n];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Single token lookahead.
 *
 * @return {Object}
 * @api private
 */

peek: function() {
  return this.<span class="apidocCodeKeywordSpan">lookahead</span>(1);
},

/**
 * Return lexer lineno.
 *
 * @return {Number}
 * @api private
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.mixin" id="apidoc.element.jade.Lexer.prototype.mixin">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>mixin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixin = function (){
  var captures;
  if (captures = /^mixin +([-\w]+)(?: *\((.*)\))? */.exec(this.input)) {
    this.consume(captures[0].length);
    var tok = this.tok('mixin', captures[1]);
    tok.args = captures[2];
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this["extends"]()
|| this.append()
|| this.prepend()
|| this.block()
|| this.mixinBlock()
|| this.include()
|| this.includeFiltered()
|| this.<span class="apidocCodeKeywordSpan">mixin</span>()
|| this.call()
|| this.conditional()
|| this.each()
|| this["while"]()
|| this.tag()
|| this.filter()
|| this.blockCode()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.mixinBlock" id="apidoc.element.jade.Lexer.prototype.mixinBlock">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>mixinBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixinBlock = function () {
  var captures;
  if (captures = /^block[ \t]*(\n|$)/.exec(this.input)) {
    this.consume(captures[0].length - captures[1].length);
    return this.tok('mixin-block');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this["case"]()
|| this.when()
|| this["default"]()
|| this["extends"]()
|| this.append()
|| this.prepend()
|| this.block()
|| this.<span class="apidocCodeKeywordSpan">mixinBlock</span>()
|| this.include()
|| this.includeFiltered()
|| this.mixin()
|| this.call()
|| this.conditional()
|| this.each()
|| this["while"]()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.next" id="apidoc.element.jade.Lexer.prototype.next">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>next
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">next = function () {
  return this.deferred()
    || this.blank()
    || this.eos()
    || this.pipelessText()
    || this.yield()
    || this.doctype()
    || this.interpolation()
    || this["case"]()
    || this.when()
    || this["default"]()
    || this["extends"]()
    || this.append()
    || this.prepend()
    || this.block()
    || this.mixinBlock()
    || this.include()
    || this.includeFiltered()
    || this.mixin()
    || this.call()
    || this.conditional()
    || this.each()
    || this["while"]()
    || this.tag()
    || this.filter()
    || this.blockCode()
    || this.code()
    || this.id()
    || this.className()
    || this.attrs()
    || this.attributesBlock()
    || this.indent()
    || this.text()
    || this.comment()
    || this.colon()
    || this.dot()
    || this.textFail()
    || this.fail();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Number} n
 * @return {Object}
 * @api private
 */

lookahead: function(n){
  var fetch = n - this.stash.length;
  while (fetch-- &gt; 0) this.stash.push(this.<span class="apidocCodeKeywordSpan">next</span>());
  return this.stash[--n];
},

/**
 * Return the indexOf `(` or `{` or `[` / `)` or `}` or `]` delimiters.
 *
 * @return {Number}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.pipelessText" id="apidoc.element.jade.Lexer.prototype.pipelessText">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>pipelessText
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipelessText = function () {
  if (!this.pipeless) return;
  var captures, re;

  // established regexp
  if (this.indentRe) {
    captures = this.indentRe.exec(this.input);
  // determine regexp
  } else {
    // tabs
    re = /^\n(\t*) */;
    captures = re.exec(this.input);

    // spaces
    if (captures &amp;&amp; !captures[1].length) {
      re = /^\n( *)/;
      captures = re.exec(this.input);
    }

    // established
    if (captures &amp;&amp; captures[1].length) this.indentRe = re;
  }

  var indents = captures &amp;&amp; captures[1].length;
  if (indents &amp;&amp; (this.indentStack.length === 0 || indents &gt; this.indentStack[0])) {
    var indent = captures[1];
    var line;
    var tokens = [];
    var isMatch;
    do {
      // text has `\n` as a prefix
      var i = this.input.substr(1).indexOf('\n');
      if (-1 == i) i = this.input.length - 1;
      var str = this.input.substr(1, i);
      isMatch = str.substr(0, indent.length) === indent || !str.trim();
      if (isMatch) {
        // consume test along with `\n` prefix if match
        this.consume(str.length + 1);
        ++this.lineno;
        tokens.push(str.substr(indent.length));
      }
    } while(this.input.length &amp;&amp; isMatch);
    while (this.input.length === 0 &amp;&amp; tokens[tokens.length - 1] === '') tokens.pop();
    return this.tok('pipeless-text', tokens);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @api private
 */

next: function() {
  return this.deferred()
    || this.blank()
    || this.eos()
    || this.<span class="apidocCodeKeywordSpan">pipelessText</span>()
    || this.yield()
    || this.doctype()
    || this.interpolation()
    || this["case"]()
    || this.when()
    || this["default"]()
    || this["extends"]()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.prepend" id="apidoc.element.jade.Lexer.prototype.prepend">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>prepend
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepend = function () {
  var captures;
  if (captures = /^prepend +([^\n]+)/.exec(this.input)) {
    this.consume(captures[0].length);
    var mode = 'prepend'
      , name = captures[1]
      , tok = this.tok('block', name);
    tok.mode = mode;
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.doctype()
|| this.interpolation()
|| this["case"]()
|| this.when()
|| this["default"]()
|| this["extends"]()
|| this.append()
|| this.<span class="apidocCodeKeywordSpan">prepend</span>()
|| this.block()
|| this.mixinBlock()
|| this.include()
|| this.includeFiltered()
|| this.mixin()
|| this.call()
|| this.conditional()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.scan" id="apidoc.element.jade.Lexer.prototype.scan">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>scan
        <span class="apidocSignatureSpan">(regexp, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scan = function (regexp, type){
  var captures;
  if (captures = regexp.exec(this.input)) {
    this.consume(captures[0].length);
    return this.tok(type, captures[1]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

/**
 * Filter.
 */

filter: function() {
  var tok = this.<span class="apidocCodeKeywordSpan">scan</span>(/^:([\w\-]+)/, 'filter');
  if (tok) {
    this.pipeless = true;
    return tok;
  }
},

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.stashed" id="apidoc.element.jade.Lexer.prototype.stashed">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>stashed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stashed = function () {
  return this.stash.length
    &amp;&amp; this.stash.shift();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * previously stashed by lookahead.
 *
 * @return {Object}
 * @api private
 */

advance: function(){
  return this.<span class="apidocCodeKeywordSpan">stashed</span>()
    || this.next();
},

/**
 * Return the next token object.
 *
 * @return {Object}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.tag" id="apidoc.element.jade.Lexer.prototype.tag">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>tag
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tag = function () {
  var captures;
  if (captures = /^(\w[-:\w]*)(\/?)/.exec(this.input)) {
    this.consume(captures[0].length);
    var tok, name = captures[1];
    if (':' == name[name.length - 1]) {
      name = name.slice(0, -1);
      tok = this.tok('tag', name);
      this.defer(this.tok(':'));
      if (this.input[0] !== ' ') {
        console.warn('Warning: space required after `:` on line ' + this.lineno +
            ' of jade file "' + this.filename + '"');
      }
      while (' ' == this.input[0]) this.input = this.input.substr(1);
    } else {
      tok = this.tok('tag', name);
    }
    tok.selfClosing = !!captures[2];
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.include()
|| this.includeFiltered()
|| this.mixin()
|| this.call()
|| this.conditional()
|| this.each()
|| this["while"]()
|| this.<span class="apidocCodeKeywordSpan">tag</span>()
|| this.filter()
|| this.blockCode()
|| this.code()
|| this.id()
|| this.className()
|| this.attrs()
|| this.attributesBlock()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.text" id="apidoc.element.jade.Lexer.prototype.text">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>text
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">text = function () {
  return this.scan(/^(?:\| ?| )([^\n]+)/, 'text') ||
    this.scan(/^\|?( )/, 'text') ||
    this.scan(/^(&lt;[^\n]*)/, 'text');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      || this.blockCode()
      || this.code()
      || this.id()
      || this.className()
      || this.attrs()
      || this.attributesBlock()
      || this.indent()
      || this.<span class="apidocCodeKeywordSpan">text</span>()
      || this.comment()
      || this.colon()
      || this.dot()
      || this.textFail()
      || this.fail();
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.textFail" id="apidoc.element.jade.Lexer.prototype.textFail">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>textFail
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">textFail = function () {
  var tok;
  if (tok = this.scan(/^([^\.\n][^\n]+)/, 'text')) {
    console.warn('Warning: missing space before text for line ' + this.lineno +
        ' of jade file "' + this.filename + '"');
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      || this.attrs()
      || this.attributesBlock()
      || this.indent()
      || this.text()
      || this.comment()
      || this.colon()
      || this.dot()
      || this.<span class="apidocCodeKeywordSpan">textFail</span>()
      || this.fail();
  }
};

},{"./utils":25,"character-parser":29}],7:[function(require,module,exports){
'use strict';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.tok" id="apidoc.element.jade.Lexer.prototype.tok">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>tok
        <span class="apidocSignatureSpan">(type, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tok = function (type, val){
  return {
      type: type
    , line: this.lineno
    , val: val
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @api private
 */

scan: function(regexp, type){
  var captures;
  if (captures = regexp.exec(this.input)) {
    this.consume(captures[0].length);
    return this.<span class="apidocCodeKeywordSpan">tok</span>(type, captures[1]);
  }
},

/**
 * Defer the given `tok`.
 *
 * @param {Object} tok
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.when" id="apidoc.element.jade.Lexer.prototype.when">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>when
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">when = function () {
  return this.scan(/^when +([^:\n]+)/, 'when');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.blank()
|| this.eos()
|| this.pipelessText()
|| this.yield()
|| this.doctype()
|| this.interpolation()
|| this["case"]()
|| this.<span class="apidocCodeKeywordSpan">when</span>()
|| this["default"]()
|| this["extends"]()
|| this.append()
|| this.prepend()
|| this.block()
|| this.mixinBlock()
|| this.include()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.while" id="apidoc.element.jade.Lexer.prototype.while">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>while
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">while = function () {
  var captures;
  if (captures = /^while +([^\n]+)/.exec(this.input)) {
    this.consume(captures[0].length);
    assertExpression(captures[1])
    var tok = this.tok('code', 'while (' + captures[1] + ')');
    tok.requiresBlock = true;
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.yield" id="apidoc.element.jade.Lexer.prototype.yield">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>yield
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">yield = function () {
  return this.scan(/^yield */, 'yield');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */

next: function() {
  return this.deferred()
    || this.blank()
    || this.eos()
    || this.pipelessText()
    || this.<span class="apidocCodeKeywordSpan">yield</span>()
    || this.doctype()
    || this.interpolation()
    || this["case"]()
    || this.when()
    || this["default"]()
    || this["extends"]()
    || this.append()
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.Parser" id="apidoc.module.jade.Parser">module jade.Parser</a></h1>


    <h2>
        <a href="#apidoc.element.jade.Parser.Parser" id="apidoc.element.jade.Parser.Parser">
        function <span class="apidocSignatureSpan">jade.</span>Parser
        <span class="apidocSignatureSpan">(str, filename, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(str, filename, options){
  //Strip any UTF-8 BOM off of the start of `str`, if it exists.
  this.input = str.replace(/^\uFEFF/, '');
  this.lexer = new Lexer(this.input, filename);
  this.filename = filename;
  this.blocks = {};
  this.mixins = {};
  this.options = options;
  this.contexts = [this];
  this.inMixin = 0;
  this.dependencies = [];
  this.inBlock = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.Parser.prototype" id="apidoc.module.jade.Parser.prototype">module jade.Parser.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.accept" id="apidoc.element.jade.Parser.prototype.accept">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>accept
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">accept = function (type){
  if (this.peek().type === type) {
    return this.advance();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
   * filter attrs? text-block
   */

  parseFilter: function(){
var tok = this.expect('filter');
var attrs = this.<span class="apidocCodeKeywordSpan">accept</span>('attrs');
var block;

block = this.parseTextBlock() || new nodes.Block();

var options = {};
if (attrs) {
  attrs.attrs.forEach(function (attribute) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.advance" id="apidoc.element.jade.Parser.prototype.advance">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>advance
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">advance = function (){
  return this.lexer.advance();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Return the next token object.
 *
 * @return {Object}
 * @api private
 */

advance: function(){
  return this.lexer.<span class="apidocCodeKeywordSpan">advance</span>();
},

/**
 * Single token lookahead.
 *
 * @return {Object}
 * @api private
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.block" id="apidoc.element.jade.Parser.prototype.block">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>block
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block = function (){
  var block = new nodes.Block;
  block.line = this.line();
  block.filename = this.filename;
  this.expect('indent');
  while ('outdent' != this.peek().type) {
    if ('newline' == this.peek().type) {
      this.advance();
    } else {
      var expr = this.parseExpr();
      expr.filename = this.filename;
      block.push(expr);
    }
  }
  this.expect('outdent');
  return block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.interpolation()
|| this["case"]()
|| this.when()
|| this["default"]()
|| this["extends"]()
|| this.append()
|| this.prepend()
|| this.<span class="apidocCodeKeywordSpan">block</span>()
|| this.mixinBlock()
|| this.include()
|| this.includeFiltered()
|| this.mixin()
|| this.call()
|| this.conditional()
|| this.each()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.constructor" id="apidoc.element.jade.Parser.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>constructor
        <span class="apidocSignatureSpan">(str, filename, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(str, filename, options){
  //Strip any UTF-8 BOM off of the start of `str`, if it exists.
  this.input = str.replace(/^\uFEFF/, '');
  this.lexer = new Lexer(this.input, filename);
  this.filename = filename;
  this.blocks = {};
  this.mixins = {};
  this.options = options;
  this.contexts = [this];
  this.inMixin = 0;
  this.dependencies = [];
  this.inBlock = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require('fs');

var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');
if ('.jade' != path.substr(-5)) path += '.jade';

this.dependencies.push(path);
var str = fs.readFileSync(path, 'utf8');
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.context" id="apidoc.element.jade.Parser.prototype.context">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>context
        <span class="apidocSignatureSpan">(parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">context = function (parser){
  if (parser) {
    this.contexts.push(parser);
  } else {
    return this.contexts.pop();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Parse
var parser = new (options.parser || Parser)(str, options.filename, options);
var tokens;
try {
  // Parse
  tokens = parser.parse();
} catch (err) {
  parser = parser.<span class="apidocCodeKeywordSpan">context</span>();
  runtime.rethrow(err, parser.filename, parser.lexer.lineno, parser.input);
}

// Compile
var compiler = new (options.compiler || Compiler)(tokens, options);
var js;
try {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.expect" id="apidoc.element.jade.Parser.prototype.expect">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>expect
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expect = function (type){
  if (this.peek().type === type) {
    return this.advance();
  } else {
    throw new Error('expected "' + type + '", but got "' + this.peek().type + '"');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

/**
 * Text
 */

parseText: function(){
  var tok = this.<span class="apidocCodeKeywordSpan">expect</span>('text');
  var tokens = this.parseInlineTagsInText(tok.val);
  if (tokens.length === 1) return tokens[0];
  var node = new nodes.Block;
  for (var i = 0; i &lt; tokens.length; i++) {
    node.push(tokens[i]);
  };
  return node;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.line" id="apidoc.element.jade.Parser.prototype.line">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>line
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">line = function () {
  return this.lexer.lineno;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
   * case
   */

  parseCase: function(){
var val = this.expect('case').val;
var node = new nodes.Case(val);
node.line = this.<span class="apidocCodeKeywordSpan">line</span>();

var block = new nodes.Block;
block.line = this.line();
block.filename = this.filename;
this.expect('indent');
while ('outdent' != this.peek().type) {
  switch (this.peek().type) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.lookahead" id="apidoc.element.jade.Parser.prototype.lookahead">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>lookahead
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookahead = function (n){
  return this.lexer.lookahead(n);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Single token lookahead.
 *
 * @return {Object}
 * @api private
 */

peek: function() {
  return this.<span class="apidocCodeKeywordSpan">lookahead</span>(1);
},

/**
 * Return lexer lineno.
 *
 * @return {Number}
 * @api private
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parse" id="apidoc.element.jade.Parser.prototype.parse">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (){
  var block = new nodes.Block, parser;
  block.line = 0;
  block.filename = this.filename;

  while ('eos' != this.peek().type) {
    if ('newline' == this.peek().type) {
      this.advance();
    } else {
      var next = this.peek();
      var expr = this.parseExpr();
      expr.filename = expr.filename || this.filename;
      expr.line = next.line;
      block.push(expr);
    }
  }

  if (parser = this.extending) {
    this.context(parser);
    var ast = parser.parse();
    this.context();

    // hoist mixins
    for (var name in this.mixins)
      ast.unshift(this.mixins[name]);
    return ast;
  }

  if (!this.extending &amp;&amp; !this.included &amp;&amp; Object.keys(this.blocks).length){
    var blocks = [];
    utils.walkAST(block, function (node) {
      if (node.type === 'Block' &amp;&amp; node.name) {
        blocks.push(node.name);
      }
    });
    Object.keys(this.blocks).forEach(function (name) {
      if (blocks.indexOf(name) === -1 &amp;&amp; !this.blocks[name].isSubBlock) {
        console.warn('Warning: Unexpected block "'
                     + name
                     + '" '
                     + ' on line '
                     + this.blocks[name].line
                     + ' of '
                     + (this.blocks[name].filename)
                     + '. This block is never used. This warning will be an error in v2.0.0');
      }
    }.bind(this));
  }

  return block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// Parse
var parser = new (options.parser || Parser)(str, options.filename, options);
var tokens;
try {
  // Parse
  tokens = parser.<span class="apidocCodeKeywordSpan">parse</span>();
} catch (err) {
  parser = parser.context();
  runtime.rethrow(err, parser.filename, parser.lexer.lineno, parser.input);
}

// Compile
var compiler = new (options.compiler || Compiler)(tokens, options);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseBlock" id="apidoc.element.jade.Parser.prototype.parseBlock">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseBlock = function (){
  var block = this.expect('block');
  var mode = block.mode;
  var name = block.val.trim();

  var line = block.line;

  this.inBlock++;
  block = 'indent' == this.peek().type
    ? this.block()
    : new nodes.Block(new nodes.Literal(''));
  this.inBlock--;
  block.name = name;
  block.line = line;

  var prev = this.blocks[name] || {prepended: [], appended: []}
  if (prev.mode === 'replace') return this.blocks[name] = prev;

  var allNodes = prev.prepended.concat(block.nodes).concat(prev.appended);

  switch (mode) {
    case 'append':
      prev.appended = prev.parser === this ?
                      prev.appended.concat(block.nodes) :
                      block.nodes.concat(prev.appended);
      break;
    case 'prepend':
      prev.prepended = prev.parser === this ?
                       block.nodes.concat(prev.prepended) :
                       prev.prepended.concat(block.nodes);
      break;
  }
  block.nodes = allNodes;
  block.appended = prev.appended;
  block.prepended = prev.prepended;
  block.mode = mode;
  block.parser = this;

  block.isSubBlock = this.inBlock &gt; 0;

  return this.blocks[name] = block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  parseExpr: function(){
switch (this.peek().type) {
  case 'tag':
    return this.parseTag();
  case 'mixin':
    return this.parseMixin();
  case 'block':
    return this.<span class="apidocCodeKeywordSpan">parseBlock</span>();
  case 'mixin-block':
    return this.parseMixinBlock();
  case 'case':
    return this.parseCase();
  case 'extends':
    return this.parseExtends();
  case 'include':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseBlockCode" id="apidoc.element.jade.Parser.prototype.parseBlockCode">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseBlockCode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseBlockCode = function (){
  var tok = this.expect('blockCode');
  var node;
  var body = this.peek();
  var text;
  if (body.type === 'pipeless-text') {
    this.advance();
    text = body.val.join('\n');
  } else {
    text = '';
  }
    node = new nodes.Code(text, false, false);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 'text':
  return this.parseText();
case 'each':
  return this.parseEach();
case 'code':
  return this.parseCode();
case 'blockCode':
  return this.<span class="apidocCodeKeywordSpan">parseBlockCode</span>();
case 'call':
  return this.parseCall();
case 'interpolation':
  return this.parseInterpolation();
case 'yield':
  this.advance();
  var block = new nodes.Block;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseBlockExpansion" id="apidoc.element.jade.Parser.prototype.parseBlockExpansion">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseBlockExpansion
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseBlockExpansion = function (){
  if (':' == this.peek().type) {
    this.advance();
    return new nodes.Block(this.parseExpr());
  } else {
    return this.block();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * when
 */

parseWhen: function(){
  var val = this.expect('when').val;
  if (this.peek().type !== 'newline')
    return new nodes.Case.When(val, this.<span class="apidocCodeKeywordSpan">parseBlockExpansion</span>());
  else
    return new nodes.Case.When(val);
},

/**
 * default
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseCall" id="apidoc.element.jade.Parser.prototype.parseCall">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseCall
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseCall = function (){
  var tok = this.expect('call');
  var name = tok.val;
  var args = tok.args;
  var mixin = new nodes.Mixin(name, args, new nodes.Block, true);

  this.tag(mixin);
  if (mixin.code) {
    mixin.block.push(mixin.code);
    mixin.code = null;
  }
  if (mixin.block.isEmpty()) mixin.block = null;
  return mixin;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 'each':
  return this.parseEach();
case 'code':
  return this.parseCode();
case 'blockCode':
  return this.parseBlockCode();
case 'call':
  return this.<span class="apidocCodeKeywordSpan">parseCall</span>();
case 'interpolation':
  return this.parseInterpolation();
case 'yield':
  this.advance();
  var block = new nodes.Block;
  block.yield = true;
  return block;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseCase" id="apidoc.element.jade.Parser.prototype.parseCase">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseCase
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseCase = function (){
  var val = this.expect('case').val;
  var node = new nodes.Case(val);
  node.line = this.line();

  var block = new nodes.Block;
  block.line = this.line();
  block.filename = this.filename;
  this.expect('indent');
  while ('outdent' != this.peek().type) {
    switch (this.peek().type) {
      case 'comment':
      case 'newline':
        this.advance();
        break;
      case 'when':
        block.push(this.parseWhen());
        break;
      case 'default':
        block.push(this.parseDefault());
        break;
      default:
        throw new Error('Unexpected token "' + this.peek().type
                        + '", expected "when", "default" or "newline"');
    }
  }
  this.expect('outdent');

  node.block = block;

  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 'mixin':
  return this.parseMixin();
case 'block':
  return this.parseBlock();
case 'mixin-block':
  return this.parseMixinBlock();
case 'case':
  return this.<span class="apidocCodeKeywordSpan">parseCase</span>();
case 'extends':
  return this.parseExtends();
case 'include':
  return this.parseInclude();
case 'doctype':
  return this.parseDoctype();
case 'filter':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseCode" id="apidoc.element.jade.Parser.prototype.parseCode">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseCode
        <span class="apidocSignatureSpan">(afterIf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseCode = function (afterIf){
  var tok = this.expect('code');
  var node = new nodes.Code(tok.val, tok.buffer, tok.escape);
  var block;
  node.line = this.line();

  // throw an error if an else does not have an if
  if (tok.isElse &amp;&amp; !tok.hasIf) {
    throw new Error('Unexpected else without if');
  }

  // handle block
  block = 'indent' == this.peek().type;
  if (block) {
    node.block = this.block();
  }

  // handle missing block
  if (tok.requiresBlock &amp;&amp; !block) {
    node.block = new nodes.Block();
  }

  // mark presense of if for future elses
  if (tok.isIf &amp;&amp; this.peek().isElse) {
    this.peek().hasIf = true;
  } else if (tok.isIf &amp;&amp; this.peek().type === 'newline' &amp;&amp; this.lookahead(2).isElse) {
    this.lookahead(2).hasIf = true;
  }

  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 'comment':
  return this.parseComment();
case 'text':
  return this.parseText();
case 'each':
  return this.parseEach();
case 'code':
  return this.<span class="apidocCodeKeywordSpan">parseCode</span>();
case 'blockCode':
  return this.parseBlockCode();
case 'call':
  return this.parseCall();
case 'interpolation':
  return this.parseInterpolation();
case 'yield':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseComment" id="apidoc.element.jade.Parser.prototype.parseComment">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseComment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseComment = function (){
  var tok = this.expect('comment');
  var node;

  var block;
  if (block = this.parseTextBlock()) {
    node = new nodes.BlockComment(tok.val, block, tok.buffer);
  } else {
    node = new nodes.Comment(tok.val, tok.buffer);
  }

  node.line = this.line();
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 'include':
  return this.parseInclude();
case 'doctype':
  return this.parseDoctype();
case 'filter':
  return this.parseFilter();
case 'comment':
  return this.<span class="apidocCodeKeywordSpan">parseComment</span>();
case 'text':
  return this.parseText();
case 'each':
  return this.parseEach();
case 'code':
  return this.parseCode();
case 'blockCode':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseDefault" id="apidoc.element.jade.Parser.prototype.parseDefault">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseDefault
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseDefault = function (){
  this.expect('default');
  return new nodes.Case.When('default', this.parseBlockExpansion());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    case 'newline':
      this.advance();
      break;
    case 'when':
      block.push(this.parseWhen());
      break;
    case 'default':
      block.push(this.<span class="apidocCodeKeywordSpan">parseDefault</span>());
      break;
    default:
      throw new Error('Unexpected token "' + this.peek().type
                      + '", expected "when", "default" or "newline"');
  }
}
this.expect('outdent');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseDoctype" id="apidoc.element.jade.Parser.prototype.parseDoctype">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseDoctype
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseDoctype = function (){
  var tok = this.expect('doctype');
  var node = new nodes.Doctype(tok.val);
  node.line = this.line();
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 'case':
  return this.parseCase();
case 'extends':
  return this.parseExtends();
case 'include':
  return this.parseInclude();
case 'doctype':
  return this.<span class="apidocCodeKeywordSpan">parseDoctype</span>();
case 'filter':
  return this.parseFilter();
case 'comment':
  return this.parseComment();
case 'text':
  return this.parseText();
case 'each':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseEach" id="apidoc.element.jade.Parser.prototype.parseEach">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseEach
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseEach = function (){
  var tok = this.expect('each');
  var node = new nodes.Each(tok.code, tok.val, tok.key);
  node.line = this.line();
  node.block = this.block();
  if (this.peek().type == 'code' &amp;&amp; this.peek().val == 'else') {
    this.advance();
    node.alternative = this.block();
  }
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 'filter':
  return this.parseFilter();
case 'comment':
  return this.parseComment();
case 'text':
  return this.parseText();
case 'each':
  return this.<span class="apidocCodeKeywordSpan">parseEach</span>();
case 'code':
  return this.parseCode();
case 'blockCode':
  return this.parseBlockCode();
case 'call':
  return this.parseCall();
case 'interpolation':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseExpr" id="apidoc.element.jade.Parser.prototype.parseExpr">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseExpr
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseExpr = function (){
  switch (this.peek().type) {
    case 'tag':
      return this.parseTag();
    case 'mixin':
      return this.parseMixin();
    case 'block':
      return this.parseBlock();
    case 'mixin-block':
      return this.parseMixinBlock();
    case 'case':
      return this.parseCase();
    case 'extends':
      return this.parseExtends();
    case 'include':
      return this.parseInclude();
    case 'doctype':
      return this.parseDoctype();
    case 'filter':
      return this.parseFilter();
    case 'comment':
      return this.parseComment();
    case 'text':
      return this.parseText();
    case 'each':
      return this.parseEach();
    case 'code':
      return this.parseCode();
    case 'blockCode':
      return this.parseBlockCode();
    case 'call':
      return this.parseCall();
    case 'interpolation':
      return this.parseInterpolation();
    case 'yield':
      this.advance();
      var block = new nodes.Block;
      block.yield = true;
      return block;
    case 'id':
    case 'class':
      var tok = this.advance();
      this.lexer.defer(this.lexer.tok('tag', 'div'));
      this.lexer.defer(tok);
      return this.parseExpr();
    default:
      throw new Error('unexpected token "' + this.peek().type + '"');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
block.filename = this.filename;

while ('eos' != this.peek().type) {
  if ('newline' == this.peek().type) {
    this.advance();
  } else {
    var next = this.peek();
    var expr = this.<span class="apidocCodeKeywordSpan">parseExpr</span>();
    expr.filename = expr.filename || this.filename;
    expr.line = next.line;
    block.push(expr);
  }
}

if (parser = this.extending) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseExtends" id="apidoc.element.jade.Parser.prototype.parseExtends">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseExtends
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseExtends = function (){
  var fs = require('fs');

  var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');
  if ('.jade' != path.substr(-5)) path += '.jade';

  this.dependencies.push(path);
  var str = fs.readFileSync(path, 'utf8');
  var parser = new this.constructor(str, path, this.options);
  parser.dependencies = this.dependencies;

  parser.blocks = this.blocks;
  parser.included = this.included;
  parser.contexts = this.contexts;
  this.extending = parser;

  // TODO: null node
  return new nodes.Literal('');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 'block':
  return this.parseBlock();
case 'mixin-block':
  return this.parseMixinBlock();
case 'case':
  return this.parseCase();
case 'extends':
  return this.<span class="apidocCodeKeywordSpan">parseExtends</span>();
case 'include':
  return this.parseInclude();
case 'doctype':
  return this.parseDoctype();
case 'filter':
  return this.parseFilter();
case 'comment':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseFilter" id="apidoc.element.jade.Parser.prototype.parseFilter">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseFilter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseFilter = function (){
  var tok = this.expect('filter');
  var attrs = this.accept('attrs');
  var block;

  block = this.parseTextBlock() || new nodes.Block();

  var options = {};
  if (attrs) {
    attrs.attrs.forEach(function (attribute) {
      options[attribute.name] = constantinople.toConstant(attribute.val);
    });
  }

  var node = new nodes.Filter(tok.val, block, options);
  node.line = this.line();
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 'extends':
  return this.parseExtends();
case 'include':
  return this.parseInclude();
case 'doctype':
  return this.parseDoctype();
case 'filter':
  return this.<span class="apidocCodeKeywordSpan">parseFilter</span>();
case 'comment':
  return this.parseComment();
case 'text':
  return this.parseText();
case 'each':
  return this.parseEach();
case 'code':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseInclude" id="apidoc.element.jade.Parser.prototype.parseInclude">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseInclude
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseInclude = function (){
  var fs = require('fs');
  var tok = this.expect('include');

  var path = this.resolvePath(tok.val.trim(), 'include');
  this.dependencies.push(path);
  // has-filter
  if (tok.filter) {
    var str = fs.readFileSync(path, 'utf8').replace(/\r/g, '');
    var options = {filename: path};
    if (tok.attrs) {
      tok.attrs.attrs.forEach(function (attribute) {
        options[attribute.name] = constantinople.toConstant(attribute.val);
      });
    }
    str = filters(tok.filter, str, options);
    return new nodes.Literal(str);
  }

  // non-jade
  if ('.jade' != path.substr(-5)) {
    var str = fs.readFileSync(path, 'utf8').replace(/\r/g, '');
    return new nodes.Literal(str);
  }

  var str = fs.readFileSync(path, 'utf8');
  var parser = new this.constructor(str, path, this.options);
  parser.dependencies = this.dependencies;

  parser.blocks = utils.merge({}, this.blocks);
  parser.included = true;

  parser.mixins = this.mixins;

  this.context(parser);
  var ast = parser.parse();
  this.context();
  ast.filename = path;

  if ('indent' == this.peek().type) {
    ast.includeBlock().push(this.block());
  }

  return ast;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 'mixin-block':
  return this.parseMixinBlock();
case 'case':
  return this.parseCase();
case 'extends':
  return this.parseExtends();
case 'include':
  return this.<span class="apidocCodeKeywordSpan">parseInclude</span>();
case 'doctype':
  return this.parseDoctype();
case 'filter':
  return this.parseFilter();
case 'comment':
  return this.parseComment();
case 'text':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseInlineTagsInText" id="apidoc.element.jade.Parser.prototype.parseInlineTagsInText">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseInlineTagsInText
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseInlineTagsInText = function (str) {
  var line = this.line();

  var match = /(\\)?#\[((?:.|\n)*)$/.exec(str);
  if (match) {
    if (match[1]) { // escape
      var text = new nodes.Text(str.substr(0, match.index) + '#[');
      text.line = line;
      var rest = this.parseInlineTagsInText(match[2]);
      if (rest[0].type === 'Text') {
        text.val += rest[0].val;
        rest.shift();
      }
      return [text].concat(rest);
    } else {
      var text = new nodes.Text(str.substr(0, match.index));
      text.line = line;
      var buffer = [text];
      var rest = match[2];
      var range = parseJSExpression(rest);
      var inner = new Parser(range.src, this.filename, this.options);
      buffer.push(inner.parse());
      return buffer.concat(this.parseInlineTagsInText(rest.substr(range.end + 1)));
    }
  } else {
    var text = new nodes.Text(str);
    text.line = line;
    return [text];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Text
 */

parseText: function(){
  var tok = this.expect('text');
  var tokens = this.<span class="apidocCodeKeywordSpan">parseInlineTagsInText</span>(tok.val);
  if (tokens.length === 1) return tokens[0];
  var node = new nodes.Block;
  for (var i = 0; i &lt; tokens.length; i++) {
    node.push(tokens[i]);
  };
  return node;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseInterpolation" id="apidoc.element.jade.Parser.prototype.parseInterpolation">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseInterpolation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseInterpolation = function (){
  var tok = this.advance();
  var tag = new nodes.Tag(tok.val);
  tag.buffer = true;
  return this.tag(tag);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 'code':
  return this.parseCode();
case 'blockCode':
  return this.parseBlockCode();
case 'call':
  return this.parseCall();
case 'interpolation':
  return this.<span class="apidocCodeKeywordSpan">parseInterpolation</span>();
case 'yield':
  this.advance();
  var block = new nodes.Block;
  block.yield = true;
  return block;
case 'id':
case 'class':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseMixin" id="apidoc.element.jade.Parser.prototype.parseMixin">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseMixin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseMixin = function (){
  var tok = this.expect('mixin');
  var name = tok.val;
  var args = tok.args;
  var mixin;

  // definition
  if ('indent' == this.peek().type) {
    this.inMixin++;
    mixin = new nodes.Mixin(name, args, this.block(), false);
    this.mixins[name] = mixin;
    this.inMixin--;
    return mixin;
  // call
  } else {
    return new nodes.Mixin(name, args, null, true);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */

parseExpr: function(){
  switch (this.peek().type) {
    case 'tag':
      return this.parseTag();
    case 'mixin':
      return this.<span class="apidocCodeKeywordSpan">parseMixin</span>();
    case 'block':
      return this.parseBlock();
    case 'mixin-block':
      return this.parseMixinBlock();
    case 'case':
      return this.parseCase();
    case 'extends':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseMixinBlock" id="apidoc.element.jade.Parser.prototype.parseMixinBlock">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseMixinBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseMixinBlock = function () {
  var block = this.expect('mixin-block');
  if (!this.inMixin) {
    throw new Error('Anonymous blocks are not allowed unless they are part of a mixin.');
  }
  return new nodes.MixinBlock();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 'tag':
  return this.parseTag();
case 'mixin':
  return this.parseMixin();
case 'block':
  return this.parseBlock();
case 'mixin-block':
  return this.<span class="apidocCodeKeywordSpan">parseMixinBlock</span>();
case 'case':
  return this.parseCase();
case 'extends':
  return this.parseExtends();
case 'include':
  return this.parseInclude();
case 'doctype':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseTag" id="apidoc.element.jade.Parser.prototype.parseTag">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseTag
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseTag = function (){
  var tok = this.advance();
  var tag = new nodes.Tag(tok.val);

  tag.selfClosing = tok.selfClosing;

  return this.tag(tag);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * | class
 * | interpolation
 */

parseExpr: function(){
  switch (this.peek().type) {
    case 'tag':
      return this.<span class="apidocCodeKeywordSpan">parseTag</span>();
    case 'mixin':
      return this.parseMixin();
    case 'block':
      return this.parseBlock();
    case 'mixin-block':
      return this.parseMixinBlock();
    case 'case':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseText" id="apidoc.element.jade.Parser.prototype.parseText">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseText
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseText = function (){
  var tok = this.expect('text');
  var tokens = this.parseInlineTagsInText(tok.val);
  if (tokens.length === 1) return tokens[0];
  var node = new nodes.Block;
  for (var i = 0; i &lt; tokens.length; i++) {
    node.push(tokens[i]);
  };
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 'doctype':
  return this.parseDoctype();
case 'filter':
  return this.parseFilter();
case 'comment':
  return this.parseComment();
case 'text':
  return this.<span class="apidocCodeKeywordSpan">parseText</span>();
case 'each':
  return this.parseEach();
case 'code':
  return this.parseCode();
case 'blockCode':
  return this.parseBlockCode();
case 'call':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseTextBlock" id="apidoc.element.jade.Parser.prototype.parseTextBlock">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseTextBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseTextBlock = function (){
  var block = new nodes.Block;
  block.line = this.line();
  var body = this.peek();
  if (body.type !== 'pipeless-text') return;
  this.advance();
  block.nodes = body.val.reduce(function (accumulator, text) {
    return accumulator.concat(this.parseInlineTagsInText(text));
  }.bind(this), []);
  return block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   */

  parseComment: function(){
var tok = this.expect('comment');
var node;

var block;
if (block = this.<span class="apidocCodeKeywordSpan">parseTextBlock</span>()) {
  node = new nodes.BlockComment(tok.val, block, tok.buffer);
} else {
  node = new nodes.Comment(tok.val, tok.buffer);
}

node.line = this.line();
return node;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseWhen" id="apidoc.element.jade.Parser.prototype.parseWhen">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseWhen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseWhen = function (){
  var val = this.expect('when').val;
  if (this.peek().type !== 'newline')
    return new nodes.Case.When(val, this.parseBlockExpansion());
  else
    return new nodes.Case.When(val);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    while ('outdent' != this.peek().type) {
switch (this.peek().type) {
  case 'comment':
  case 'newline':
    this.advance();
    break;
  case 'when':
    block.push(this.<span class="apidocCodeKeywordSpan">parseWhen</span>());
    break;
  case 'default':
    block.push(this.parseDefault());
    break;
  default:
    throw new Error('Unexpected token "' + this.peek().type
                    + '", expected "when", "default" or "newline"');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.peek" id="apidoc.element.jade.Parser.prototype.peek">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>peek
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">peek = function () {
  return this.lookahead(1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   */

  parse: function(){
var block = new nodes.Block, parser;
block.line = 0;
block.filename = this.filename;

while ('eos' != this.<span class="apidocCodeKeywordSpan">peek</span>().type) {
  if ('newline' == this.peek().type) {
    this.advance();
  } else {
    var next = this.peek();
    var expr = this.parseExpr();
    expr.filename = expr.filename || this.filename;
    expr.line = next.line;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.resolvePath" id="apidoc.element.jade.Parser.prototype.resolvePath">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>resolvePath
        <span class="apidocSignatureSpan">(path, purpose)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolvePath = function (path, purpose) {
  var p = require('path');
  var dirname = p.dirname;
  var basename = p.basename;
  var join = p.join;

  if (path[0] !== '/' &amp;&amp; !this.filename)
    throw new Error('the "filename" option is required to use "' + purpose + '" with "relative" paths');

  if (path[0] === '/' &amp;&amp; !this.options.basedir)
    throw new Error('the "basedir" option is required to use "' + purpose + '" with "absolute" paths');

  path = join(path[0] === '/' ? this.options.basedir : dirname(this.filename), path);

  if (basename(path).indexOf('.') === -1) path += '.jade';

  return path;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
   * 'extends' name
   */

  parseExtends: function(){
var fs = require('fs');

var path = this.<span class="apidocCodeKeywordSpan">resolvePath</span>(this.expect('extends').val.trim(), 'extends
');
if ('.jade' != path.substr(-5)) path += '.jade';

this.dependencies.push(path);
var str = fs.readFileSync(path, 'utf8');
var parser = new this.constructor(str, path, this.options);
parser.dependencies = this.dependencies;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.tag" id="apidoc.element.jade.Parser.prototype.tag">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>tag
        <span class="apidocSignatureSpan">(tag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tag = function (tag){
  tag.line = this.line();

  var seenAttrs = false;
  // (attrs | class | id)*
  out:
    while (true) {
      switch (this.peek().type) {
        case 'id':
        case 'class':
          var tok = this.advance();
          tag.setAttribute(tok.type, "'" + tok.val + "'");
          continue;
        case 'attrs':
          if (seenAttrs) {
            console.warn(this.filename + ', line ' + this.peek().line + ':\nYou should not have jade tags with multiple attributes
.');
          }
          seenAttrs = true;
          var tok = this.advance();
          var attrs = tok.attrs;

          if (tok.selfClosing) tag.selfClosing = true;

          for (var i = 0; i &lt; attrs.length; i++) {
            tag.setAttribute(attrs[i].name, attrs[i].val, attrs[i].escaped);
          }
          continue;
        case '&amp;attributes':
          var tok = this.advance();
          tag.addAttributes(tok.val);
          break;
        default:
          break out;
      }
    }

  // check immediate '.'
  if ('dot' == this.peek().type) {
    tag.textOnly = true;
    this.advance();
  }

  // (text | code | ':')?
  switch (this.peek().type) {
    case 'text':
      tag.block.push(this.parseText());
      break;
    case 'code':
      tag.code = this.parseCode();
      break;
    case ':':
      this.advance();
      tag.block = new nodes.Block;
      tag.block.push(this.parseExpr());
      break;
    case 'newline':
    case 'indent':
    case 'outdent':
    case 'eos':
    case 'pipeless-text':
      break;
    default:
      throw new Error('Unexpected token `' + this.peek().type + '` expected `text`, `code`, `:`, `newline` or `eos`')
  }

  // newline*
  while ('newline' == this.peek().type) this.advance();

  // block?
  if (tag.textOnly) {
    tag.block = this.parseTextBlock() || new nodes.Block();
  } else if ('indent' == this.peek().type) {
    var block = this.block();
    for (var i = 0, len = block.nodes.length; i &lt; len; ++i) {
      tag.block.push(block.nodes[i]);
    }
  }

  return tag;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.include()
|| this.includeFiltered()
|| this.mixin()
|| this.call()
|| this.conditional()
|| this.each()
|| this["while"]()
|| this.<span class="apidocCodeKeywordSpan">tag</span>()
|| this.filter()
|| this.blockCode()
|| this.code()
|| this.id()
|| this.className()
|| this.attrs()
|| this.attributesBlock()
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.jade" id="apidoc.module.jade.jade">module jade.jade</a></h1>


    <h2>
        <a href="#apidoc.element.jade.jade.Compiler" id="apidoc.element.jade.jade.Compiler">
        function <span class="apidocSignatureSpan">jade.jade.</span>Compiler
        <span class="apidocSignatureSpan">(node, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Compiler(node, options) {
  this.options = options = options || {};
  this.node = node;
  this.hasCompiledDoctype = false;
  this.hasCompiledTag = false;
  this.pp = options.pretty || false;
  if (this.pp &amp;&amp; typeof this.pp !== 'string') {
    this.pp = '  ';
  }
  this.debug = false !== options.compileDebug;
  this.indents = 0;
  this.parentIndents = 0;
  this.terse = false;
  this.mixins = {};
  this.dynamicMixins = false;
  if (options.doctype) this.setDoctype(options.doctype);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.jade.Lexer" id="apidoc.element.jade.jade.Lexer">
        function <span class="apidocSignatureSpan">jade.jade.</span>Lexer
        <span class="apidocSignatureSpan">(str, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Lexer(str, filename) {
  this.input = str.replace(/\r\n|\r/g, '\n');
  this.filename = filename;
  this.deferredTokens = [];
  this.lastIndents = 0;
  this.lineno = 1;
  this.stash = [];
  this.indentStack = [];
  this.indentRe = null;
  this.pipeless = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.jade.Parser" id="apidoc.element.jade.jade.Parser">
        function <span class="apidocSignatureSpan">jade.jade.</span>Parser
        <span class="apidocSignatureSpan">(str, filename, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(str, filename, options){
  //Strip any UTF-8 BOM off of the start of `str`, if it exists.
  this.input = str.replace(/^\uFEFF/, '');
  this.lexer = new Lexer(this.input, filename);
  this.filename = filename;
  this.blocks = {};
  this.mixins = {};
  this.options = options;
  this.contexts = [this];
  this.inMixin = 0;
  this.dependencies = [];
  this.inBlock = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.jade.__express" id="apidoc.element.jade.jade.__express">
        function <span class="apidocSignatureSpan">jade.jade.</span>__express
        <span class="apidocSignatureSpan">(path, options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__express = function (path, options, fn) {
  if(options.compileDebug == undefined &amp;&amp; process.env.NODE_ENV === 'production') {
    options.compileDebug = false;
  }
  exports.renderFile(path, options, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.jade.compile" id="apidoc.element.jade.jade.compile">
        function <span class="apidocSignatureSpan">jade.jade.</span>compile
        <span class="apidocSignatureSpan">(str, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (str, options){
  var options = options || {}
    , filename = options.filename
      ? utils.stringify(options.filename)
      : 'undefined'
    , fn;

  str = String(str);

  var parsed = parse(str, options);
  if (options.compileDebug !== false) {
    fn = [
        'var jade_debug = [ new jade.DebugItem( 1, ' + filename + ' ) ];'
      , 'try {'
      , parsed.body
      , '} catch (err) {'
      , '  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno' + (options.compileDebug === true ? ',' + utils.stringify
(str) : '') + ');'
      , '}'
    ].join('\n');
  } else {
    fn = parsed.body;
  }
  fn = new Function('locals, jade', fn)
  var res = function(locals){ return fn(locals, Object.create(runtime)) };
  if (options.client) {
    res.toString = function () {
      var err = new Error('The `client` option is deprecated, use the `jade.compileClient` method instead');
      err.name = 'Warning';
      console.error(err.stack || /* istanbul ignore next */ err.message);
      return exports.compileClient(str, options);
    };
  }
  res.dependencies = parsed.dependencies;
  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

For full API, see [jade-lang.com/api](http://jade-lang.com/api/)

```js
var jade = require('jade');

// compile
var fn = jade.<span class="apidocCodeKeywordSpan">compile</span>('string of jade', options);
var html = fn(locals);

// render
var html = jade.render('string of jade', merge(options, locals));

// renderFile
var html = jade.renderFile('filename.jade', merge(options, locals));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.jade.compileClient" id="apidoc.element.jade.jade.compileClient">
        function <span class="apidocSignatureSpan">jade.jade.</span>compileClient
        <span class="apidocSignatureSpan">(str, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileClient = function (str, options) {
  return exports.compileClientWithDependenciesTracked(str, options).body;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  fn = new Function('locals, jade', fn)
  var res = function(locals){ return fn(locals, Object.create(runtime)) };
  if (options.client) {
    res.toString = function () {
      var err = new Error('The `client` option is deprecated, use the `jade.compileClient` method instead');
      err.name = 'Warning';
      console.error(err.stack || /* istanbul ignore next */ err.message);
      return exports.<span class="apidocCodeKeywordSpan">compileClient</span>(str, options);
    };
  }
  res.dependencies = parsed.dependencies;
  return res;
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.jade.compileClientWithDependenciesTracked" id="apidoc.element.jade.jade.compileClientWithDependenciesTracked">
        function <span class="apidocSignatureSpan">jade.jade.</span>compileClientWithDependenciesTracked
        <span class="apidocSignatureSpan">(str, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileClientWithDependenciesTracked = function (str, options){
  var options = options || {};
  var name = options.name || 'template';
  var filename = options.filename ? utils.stringify(options.filename) : 'undefined';
  var fn;

  str = String(str);
  options.compileDebug = options.compileDebug ? true : false;
  var parsed = parse(str, options);
  if (options.compileDebug) {
    fn = [
        'var jade_debug = [ new jade.DebugItem( 1, ' + filename + ' ) ];'
      , 'try {'
      , parsed.body
      , '} catch (err) {'
      , '  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno, ' + utils.stringify(str) + ');'
      , '}'
    ].join('\n');
  } else {
    fn = parsed.body;
  }

  return {body: 'function ' + name + '(locals) {\n' + fn + '\n}', dependencies: parsed.dependencies};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @param {String} str
* @param {Options} options
* @return {String}
* @api public
*/
exports.compileClient = function (str, options) {
 return exports.<span class="apidocCodeKeywordSpan">compileClientWithDependenciesTracked</span>(str, options).body;
};

/**
* Compile a `Function` representation of the given jade file.
*
* Options:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.jade.compileFile" id="apidoc.element.jade.jade.compileFile">
        function <span class="apidocSignatureSpan">jade.jade.</span>compileFile
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileFile = function (path, options) {
  options = options || {};
  options.filename = path;
  return handleTemplateCache(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.jade.compileFileClient" id="apidoc.element.jade.jade.compileFileClient">
        function <span class="apidocSignatureSpan">jade.jade.</span>compileFileClient
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileFileClient = function (path, options){
  var key = path + ':client';
  options = options || {};

  options.filename = path;

  if (options.cache &amp;&amp; exports.cache[key]) {
    return exports.cache[key];
  }

  var str = fs.readFileSync(options.filename, 'utf8');
  var out = exports.compileClient(str, options);
  if (options.cache) exports.cache[key] = out;
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.jade.filters" id="apidoc.element.jade.jade.filters">
        function <span class="apidocSignatureSpan">jade.jade.</span>filters
        <span class="apidocSignatureSpan">(name, str, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filter(name, str, options) {
  if (typeof filter[name] === 'function') {
    return filter[name](str, options);
  } else {
    throw new Error('unknown filter ":' + name + '"');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.jade.render" id="apidoc.element.jade.jade.render">
        function <span class="apidocSignatureSpan">jade.jade.</span>render
        <span class="apidocSignatureSpan">(str, options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">render = function (str, options, fn){
  // support callback API
  if ('function' == typeof options) {
    fn = options, options = undefined;
  }
  if (typeof fn === 'function') {
    var res
    try {
      res = exports.render(str, options);
    } catch (ex) {
      return fn(ex);
    }
    return fn(null, res);
  }

  options = options || {};

  // cache requires .filename
  if (options.cache &amp;&amp; !options.filename) {
    throw new Error('the "filename" option is required for caching');
  }

  return handleTemplateCache(options, str)(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var jade = require('jade');

// compile
var fn = jade.compile('string of jade', options);
var html = fn(locals);

// render
var html = jade.<span class="apidocCodeKeywordSpan">render</span>('string of jade', merge(options, locals));

// renderFile
var html = jade.renderFile('filename.jade', merge(options, locals));
```

### Options
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.jade.renderFile" id="apidoc.element.jade.jade.renderFile">
        function <span class="apidocSignatureSpan">jade.jade.</span>renderFile
        <span class="apidocSignatureSpan">(path, options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renderFile = function (path, options, fn){
  // support callback API
  if ('function' == typeof options) {
    fn = options, options = undefined;
  }
  if (typeof fn === 'function') {
    var res
    try {
      res = exports.renderFile(path, options);
    } catch (ex) {
      return fn(ex);
    }
    return fn(null, res);
  }

  options = options || {};

  options.filename = path;
  return handleTemplateCache(options)(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fn = jade.compile('string of jade', options);
var html = fn(locals);

// render
var html = jade.render('string of jade', merge(options, locals));

// renderFile
var html = jade.<span class="apidocCodeKeywordSpan">renderFile</span>('filename.jade', merge(options, locals));
```

### Options

- `filename`  Used in exceptions, and required when using includes
- `compileDebug`  When `false` no debug instrumentation is compiled
- `pretty`    Add pretty-indentation whitespace to output _(false by default)_
...</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes" id="apidoc.module.jade.nodes">module jade.nodes</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Block" id="apidoc.element.jade.nodes.Block">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Block
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Block(node){
  this.nodes = [];
  if (node) this.push(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *   ':' expr
 * | block
 */

parseBlockExpansion: function(){
  if (':' == this.peek().type) {
    this.advance();
    return new nodes.<span class="apidocCodeKeywordSpan">Block</span>(this.parseExpr());
  } else {
    return this.block();
  }
},

/**
 * case
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.BlockComment" id="apidoc.element.jade.nodes.BlockComment">
        function <span class="apidocSignatureSpan">jade.nodes.</span>BlockComment
        <span class="apidocSignatureSpan">(val, block, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BlockComment(val, block, buffer) {
  this.block = block;
  this.val = val;
  this.buffer = buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

parseComment: function(){
  var tok = this.expect('comment');
  var node;

  var block;
  if (block = this.parseTextBlock()) {
    node = new nodes.<span class="apidocCodeKeywordSpan">BlockComment</span>(tok.val, block, tok.buffer);
  } else {
    node = new nodes.Comment(tok.val, tok.buffer);
  }

  node.line = this.line();
  return node;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Case" id="apidoc.element.jade.nodes.Case">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Case
        <span class="apidocSignatureSpan">(expr, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Case(expr, block){
  this.expr = expr;
  this.block = block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
   * case
   */

  parseCase: function(){
var val = this.expect('case').val;
var node = new nodes.<span class="apidocCodeKeywordSpan">Case</span>(val);
node.line = this.line();

var block = new nodes.Block;
block.line = this.line();
block.filename = this.filename;
this.expect('indent');
while ('outdent' != this.peek().type) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Code" id="apidoc.element.jade.nodes.Code">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Code
        <span class="apidocSignatureSpan">(val, buffer, escape)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Code(val, buffer, escape) {
  this.val = val;
  this.buffer = buffer;
  this.escape = escape;
  if (val.match(/^ *else/)) this.debug = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
   * code
   */

  parseCode: function(afterIf){
var tok = this.expect('code');
var node = new nodes.<span class="apidocCodeKeywordSpan">Code</span>(tok.val, tok.buffer, tok.escape);
var block;
node.line = this.line();

// throw an error if an else does not have an if
if (tok.isElse &amp;&amp; !tok.hasIf) {
  throw new Error('Unexpected else without if');
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Comment" id="apidoc.element.jade.nodes.Comment">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Comment
        <span class="apidocSignatureSpan">(val, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Comment(val, buffer) {
  this.val = val;
  this.buffer = buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var tok = this.expect('comment');
  var node;

  var block;
  if (block = this.parseTextBlock()) {
    node = new nodes.BlockComment(tok.val, block, tok.buffer);
  } else {
    node = new nodes.<span class="apidocCodeKeywordSpan">Comment</span>(tok.val, tok.buffer);
  }

  node.line = this.line();
  return node;
},

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Doctype" id="apidoc.element.jade.nodes.Doctype">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Doctype
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Doctype(val) {
  this.val = val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * doctype
 */

parseDoctype: function(){
  var tok = this.expect('doctype');
  var node = new nodes.<span class="apidocCodeKeywordSpan">Doctype</span>(tok.val);
  node.line = this.line();
  return node;
},

/**
 * filter attrs? text-block
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Each" id="apidoc.element.jade.nodes.Each">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Each
        <span class="apidocSignatureSpan">(obj, val, key, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Each(obj, val, key, block) {
  this.obj = obj;
  this.val = val;
  this.key = key;
  this.block = block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * each block
 */

parseEach: function(){
  var tok = this.expect('each');
  var node = new nodes.<span class="apidocCodeKeywordSpan">Each</span>(tok.code, tok.val, tok.key);
  node.line = this.line();
  node.block = this.block();
  if (this.peek().type == 'code' &amp;&amp; this.peek().val == 'else') {
    this.advance();
    node.alternative = this.block();
  }
  return node;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Filter" id="apidoc.element.jade.nodes.Filter">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Filter
        <span class="apidocSignatureSpan">(name, block, attrs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Filter(name, block, attrs) {
  this.name = name;
  this.block = block;
  this.attrs = attrs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var options = {};
  if (attrs) {
    attrs.attrs.forEach(function (attribute) {
      options[attribute.name] = constantinople.toConstant(attribute.val);
    });
  }

  var node = new nodes.<span class="apidocCodeKeywordSpan">Filter</span>(tok.val, block, options);
  node.line = this.line();
  return node;
},

/**
 * each block
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Literal" id="apidoc.element.jade.nodes.Literal">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Literal
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Literal(str) {
  this.str = str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  parser.blocks = this.blocks;
  parser.included = this.included;
  parser.contexts = this.contexts;
  this.extending = parser;

  // TODO: null node
  return new nodes.<span class="apidocCodeKeywordSpan">Literal</span>('');
},

/**
 * 'block' name block
 */

parseBlock: function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Mixin" id="apidoc.element.jade.nodes.Mixin">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Mixin
        <span class="apidocSignatureSpan">(name, args, block, call)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Mixin(name, args, block, call){
  Attrs.call(this);
  this.name = name;
  this.args = args;
  this.block = block;
  this.call = call;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * call ident block
   */

  parseCall: function(){
var tok = this.expect('call');
var name = tok.val;
var args = tok.args;
var mixin = new nodes.<span class="apidocCodeKeywordSpan">Mixin</span>(name, args, new nodes.Block, true);

this.tag(mixin);
if (mixin.code) {
  mixin.block.push(mixin.code);
  mixin.code = null;
}
if (mixin.block.isEmpty()) mixin.block = null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.MixinBlock" id="apidoc.element.jade.nodes.MixinBlock">
        function <span class="apidocSignatureSpan">jade.nodes.</span>MixinBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MixinBlock(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

parseMixinBlock: function () {
  var block = this.expect('mixin-block');
  if (!this.inMixin) {
    throw new Error('Anonymous blocks are not allowed unless they are part of a mixin.');
  }
  return new nodes.<span class="apidocCodeKeywordSpan">MixinBlock</span>();
},

/**
 * include block?
 */

parseInclude: function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Node" id="apidoc.element.jade.nodes.Node">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Node
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Node(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Tag" id="apidoc.element.jade.nodes.Tag">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Tag
        <span class="apidocSignatureSpan">(name, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Tag(name, block) {
  Attrs.call(this);
  this.name = name;
  this.block = block || new Block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * interpolation (attrs | class | id)* (text | code | ':')? newline* block?
 */

parseInterpolation: function(){
  var tok = this.advance();
  var tag = new nodes.<span class="apidocCodeKeywordSpan">Tag</span>(tok.val);
  tag.buffer = true;
  return this.tag(tag);
},

/**
 * tag (attrs | class | id)* (text | code | ':')? newline* block?
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Text" id="apidoc.element.jade.nodes.Text">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Text
        <span class="apidocSignatureSpan">(line)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Text(line) {
  this.val = line;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  parseInlineTagsInText: function (str) {
var line = this.line();

var match = /(\\)?#\[((?:.|\n)*)$/.exec(str);
if (match) {
  if (match[1]) { // escape
    var text = new nodes.<span class="apidocCodeKeywordSpan">Text</span>(str.substr(0, match.index) + '#[');
    text.line = line;
    var rest = this.parseInlineTagsInText(match[2]);
    if (rest[0].type === 'Text') {
      text.val += rest[0].val;
      rest.shift();
    }
    return [text].concat(rest);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Block" id="apidoc.module.jade.nodes.Block">module jade.nodes.Block</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Block.Block" id="apidoc.element.jade.nodes.Block.Block">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Block
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Block(node){
  this.nodes = [];
  if (node) this.push(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *   ':' expr
 * | block
 */

parseBlockExpansion: function(){
  if (':' == this.peek().type) {
    this.advance();
    return new nodes.<span class="apidocCodeKeywordSpan">Block</span>(this.parseExpr());
  } else {
    return this.block();
  }
},

/**
 * case
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Block.prototype" id="apidoc.module.jade.nodes.Block.prototype">module jade.nodes.Block.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.jade.nodes.Block.prototype.clone" id="apidoc.element.jade.nodes.Block.prototype.clone">
        function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function (){
  var err = new Error('block.clone is deprecated and will be removed in v2.0.0');
  console.warn(err.stack);

  var clone = new Block;
  for (var i = 0, len = this.nodes.length; i &lt; len; ++i) {
    clone.push(this.nodes[i].clone());
  }
  return clone;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Block.prototype.clone = function(){
  var err = new Error('block.clone is deprecated and will be removed in v2.0.0');
  console.warn(err.stack);

  var clone = new Block;
  for (var i = 0, len = this.nodes.length; i &lt; len; ++i) {
    clone.push(this.nodes[i].<span class="apidocCodeKeywordSpan">clone</span>());
  }
  return clone;
};

},{"./node":20}],10:[function(require,module,exports){
'use strict';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Block.prototype.constructor" id="apidoc.element.jade.nodes.Block.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>constructor
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Block(node){
  this.nodes = [];
  if (node) this.push(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require('fs');

var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');
if ('.jade' != path.substr(-5)) path += '.jade';

this.dependencies.push(path);
var str = fs.readFileSync(path, 'utf8');
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Block.prototype.includeBlock" id="apidoc.element.jade.nodes.Block.prototype.includeBlock">
        function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>includeBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">includeBlock = function (){
  var ret = this
    , node;

  for (var i = 0, len = this.nodes.length; i &lt; len; ++i) {
    node = this.nodes[i];
    if (node.yield) return node;
    else if (node.textOnly) continue;
    else if (node.includeBlock) ret = node.includeBlock();
    else if (node.block &amp;&amp; !node.block.isEmpty()) ret = node.block.includeBlock();
    if (ret.yield) return ret;
  }

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var ret = this
    , node;

  for (var i = 0, len = this.nodes.length; i &lt; len; ++i) {
    node = this.nodes[i];
    if (node.yield) return node;
    else if (node.textOnly) continue;
    else if (node.includeBlock) ret = node.<span class="apidocCodeKeywordSpan">includeBlock</span>();
    else if (node.block &amp;&amp; !node.block.isEmpty()) ret = node.block.includeBlock();
    if (ret.yield) return ret;
  }

  return ret;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Block.prototype.isEmpty" id="apidoc.element.jade.nodes.Block.prototype.isEmpty">
        function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmpty = function (){
  return 0 == this.nodes.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    , node;

  for (var i = 0, len = this.nodes.length; i &lt; len; ++i) {
    node = this.nodes[i];
    if (node.yield) return node;
    else if (node.textOnly) continue;
    else if (node.includeBlock) ret = node.includeBlock();
    else if (node.block &amp;&amp; !node.block.<span class="apidocCodeKeywordSpan">isEmpty</span>()) ret = node.block.includeBlock
();
    if (ret.yield) return ret;
  }

  return ret;
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Block.prototype.push" id="apidoc.element.jade.nodes.Block.prototype.push">
        function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>push
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (node){
  return this.nodes.push(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var globals = [];

if (options.globals) {
  globals = options.globals.slice();
}

globals.<span class="apidocCodeKeywordSpan">push</span>('jade');
globals.push('jade_mixins');
globals.push('jade_interp');
globals.push('jade_debug');
globals.push('buf');

var body = ''
  + 'var buf = [];\n'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Block.prototype.replace" id="apidoc.element.jade.nodes.Block.prototype.replace">
        function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>replace
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (other){
  var err = new Error('block.replace is deprecated and will be removed in v2.0.0');
  console.warn(err.stack);

  other.nodes = this.nodes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    throw err;
  }
}

// Debug compiler
if (options.debug) {
  console.error('\nCompiled Function:\n\n\u001b[90m%s\u001b[0m', js.<span class="apidocCodeKeywordSpan">replace</span>(/^/
gm, '  '));
}

var globals = [];

if (options.globals) {
  globals = options.globals.slice();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Block.prototype.unshift" id="apidoc.element.jade.nodes.Block.prototype.unshift">
        function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>unshift
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unshift = function (node){
  return this.nodes.unshift(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @api public
   */

  visit: function(node){
var debug = this.debug;

if (debug) {
  this.buf.push('jade_debug.<span class="apidocCodeKeywordSpan">unshift</span>(new jade.DebugItem( ' + node.line
    + ', ' + (node.filename
      ? utils.stringify(node.filename)
      : 'jade_debug[0].filename')
    + ' ));');
}

// Massive hack to fix our context
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.BlockComment" id="apidoc.module.jade.nodes.BlockComment">module jade.nodes.BlockComment</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.BlockComment.BlockComment" id="apidoc.element.jade.nodes.BlockComment.BlockComment">
        function <span class="apidocSignatureSpan">jade.nodes.</span>BlockComment
        <span class="apidocSignatureSpan">(val, block, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BlockComment(val, block, buffer) {
  this.block = block;
  this.val = val;
  this.buffer = buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

parseComment: function(){
  var tok = this.expect('comment');
  var node;

  var block;
  if (block = this.parseTextBlock()) {
    node = new nodes.<span class="apidocCodeKeywordSpan">BlockComment</span>(tok.val, block, tok.buffer);
  } else {
    node = new nodes.Comment(tok.val, tok.buffer);
  }

  node.line = this.line();
  return node;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.BlockComment.prototype" id="apidoc.module.jade.nodes.BlockComment.prototype">module jade.nodes.BlockComment.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.BlockComment.prototype.constructor" id="apidoc.element.jade.nodes.BlockComment.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.BlockComment.prototype.</span>constructor
        <span class="apidocSignatureSpan">(val, block, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BlockComment(val, block, buffer) {
  this.block = block;
  this.val = val;
  this.buffer = buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require('fs');

var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');
if ('.jade' != path.substr(-5)) path += '.jade';

this.dependencies.push(path);
var str = fs.readFileSync(path, 'utf8');
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Case" id="apidoc.module.jade.nodes.Case">module jade.nodes.Case</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Case.Case" id="apidoc.element.jade.nodes.Case.Case">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Case
        <span class="apidocSignatureSpan">(expr, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Case(expr, block){
  this.expr = expr;
  this.block = block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
   * case
   */

  parseCase: function(){
var val = this.expect('case').val;
var node = new nodes.<span class="apidocCodeKeywordSpan">Case</span>(val);
node.line = this.line();

var block = new nodes.Block;
block.line = this.line();
block.filename = this.filename;
this.expect('indent');
while ('outdent' != this.peek().type) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Case.When" id="apidoc.element.jade.nodes.Case.When">
        function <span class="apidocSignatureSpan">jade.nodes.Case.</span>When
        <span class="apidocSignatureSpan">(expr, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function When(expr, block){
  this.expr = expr;
  this.block = block;
  this.debug = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * when
 */

parseWhen: function(){
  var val = this.expect('when').val;
  if (this.peek().type !== 'newline')
    return new nodes.Case.<span class="apidocCodeKeywordSpan">When</span>(val, this.parseBlockExpansion());
  else
    return new nodes.Case.When(val);
},

/**
 * default
 */
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Case.When.prototype" id="apidoc.module.jade.nodes.Case.When.prototype">module jade.nodes.Case.When.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Case.When.prototype.constructor" id="apidoc.element.jade.nodes.Case.When.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.Case.When.prototype.</span>constructor
        <span class="apidocSignatureSpan">(expr, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function When(expr, block){
  this.expr = expr;
  this.block = block;
  this.debug = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require('fs');

var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');
if ('.jade' != path.substr(-5)) path += '.jade';

this.dependencies.push(path);
var str = fs.readFileSync(path, 'utf8');
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Case.prototype" id="apidoc.module.jade.nodes.Case.prototype">module jade.nodes.Case.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Case.prototype.constructor" id="apidoc.element.jade.nodes.Case.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.Case.prototype.</span>constructor
        <span class="apidocSignatureSpan">(expr, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Case(expr, block){
  this.expr = expr;
  this.block = block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require('fs');

var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');
if ('.jade' != path.substr(-5)) path += '.jade';

this.dependencies.push(path);
var str = fs.readFileSync(path, 'utf8');
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Code" id="apidoc.module.jade.nodes.Code">module jade.nodes.Code</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Code.Code" id="apidoc.element.jade.nodes.Code.Code">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Code
        <span class="apidocSignatureSpan">(val, buffer, escape)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Code(val, buffer, escape) {
  this.val = val;
  this.buffer = buffer;
  this.escape = escape;
  if (val.match(/^ *else/)) this.debug = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
   * code
   */

  parseCode: function(afterIf){
var tok = this.expect('code');
var node = new nodes.<span class="apidocCodeKeywordSpan">Code</span>(tok.val, tok.buffer, tok.escape);
var block;
node.line = this.line();

// throw an error if an else does not have an if
if (tok.isElse &amp;&amp; !tok.hasIf) {
  throw new Error('Unexpected else without if');
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Code.prototype" id="apidoc.module.jade.nodes.Code.prototype">module jade.nodes.Code.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Code.prototype.constructor" id="apidoc.element.jade.nodes.Code.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.Code.prototype.</span>constructor
        <span class="apidocSignatureSpan">(val, buffer, escape)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Code(val, buffer, escape) {
  this.val = val;
  this.buffer = buffer;
  this.escape = escape;
  if (val.match(/^ *else/)) this.debug = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require('fs');

var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');
if ('.jade' != path.substr(-5)) path += '.jade';

this.dependencies.push(path);
var str = fs.readFileSync(path, 'utf8');
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Comment" id="apidoc.module.jade.nodes.Comment">module jade.nodes.Comment</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Comment.Comment" id="apidoc.element.jade.nodes.Comment.Comment">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Comment
        <span class="apidocSignatureSpan">(val, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Comment(val, buffer) {
  this.val = val;
  this.buffer = buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var tok = this.expect('comment');
  var node;

  var block;
  if (block = this.parseTextBlock()) {
    node = new nodes.BlockComment(tok.val, block, tok.buffer);
  } else {
    node = new nodes.<span class="apidocCodeKeywordSpan">Comment</span>(tok.val, tok.buffer);
  }

  node.line = this.line();
  return node;
},

/**
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Comment.prototype" id="apidoc.module.jade.nodes.Comment.prototype">module jade.nodes.Comment.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Comment.prototype.constructor" id="apidoc.element.jade.nodes.Comment.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.Comment.prototype.</span>constructor
        <span class="apidocSignatureSpan">(val, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Comment(val, buffer) {
  this.val = val;
  this.buffer = buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require('fs');

var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');
if ('.jade' != path.substr(-5)) path += '.jade';

this.dependencies.push(path);
var str = fs.readFileSync(path, 'utf8');
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Doctype" id="apidoc.module.jade.nodes.Doctype">module jade.nodes.Doctype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Doctype.Doctype" id="apidoc.element.jade.nodes.Doctype.Doctype">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Doctype
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Doctype(val) {
  this.val = val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * doctype
 */

parseDoctype: function(){
  var tok = this.expect('doctype');
  var node = new nodes.<span class="apidocCodeKeywordSpan">Doctype</span>(tok.val);
  node.line = this.line();
  return node;
},

/**
 * filter attrs? text-block
 */
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Doctype.prototype" id="apidoc.module.jade.nodes.Doctype.prototype">module jade.nodes.Doctype.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Doctype.prototype.constructor" id="apidoc.element.jade.nodes.Doctype.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.Doctype.prototype.</span>constructor
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Doctype(val) {
  this.val = val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require('fs');

var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');
if ('.jade' != path.substr(-5)) path += '.jade';

this.dependencies.push(path);
var str = fs.readFileSync(path, 'utf8');
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Each" id="apidoc.module.jade.nodes.Each">module jade.nodes.Each</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Each.Each" id="apidoc.element.jade.nodes.Each.Each">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Each
        <span class="apidocSignatureSpan">(obj, val, key, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Each(obj, val, key, block) {
  this.obj = obj;
  this.val = val;
  this.key = key;
  this.block = block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * each block
 */

parseEach: function(){
  var tok = this.expect('each');
  var node = new nodes.<span class="apidocCodeKeywordSpan">Each</span>(tok.code, tok.val, tok.key);
  node.line = this.line();
  node.block = this.block();
  if (this.peek().type == 'code' &amp;&amp; this.peek().val == 'else') {
    this.advance();
    node.alternative = this.block();
  }
  return node;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Each.prototype" id="apidoc.module.jade.nodes.Each.prototype">module jade.nodes.Each.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Each.prototype.constructor" id="apidoc.element.jade.nodes.Each.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.Each.prototype.</span>constructor
        <span class="apidocSignatureSpan">(obj, val, key, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Each(obj, val, key, block) {
  this.obj = obj;
  this.val = val;
  this.key = key;
  this.block = block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require('fs');

var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');
if ('.jade' != path.substr(-5)) path += '.jade';

this.dependencies.push(path);
var str = fs.readFileSync(path, 'utf8');
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Filter" id="apidoc.module.jade.nodes.Filter">module jade.nodes.Filter</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Filter.Filter" id="apidoc.element.jade.nodes.Filter.Filter">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Filter
        <span class="apidocSignatureSpan">(name, block, attrs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Filter(name, block, attrs) {
  this.name = name;
  this.block = block;
  this.attrs = attrs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var options = {};
  if (attrs) {
    attrs.attrs.forEach(function (attribute) {
      options[attribute.name] = constantinople.toConstant(attribute.val);
    });
  }

  var node = new nodes.<span class="apidocCodeKeywordSpan">Filter</span>(tok.val, block, options);
  node.line = this.line();
  return node;
},

/**
 * each block
 */
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Filter.prototype" id="apidoc.module.jade.nodes.Filter.prototype">module jade.nodes.Filter.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Filter.prototype.constructor" id="apidoc.element.jade.nodes.Filter.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.Filter.prototype.</span>constructor
        <span class="apidocSignatureSpan">(name, block, attrs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Filter(name, block, attrs) {
  this.name = name;
  this.block = block;
  this.attrs = attrs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require('fs');

var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');
if ('.jade' != path.substr(-5)) path += '.jade';

this.dependencies.push(path);
var str = fs.readFileSync(path, 'utf8');
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Literal" id="apidoc.module.jade.nodes.Literal">module jade.nodes.Literal</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Literal.Literal" id="apidoc.element.jade.nodes.Literal.Literal">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Literal
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Literal(str) {
  this.str = str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  parser.blocks = this.blocks;
  parser.included = this.included;
  parser.contexts = this.contexts;
  this.extending = parser;

  // TODO: null node
  return new nodes.<span class="apidocCodeKeywordSpan">Literal</span>('');
},

/**
 * 'block' name block
 */

parseBlock: function(){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Literal.prototype" id="apidoc.module.jade.nodes.Literal.prototype">module jade.nodes.Literal.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Literal.prototype.constructor" id="apidoc.element.jade.nodes.Literal.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.Literal.prototype.</span>constructor
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Literal(str) {
  this.str = str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require('fs');

var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');
if ('.jade' != path.substr(-5)) path += '.jade';

this.dependencies.push(path);
var str = fs.readFileSync(path, 'utf8');
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Mixin" id="apidoc.module.jade.nodes.Mixin">module jade.nodes.Mixin</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Mixin.Mixin" id="apidoc.element.jade.nodes.Mixin.Mixin">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Mixin
        <span class="apidocSignatureSpan">(name, args, block, call)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Mixin(name, args, block, call){
  Attrs.call(this);
  this.name = name;
  this.args = args;
  this.block = block;
  this.call = call;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * call ident block
   */

  parseCall: function(){
var tok = this.expect('call');
var name = tok.val;
var args = tok.args;
var mixin = new nodes.<span class="apidocCodeKeywordSpan">Mixin</span>(name, args, new nodes.Block, true);

this.tag(mixin);
if (mixin.code) {
  mixin.block.push(mixin.code);
  mixin.code = null;
}
if (mixin.block.isEmpty()) mixin.block = null;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Mixin.prototype" id="apidoc.module.jade.nodes.Mixin.prototype">module jade.nodes.Mixin.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Mixin.prototype.constructor" id="apidoc.element.jade.nodes.Mixin.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.Mixin.prototype.</span>constructor
        <span class="apidocSignatureSpan">(name, args, block, call)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Mixin(name, args, block, call){
  Attrs.call(this);
  this.name = name;
  this.args = args;
  this.block = block;
  this.call = call;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require('fs');

var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');
if ('.jade' != path.substr(-5)) path += '.jade';

this.dependencies.push(path);
var str = fs.readFileSync(path, 'utf8');
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.MixinBlock" id="apidoc.module.jade.nodes.MixinBlock">module jade.nodes.MixinBlock</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.MixinBlock.MixinBlock" id="apidoc.element.jade.nodes.MixinBlock.MixinBlock">
        function <span class="apidocSignatureSpan">jade.nodes.</span>MixinBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MixinBlock(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

parseMixinBlock: function () {
  var block = this.expect('mixin-block');
  if (!this.inMixin) {
    throw new Error('Anonymous blocks are not allowed unless they are part of a mixin.');
  }
  return new nodes.<span class="apidocCodeKeywordSpan">MixinBlock</span>();
},

/**
 * include block?
 */

parseInclude: function(){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.MixinBlock.prototype" id="apidoc.module.jade.nodes.MixinBlock.prototype">module jade.nodes.MixinBlock.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.MixinBlock.prototype.constructor" id="apidoc.element.jade.nodes.MixinBlock.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.MixinBlock.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MixinBlock(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require('fs');

var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');
if ('.jade' != path.substr(-5)) path += '.jade';

this.dependencies.push(path);
var str = fs.readFileSync(path, 'utf8');
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Node" id="apidoc.module.jade.nodes.Node">module jade.nodes.Node</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Node.Node" id="apidoc.element.jade.nodes.Node.Node">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Node
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Node(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Node.prototype" id="apidoc.module.jade.nodes.Node.prototype">module jade.nodes.Node.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Node.prototype.clone" id="apidoc.element.jade.nodes.Node.prototype.clone">
        function <span class="apidocSignatureSpan">jade.nodes.Node.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function (){
  var err = new Error('node.clone is deprecated and will be removed in v2.0.0');
  console.warn(err.stack);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Block.prototype.clone = function(){
  var err = new Error('block.clone is deprecated and will be removed in v2.0.0');
  console.warn(err.stack);

  var clone = new Block;
  for (var i = 0, len = this.nodes.length; i &lt; len; ++i) {
    clone.push(this.nodes[i].<span class="apidocCodeKeywordSpan">clone</span>());
  }
  return clone;
};

},{"./node":20}],10:[function(require,module,exports){
'use strict';
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Tag" id="apidoc.module.jade.nodes.Tag">module jade.nodes.Tag</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Tag.Tag" id="apidoc.element.jade.nodes.Tag.Tag">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Tag
        <span class="apidocSignatureSpan">(name, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Tag(name, block) {
  Attrs.call(this);
  this.name = name;
  this.block = block || new Block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * interpolation (attrs | class | id)* (text | code | ':')? newline* block?
 */

parseInterpolation: function(){
  var tok = this.advance();
  var tag = new nodes.<span class="apidocCodeKeywordSpan">Tag</span>(tok.val);
  tag.buffer = true;
  return this.tag(tag);
},

/**
 * tag (attrs | class | id)* (text | code | ':')? newline* block?
 */
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Tag.prototype" id="apidoc.module.jade.nodes.Tag.prototype">module jade.nodes.Tag.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Tag.prototype.canInline" id="apidoc.element.jade.nodes.Tag.prototype.canInline">
        function <span class="apidocSignatureSpan">jade.nodes.Tag.prototype.</span>canInline
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">canInline = function (){
  var nodes = this.block.nodes;

  function isInline(node){
    // Recurse if the node is a block
    if (node.isBlock) return node.nodes.every(isInline);
    return node.isText || (node.isInline &amp;&amp; node.isInline());
  }

  // Empty tag
  if (!nodes.length) return true;

  // Text-only or inline-only tag
  if (1 == nodes.length) return isInline(nodes[0]);

  // Multi-line inline-only tag
  if (this.block.nodes.every(isInline)) {
    for (var i = 1, len = nodes.length; i &lt; len; ++i) {
      if (nodes[i-1].isText &amp;&amp; nodes[i].isText)
        return false;
    }
    return true;
  }

  // Mixed tag
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  bufferName();
  this.visitAttributes(tag.attrs, tag.attributeBlocks.slice());
  this.buffer('&gt;');
  if (tag.code) this.visitCode(tag.code);
  this.visit(tag.block);

  // pretty print
  if (pp &amp;&amp; !tag.isInline() &amp;&amp; 'pre' != tag.name &amp;&amp; !tag.<span class="apidocCodeKeywordSpan
">canInline</span>())
    this.prettyIndent(0, true);

  this.buffer('&lt;/');
  bufferName();
  this.buffer('&gt;');
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Tag.prototype.clone" id="apidoc.element.jade.nodes.Tag.prototype.clone">
        function <span class="apidocSignatureSpan">jade.nodes.Tag.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function (){
  var err = new Error('tag.clone is deprecated and will be removed in v2.0.0');
  console.warn(err.stack);

  var clone = new Tag(this.name, this.block.clone());
  clone.line = this.line;
  clone.attrs = this.attrs;
  clone.textOnly = this.textOnly;
  return clone;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Block.prototype.clone = function(){
  var err = new Error('block.clone is deprecated and will be removed in v2.0.0');
  console.warn(err.stack);

  var clone = new Block;
  for (var i = 0, len = this.nodes.length; i &lt; len; ++i) {
    clone.push(this.nodes[i].<span class="apidocCodeKeywordSpan">clone</span>());
  }
  return clone;
};

},{"./node":20}],10:[function(require,module,exports){
'use strict';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Tag.prototype.constructor" id="apidoc.element.jade.nodes.Tag.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.Tag.prototype.</span>constructor
        <span class="apidocSignatureSpan">(name, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Tag(name, block) {
  Attrs.call(this);
  this.name = name;
  this.block = block || new Block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require('fs');

var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');
if ('.jade' != path.substr(-5)) path += '.jade';

this.dependencies.push(path);
var str = fs.readFileSync(path, 'utf8');
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Tag.prototype.isInline" id="apidoc.element.jade.nodes.Tag.prototype.isInline">
        function <span class="apidocSignatureSpan">jade.nodes.Tag.prototype.</span>isInline
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInline = function (){
  return ~inlineTags.indexOf(this.name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!this.hasCompiledDoctype &amp;&amp; 'html' == name) {
    this.visitDoctype();
  }
  this.hasCompiledTag = true;
}

// pretty print
if (pp &amp;&amp; !tag.<span class="apidocCodeKeywordSpan">isInline</span>())
  this.prettyIndent(0, true);

if (tag.selfClosing || (!this.xml &amp;&amp; selfClosing[tag.name])) {
  this.buffer('&lt;');
  bufferName();
  this.visitAttributes(tag.attrs, tag.attributeBlocks.slice());
  this.terse
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Text" id="apidoc.module.jade.nodes.Text">module jade.nodes.Text</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Text.Text" id="apidoc.element.jade.nodes.Text.Text">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Text
        <span class="apidocSignatureSpan">(line)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Text(line) {
  this.val = line;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  parseInlineTagsInText: function (str) {
var line = this.line();

var match = /(\\)?#\[((?:.|\n)*)$/.exec(str);
if (match) {
  if (match[1]) { // escape
    var text = new nodes.<span class="apidocCodeKeywordSpan">Text</span>(str.substr(0, match.index) + '#[');
    text.line = line;
    var rest = this.parseInlineTagsInText(match[2]);
    if (rest[0].type === 'Text') {
      text.val += rest[0].val;
      rest.shift();
    }
    return [text].concat(rest);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Text.prototype" id="apidoc.module.jade.nodes.Text.prototype">module jade.nodes.Text.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.jade.nodes.Text.prototype.constructor" id="apidoc.element.jade.nodes.Text.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.Text.prototype.</span>constructor
        <span class="apidocSignatureSpan">(line)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Text(line) {
  this.val = line;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require('fs');

var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');
if ('.jade' != path.substr(-5)) path += '.jade';

this.dependencies.push(path);
var str = fs.readFileSync(path, 'utf8');
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.runtime" id="apidoc.module.jade.runtime">module jade.runtime</a></h1>


    <h2>
        <a href="#apidoc.element.jade.runtime.DebugItem" id="apidoc.element.jade.runtime.DebugItem">
        function <span class="apidocSignatureSpan">jade.runtime.</span>DebugItem
        <span class="apidocSignatureSpan">(lineno, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DebugItem(lineno, filename) {
  this.lineno = lineno;
  this.filename = filename;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  , fn;

str = String(str);

var parsed = parse(str, options);
if (options.compileDebug !== false) {
  fn = [
      'var jade_debug = [ new jade.<span class="apidocCodeKeywordSpan">DebugItem</span>( 1, ' + filename + ' ) ];&amp;#
x27;
    , 'try {'
    , parsed.body
    , '} catch (err) {'
    , '  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno' + (options.compileDebug === true ? ','
; + utils.stringify(str) : '') + ');'
    , '}'
  ].join('\n');
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.runtime.attr" id="apidoc.element.jade.runtime.attr">
        function <span class="apidocSignatureSpan">jade.runtime.</span>attr
        <span class="apidocSignatureSpan">(key, val, escaped, terse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function attr(key, val, escaped, terse) {
  if (key === 'style') {
    val = exports.style(val);
  }
  if ('boolean' == typeof val || null == val) {
    if (val) {
      return ' ' + (terse ? key : key + '="' + key + '"');
    } else {
      return '';
    }
  } else if (0 == key.indexOf('data') &amp;&amp; 'string' != typeof val) {
    if (JSON.stringify(val).indexOf('&amp;') !== -1) {
      console.warn('Since Jade 2.0.0, ampersands (`&amp;`) in data attributes ' +
                   'will be escaped to `&amp;amp;`');
    };
    if (val &amp;&amp; typeof val.toISOString === 'function') {
      console.warn('Jade will eliminate the double quotes around dates in ' +
                   'ISO form after 2.0.0');
    }
    return ' ' + key + "='" + JSON.stringify(val).replace(/'/g, '&amp;apos;') + "'";
  } else if (escaped) {
    if (val &amp;&amp; typeof val.toISOString === 'function') {
      console.warn('Jade will stringify dates in ISO form after 2.0.0');
    }
    return ' ' + key + '="' + exports.escape(val) + '"';
  } else {
    if (val &amp;&amp; typeof val.toISOString === 'function') {
      console.warn('Jade will stringify dates in ISO form after 2.0.0');
    }
    return ' ' + key + '="' + val + '"';
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var escaped = attr.escaped;

if (key === 'class') {
  classes.push(attr.val);
  classEscaping.push(attr.escaped);
} else if (isConstant(attr.val)) {
  if (buffer) {
    this.buffer(runtime.<span class="apidocCodeKeywordSpan">attr</span>(key, toConstant(attr.val), escaped, this.terse));
  } else {
    var val = toConstant(attr.val);
    if (key === 'style') val = runtime.style(val);
    if (escaped &amp;&amp; !(key.indexOf('data') === 0 &amp;&amp; typeof val !== 'string')) {
      val = runtime.escape(val);
    }
    buf.push(utils.stringify(key) + ': ' + utils.stringify(val));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.runtime.attrs" id="apidoc.element.jade.runtime.attrs">
        function <span class="apidocSignatureSpan">jade.runtime.</span>attrs
        <span class="apidocSignatureSpan">(obj, terse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function attrs(obj, terse){
  var buf = [];

  var keys = Object.keys(obj);

  if (keys.length) {
    for (var i = 0; i &lt; keys.length; ++i) {
      var key = keys[i]
        , val = obj[key];

      if ('class' == key) {
        if (val = joinClasses(val)) {
          buf.push(' ' + key + '="' + val + '"');
        }
      } else {
        buf.push(exports.attr(key, val, false, terse));
      }
    }
  }

  return buf.join('');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    this.buf.push('}');
  }
}

if (attrsBlocks.length) {
  if (attrs.length) {
    var val = this.<span class="apidocCodeKeywordSpan">attrs</span>(attrs);
    attrsBlocks.unshift(val);
  }
  this.buf.push('attributes: jade.merge([' + attrsBlocks.join(',') + '])');
} else if (attrs.length) {
  var val = this.attrs(attrs);
  this.buf.push('attributes: ' + val);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.runtime.cls" id="apidoc.element.jade.runtime.cls">
        function <span class="apidocSignatureSpan">jade.runtime.</span>cls
        <span class="apidocSignatureSpan">(classes, escaped)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cls(classes, escaped) {
  var buf = [];
  for (var i = 0; i &lt; classes.length; i++) {
    if (escaped &amp;&amp; escaped[i]) {
      buf.push(exports.escape(joinClasses([classes[i]])));
    } else {
      buf.push(joinClasses(classes[i]));
    }
  }
  var text = joinClasses(buf);
  if (text.length) {
    return ' class="' + text + '"';
  } else {
    return '';
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      buf.push(utils.stringify(key) + ': ' + val);
    }
  }
}.bind(this));
if (buffer) {
  if (classes.every(isConstant)) {
    this.buffer(runtime.<span class="apidocCodeKeywordSpan">cls</span>(classes.map(toConstant), classEscaping));
  } else {
    this.bufferExpression('jade.cls([' + classes.join(',') + '], ' + utils.stringify(classEscaping
) + ')');
  }
} else if (classes.length) {
  if (classes.every(isConstant)) {
    classes = utils.stringify(runtime.joinClasses(classes.map(toConstant).map(runtime.joinClasses).map(function (cls, i) {
      return classEscaping[i] ? runtime.escape(cls) : cls;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.runtime.escape" id="apidoc.element.jade.runtime.escape">
        function <span class="apidocSignatureSpan">jade.runtime.</span>escape
        <span class="apidocSignatureSpan">(html)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function jade_escape(html){
  var result = String(html).replace(jade_match_html, jade_encode_char);
  if (result === '' + html) return html;
  else return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// we only wrap unbuffered code blocks ATM
// since they are usually flow control

// Buffer code
if (code.buffer) {
  var val = code.val.trim();
  val = 'null == (jade_interp = '+val+') ? "" : jade_interp';
  if (code.escape) val = 'jade.<span class="apidocCodeKeywordSpan">escape</span>(' + val + ')';
  this.bufferExpression(val);
} else {
  this.buf.push(code.val);
}

// Block support
if (code.block) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.runtime.joinClasses" id="apidoc.element.jade.runtime.joinClasses">
        function <span class="apidocSignatureSpan">jade.runtime.</span>joinClasses
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function joinClasses(val) {
  return (Array.isArray(val) ? val.map(joinClasses) :
    (val &amp;&amp; typeof val === 'object') ? Object.keys(val).filter(function (key) { return val[key]; }) :
    [val]).filter(nulls).join(' ');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (classes.every(isConstant)) {
    this.buffer(runtime.cls(classes.map(toConstant), classEscaping));
  } else {
    this.bufferExpression('jade.cls([' + classes.join(',') + '], ' + utils.stringify(classEscaping
) + ')');
  }
} else if (classes.length) {
  if (classes.every(isConstant)) {
    classes = utils.stringify(runtime.<span class="apidocCodeKeywordSpan">joinClasses</span>(classes.map(toConstant).map(runtime
.joinClasses).map(function (cls, i) {
      return classEscaping[i] ? runtime.escape(cls) : cls;
    })));
  } else {
    classes = '(jade_interp = ' + utils.stringify(classEscaping) + ',' +
      ' jade.joinClasses([' + classes.join(',') + '].map(jade.joinClasses).map(function (cls, i) {'
; +
      '   return jade_interp[i] ? jade.escape(cls) : cls' +
      ' }))' +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.runtime.merge" id="apidoc.element.jade.runtime.merge">
        function <span class="apidocSignatureSpan">jade.runtime.</span>merge
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function merge(a, b) {
  if (arguments.length === 1) {
    var attrs = a[0];
    for (var i = 1; i &lt; a.length; i++) {
      attrs = merge(attrs, a[i]);
    }
    return attrs;
  }
  var ac = a['class'];
  var bc = b['class'];

  if (ac || bc) {
    ac = ac || [];
    bc = bc || [];
    if (!Array.isArray(ac)) ac = [ac];
    if (!Array.isArray(bc)) bc = [bc];
    a['class'] = ac.concat(bc).filter(nulls);
  }

  for (var key in b) {
    if (key != 'class') {
      a[key] = b[key];
    }
  }

  return a;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (attrsBlocks.length) {
  if (attrs.length) {
    var val = this.attrs(attrs);
    attrsBlocks.unshift(val);
  }
  this.buf.push('attributes: jade.<span class="apidocCodeKeywordSpan">merge</span>([' + attrsBlocks.join(',') + &amp;#
x27;])');
} else if (attrs.length) {
  var val = this.attrs(attrs);
  this.buf.push('attributes: ' + val);
}

if (args) {
  this.buf.push('}, ' + args + ');');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.runtime.rethrow" id="apidoc.element.jade.runtime.rethrow">
        function <span class="apidocSignatureSpan">jade.runtime.</span>rethrow
        <span class="apidocSignatureSpan">(err, filename, lineno, str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rethrow(err, filename, lineno, str){
  if (!(err instanceof Error)) throw err;
  if ((typeof window != 'undefined' || !filename) &amp;&amp; !str) {
    err.message += ' on line ' + lineno;
    throw err;
  }
  try {
    str = str || require('fs').readFileSync(filename, 'utf8')
  } catch (ex) {
    rethrow(err, null, lineno)
  }
  var context = 3
    , lines = str.split('\n')
    , start = Math.max(lineno - context, 0)
    , end = Math.min(lines.length, lineno + context);

  // Error context
  var context = lines.slice(start, end).map(function(line, i){
    var curr = i + start + 1;
    return (curr == lineno ? '  &gt; ' : '    ')
      + curr
      + '| '
      + line;
  }).join('\n');

  // Alter exception message
  err.path = filename;
  err.message = (filename || 'Jade') + ':' + lineno
    + '\n' + context + '\n\n' + err.message;
  throw err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var parser = new (options.parser || Parser)(str, options.filename, options);
var tokens;
try {
  // Parse
  tokens = parser.parse();
} catch (err) {
  parser = parser.context();
  runtime.<span class="apidocCodeKeywordSpan">rethrow</span>(err, parser.filename, parser.lexer.lineno, parser.input);
}

// Compile
var compiler = new (options.compiler || Compiler)(tokens, options);
var js;
try {
  js = compiler.compile();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.runtime.style" id="apidoc.element.jade.runtime.style">
        function <span class="apidocSignatureSpan">jade.runtime.</span>style
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">style = function (val) {
  if (val &amp;&amp; typeof val === 'object') {
    return Object.keys(val).map(function (style) {
      return style + ':' + val[style];
    }).join(';');
  } else {
    return val;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  classes.push(attr.val);
  classEscaping.push(attr.escaped);
} else if (isConstant(attr.val)) {
  if (buffer) {
    this.buffer(runtime.attr(key, toConstant(attr.val), escaped, this.terse));
  } else {
    var val = toConstant(attr.val);
    if (key === 'style') val = runtime.<span class="apidocCodeKeywordSpan">style</span>(val);
    if (escaped &amp;&amp; !(key.indexOf('data') === 0 &amp;&amp; typeof val !== 'string')) {
      val = runtime.escape(val);
    }
    buf.push(utils.stringify(key) + ': ' + utils.stringify(val));
  }
} else {
  if (buffer) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.utils" id="apidoc.module.jade.utils">module jade.utils</a></h1>


    <h2>
        <a href="#apidoc.element.jade.utils.merge" id="apidoc.element.jade.utils.merge">
        function <span class="apidocSignatureSpan">jade.utils.</span>merge
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function (a, b) {
  for (var key in b) a[key] = b[key];
  return a;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (attrsBlocks.length) {
  if (attrs.length) {
    var val = this.attrs(attrs);
    attrsBlocks.unshift(val);
  }
  this.buf.push('attributes: jade.<span class="apidocCodeKeywordSpan">merge</span>([' + attrsBlocks.join(',') + &amp;#
x27;])');
} else if (attrs.length) {
  var val = this.attrs(attrs);
  this.buf.push('attributes: ' + val);
}

if (args) {
  this.buf.push('}, ' + args + ');');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.utils.stringify" id="apidoc.element.jade.utils.stringify">
        function <span class="apidocSignatureSpan">jade.utils.</span>stringify
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringify = function (str) {
  return JSON.stringify(str)
             .replace(/\u2028/g, '\\u2028')
             .replace(/\u2029/g, '\\u2029');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {Function}
 * @api public
 */

exports.compile = function(str, options){
var options = options || {}
  , filename = options.filename
    ? utils.<span class="apidocCodeKeywordSpan">stringify</span>(options.filename)
    : 'undefined'
  , fn;

str = String(str);

var parsed = parse(str, options);
if (options.compileDebug !== false) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.utils.walkAST" id="apidoc.element.jade.utils.walkAST">
        function <span class="apidocSignatureSpan">jade.utils.</span>walkAST
        <span class="apidocSignatureSpan">(ast, before, after)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkAST(ast, before, after) {
  before &amp;&amp; before(ast);
  switch (ast.type) {
    case 'Block':
      ast.nodes.forEach(function (node) {
        walkAST(node, before, after);
      });
      break;
    case 'Case':
    case 'Each':
    case 'Mixin':
    case 'Tag':
    case 'When':
    case 'Code':
      ast.block &amp;&amp; walkAST(ast.block, before, after);
      break;
    case 'Attrs':
    case 'BlockComment':
    case 'Comment':
    case 'Doctype':
    case 'Filter':
    case 'Literal':
    case 'MixinBlock':
    case 'Text':
      break;
    default:
      throw new Error('Unexpected node type ' + ast.type);
      break;
  }
  after &amp;&amp; after(ast);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  for (var name in this.mixins)
    ast.unshift(this.mixins[name]);
  return ast;
}

if (!this.extending &amp;&amp; !this.included &amp;&amp; Object.keys(this.blocks).length){
  var blocks = [];
  utils.<span class="apidocCodeKeywordSpan">walkAST</span>(block, function (node) {
    if (node.type === 'Block' &amp;&amp; node.name) {
      blocks.push(node.name);
    }
  });
  Object.keys(this.blocks).forEach(function (name) {
    if (blocks.indexOf(name) === -1 &amp;&amp; !this.blocks[name].isSubBlock) {
      console.warn('Warning: Unexpected block "'
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>