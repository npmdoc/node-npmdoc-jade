<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://jade-lang.com"

    >jade (v1.11.0)</a>
</h1>
<h4>A clean, whitespace-sensitive template language for writing HTML</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade">module jade</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler">
            function <span class="apidocSignatureSpan">jade.</span>Compiler
            <span class="apidocSignatureSpan">(node, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer">
            function <span class="apidocSignatureSpan">jade.</span>Lexer
            <span class="apidocSignatureSpan">(str, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser">
            function <span class="apidocSignatureSpan">jade.</span>Parser
            <span class="apidocSignatureSpan">(str, filename, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.__express">
            function <span class="apidocSignatureSpan">jade.</span>__express
            <span class="apidocSignatureSpan">(path, options, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.compile">
            function <span class="apidocSignatureSpan">jade.</span>compile
            <span class="apidocSignatureSpan">(str, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.compileClient">
            function <span class="apidocSignatureSpan">jade.</span>compileClient
            <span class="apidocSignatureSpan">(str, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.compileClientWithDependenciesTracked">
            function <span class="apidocSignatureSpan">jade.</span>compileClientWithDependenciesTracked
            <span class="apidocSignatureSpan">(str, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.compileFile">
            function <span class="apidocSignatureSpan">jade.</span>compileFile
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.compileFileClient">
            function <span class="apidocSignatureSpan">jade.</span>compileFileClient
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.filters">
            function <span class="apidocSignatureSpan">jade.</span>filters
            <span class="apidocSignatureSpan">(name, str, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Block">
            function <span class="apidocSignatureSpan">jade.</span>nodes.Block
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.BlockComment">
            function <span class="apidocSignatureSpan">jade.</span>nodes.BlockComment
            <span class="apidocSignatureSpan">(val, block, buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Case">
            function <span class="apidocSignatureSpan">jade.</span>nodes.Case
            <span class="apidocSignatureSpan">(expr, block)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Code">
            function <span class="apidocSignatureSpan">jade.</span>nodes.Code
            <span class="apidocSignatureSpan">(val, buffer, escape)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Comment">
            function <span class="apidocSignatureSpan">jade.</span>nodes.Comment
            <span class="apidocSignatureSpan">(val, buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Doctype">
            function <span class="apidocSignatureSpan">jade.</span>nodes.Doctype
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Each">
            function <span class="apidocSignatureSpan">jade.</span>nodes.Each
            <span class="apidocSignatureSpan">(obj, val, key, block)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Filter">
            function <span class="apidocSignatureSpan">jade.</span>nodes.Filter
            <span class="apidocSignatureSpan">(name, block, attrs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Literal">
            function <span class="apidocSignatureSpan">jade.</span>nodes.Literal
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Mixin">
            function <span class="apidocSignatureSpan">jade.</span>nodes.Mixin
            <span class="apidocSignatureSpan">(name, args, block, call)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.MixinBlock">
            function <span class="apidocSignatureSpan">jade.</span>nodes.MixinBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Node">
            function <span class="apidocSignatureSpan">jade.</span>nodes.Node
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Tag">
            function <span class="apidocSignatureSpan">jade.</span>nodes.Tag
            <span class="apidocSignatureSpan">(name, block)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Text">
            function <span class="apidocSignatureSpan">jade.</span>nodes.Text
            <span class="apidocSignatureSpan">(line)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.render">
            function <span class="apidocSignatureSpan">jade.</span>render
            <span class="apidocSignatureSpan">(str, options, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.renderFile">
            function <span class="apidocSignatureSpan">jade.</span>renderFile
            <span class="apidocSignatureSpan">(path, options, fn)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan"></span>jade</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>Compiler.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>Lexer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>Parser.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>cache</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>doctypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.Block.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.BlockComment.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.Case.When.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.Case.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.Code.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.Comment.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.Doctype.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.Each.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.Filter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.Literal.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.Mixin.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.MixinBlock.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.Node.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.Tag.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>nodes.Text.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>runtime</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>selfClosing</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.Compiler">module jade.Compiler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.Compiler">
            function <span class="apidocSignatureSpan">jade.</span>Compiler
            <span class="apidocSignatureSpan">(node, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.Compiler.prototype">module jade.Compiler.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.attrs">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>attrs
            <span class="apidocSignatureSpan">(attrs, buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.buffer">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>buffer
            <span class="apidocSignatureSpan">(str, interpolate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.bufferExpression">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>bufferExpression
            <span class="apidocSignatureSpan">(src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.compile">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.prettyIndent">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>prettyIndent
            <span class="apidocSignatureSpan">(offset, newline)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.setDoctype">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>setDoctype
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visit">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visit
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitAttributes">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitAttributes
            <span class="apidocSignatureSpan">(attrs, attributeBlocks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitBlock">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitBlock
            <span class="apidocSignatureSpan">(block)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitBlockComment">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitBlockComment
            <span class="apidocSignatureSpan">(comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitCase">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitCase
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitCode">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitCode
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitComment">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitComment
            <span class="apidocSignatureSpan">(comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitDoctype">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitDoctype
            <span class="apidocSignatureSpan">(doctype)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitEach">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitEach
            <span class="apidocSignatureSpan">(each)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitFilter">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitFilter
            <span class="apidocSignatureSpan">(filter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitLiteral">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitLiteral
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitMixin">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitMixin
            <span class="apidocSignatureSpan">(mixin)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitMixinBlock">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitMixinBlock
            <span class="apidocSignatureSpan">(block)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitNode">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitTag">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitTag
            <span class="apidocSignatureSpan">(tag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitText">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitText
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Compiler.prototype.visitWhen">
            function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitWhen
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.Lexer">module jade.Lexer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.Lexer">
            function <span class="apidocSignatureSpan">jade.</span>Lexer
            <span class="apidocSignatureSpan">(str, filename)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.Lexer.prototype">module jade.Lexer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.advance">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>advance
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.append">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>append
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.attributesBlock">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>attributesBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.attrs">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>attrs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.blank">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>blank
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.block">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>block
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.blockCode">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>blockCode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.bracketExpression">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>bracketExpression
            <span class="apidocSignatureSpan">(skip)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.call">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>call
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.case">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>case
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.className">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>className
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.code">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>code
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.colon">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>colon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.comment">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>comment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.conditional">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>conditional
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.consume">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>consume
            <span class="apidocSignatureSpan">(len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.default">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>default
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.defer">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>defer
            <span class="apidocSignatureSpan">(tok)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.deferred">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>deferred
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.doctype">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>doctype
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.dot">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>dot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.each">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>each
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.eos">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>eos
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.extends">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>extends
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.fail">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>fail
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.filter">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>filter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.id">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>id
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.include">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>include
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.includeFiltered">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>includeFiltered
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.indent">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>indent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.interpolation">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>interpolation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.lookahead">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>lookahead
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.mixin">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>mixin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.mixinBlock">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>mixinBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.next">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>next
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.pipelessText">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>pipelessText
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.prepend">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>prepend
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.scan">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>scan
            <span class="apidocSignatureSpan">(regexp, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.stashed">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>stashed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.tag">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>tag
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.text">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>text
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.textFail">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>textFail
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.tok">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>tok
            <span class="apidocSignatureSpan">(type, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.when">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>when
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.while">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>while
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Lexer.prototype.yield">
            function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>yield
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.Parser">module jade.Parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.Parser">
            function <span class="apidocSignatureSpan">jade.</span>Parser
            <span class="apidocSignatureSpan">(str, filename, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.Parser.prototype">module jade.Parser.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.accept">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>accept
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.advance">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>advance
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.block">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>block
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>constructor
            <span class="apidocSignatureSpan">(str, filename, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.context">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>context
            <span class="apidocSignatureSpan">(parser)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.expect">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>expect
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.line">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>line
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.lookahead">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>lookahead
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parse">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseBlock">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseBlockCode">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseBlockCode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseBlockExpansion">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseBlockExpansion
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseCall">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseCall
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseCase">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseCase
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseCode">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseCode
            <span class="apidocSignatureSpan">(afterIf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseComment">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseComment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseDefault">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseDefault
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseDoctype">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseDoctype
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseEach">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseEach
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseExpr">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseExpr
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseExtends">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseExtends
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseFilter">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseFilter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseInclude">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseInclude
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseInlineTagsInText">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseInlineTagsInText
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseInterpolation">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseInterpolation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseMixin">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseMixin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseMixinBlock">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseMixinBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseTag">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseTag
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseText">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseText
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseTextBlock">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseTextBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.parseWhen">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseWhen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.peek">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>peek
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.resolvePath">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>resolvePath
            <span class="apidocSignatureSpan">(path, purpose)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.Parser.prototype.tag">
            function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>tag
            <span class="apidocSignatureSpan">(tag)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.jade">module jade.jade</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.jade.Compiler">
            function <span class="apidocSignatureSpan">jade.jade.</span>Compiler
            <span class="apidocSignatureSpan">(node, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.jade.Lexer">
            function <span class="apidocSignatureSpan">jade.jade.</span>Lexer
            <span class="apidocSignatureSpan">(str, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.jade.Parser">
            function <span class="apidocSignatureSpan">jade.jade.</span>Parser
            <span class="apidocSignatureSpan">(str, filename, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.jade.__express">
            function <span class="apidocSignatureSpan">jade.jade.</span>__express
            <span class="apidocSignatureSpan">(path, options, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.jade.compile">
            function <span class="apidocSignatureSpan">jade.jade.</span>compile
            <span class="apidocSignatureSpan">(str, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.jade.compileClient">
            function <span class="apidocSignatureSpan">jade.jade.</span>compileClient
            <span class="apidocSignatureSpan">(str, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.jade.compileClientWithDependenciesTracked">
            function <span class="apidocSignatureSpan">jade.jade.</span>compileClientWithDependenciesTracked
            <span class="apidocSignatureSpan">(str, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.jade.compileFile">
            function <span class="apidocSignatureSpan">jade.jade.</span>compileFile
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.jade.compileFileClient">
            function <span class="apidocSignatureSpan">jade.jade.</span>compileFileClient
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.jade.filters">
            function <span class="apidocSignatureSpan">jade.jade.</span>filters
            <span class="apidocSignatureSpan">(name, str, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.jade.render">
            function <span class="apidocSignatureSpan">jade.jade.</span>render
            <span class="apidocSignatureSpan">(str, options, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.jade.renderFile">
            function <span class="apidocSignatureSpan">jade.jade.</span>renderFile
            <span class="apidocSignatureSpan">(path, options, fn)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.jade.</span>cache</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.jade.</span>doctypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.jade.</span>nodes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.jade.</span>runtime</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.jade.</span>selfClosing</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jade.jade.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes">module jade.nodes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Block">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Block
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.BlockComment">
            function <span class="apidocSignatureSpan">jade.nodes.</span>BlockComment
            <span class="apidocSignatureSpan">(val, block, buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Case">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Case
            <span class="apidocSignatureSpan">(expr, block)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Code">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Code
            <span class="apidocSignatureSpan">(val, buffer, escape)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Comment">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Comment
            <span class="apidocSignatureSpan">(val, buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Doctype">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Doctype
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Each">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Each
            <span class="apidocSignatureSpan">(obj, val, key, block)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Filter">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Filter
            <span class="apidocSignatureSpan">(name, block, attrs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Literal">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Literal
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Mixin">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Mixin
            <span class="apidocSignatureSpan">(name, args, block, call)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.MixinBlock">
            function <span class="apidocSignatureSpan">jade.nodes.</span>MixinBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Node">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Node
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Tag">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Tag
            <span class="apidocSignatureSpan">(name, block)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Text">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Text
            <span class="apidocSignatureSpan">(line)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Block">module jade.nodes.Block</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Block.Block">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Block
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Block.prototype">module jade.nodes.Block.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>isBlock</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Block.prototype.clone">
            function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Block.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>constructor
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Block.prototype.includeBlock">
            function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>includeBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Block.prototype.isEmpty">
            function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Block.prototype.push">
            function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>push
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Block.prototype.replace">
            function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>replace
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Block.prototype.unshift">
            function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>unshift
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.BlockComment">module jade.nodes.BlockComment</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.BlockComment.BlockComment">
            function <span class="apidocSignatureSpan">jade.nodes.</span>BlockComment
            <span class="apidocSignatureSpan">(val, block, buffer)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.BlockComment.prototype">module jade.nodes.BlockComment.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.BlockComment.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.BlockComment.prototype.</span>constructor
            <span class="apidocSignatureSpan">(val, block, buffer)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.BlockComment.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Case">module jade.nodes.Case</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Case.Case">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Case
            <span class="apidocSignatureSpan">(expr, block)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Case.When">
            function <span class="apidocSignatureSpan">jade.nodes.Case.</span>When
            <span class="apidocSignatureSpan">(expr, block)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Case.When.prototype">module jade.nodes.Case.When.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Case.When.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.Case.When.prototype.</span>constructor
            <span class="apidocSignatureSpan">(expr, block)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.Case.When.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Case.prototype">module jade.nodes.Case.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Case.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.Case.prototype.</span>constructor
            <span class="apidocSignatureSpan">(expr, block)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.Case.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Code">module jade.nodes.Code</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Code.Code">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Code
            <span class="apidocSignatureSpan">(val, buffer, escape)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Code.prototype">module jade.nodes.Code.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Code.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.Code.prototype.</span>constructor
            <span class="apidocSignatureSpan">(val, buffer, escape)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.Code.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Comment">module jade.nodes.Comment</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Comment.Comment">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Comment
            <span class="apidocSignatureSpan">(val, buffer)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Comment.prototype">module jade.nodes.Comment.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Comment.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.Comment.prototype.</span>constructor
            <span class="apidocSignatureSpan">(val, buffer)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.Comment.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Doctype">module jade.nodes.Doctype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Doctype.Doctype">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Doctype
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Doctype.prototype">module jade.nodes.Doctype.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Doctype.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.Doctype.prototype.</span>constructor
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.Doctype.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Each">module jade.nodes.Each</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Each.Each">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Each
            <span class="apidocSignatureSpan">(obj, val, key, block)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Each.prototype">module jade.nodes.Each.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Each.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.Each.prototype.</span>constructor
            <span class="apidocSignatureSpan">(obj, val, key, block)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.Each.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Filter">module jade.nodes.Filter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Filter.Filter">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Filter
            <span class="apidocSignatureSpan">(name, block, attrs)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Filter.prototype">module jade.nodes.Filter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Filter.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.Filter.prototype.</span>constructor
            <span class="apidocSignatureSpan">(name, block, attrs)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.Filter.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Literal">module jade.nodes.Literal</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Literal.Literal">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Literal
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Literal.prototype">module jade.nodes.Literal.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Literal.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.Literal.prototype.</span>constructor
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.Literal.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Mixin">module jade.nodes.Mixin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Mixin.Mixin">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Mixin
            <span class="apidocSignatureSpan">(name, args, block, call)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Mixin.prototype">module jade.nodes.Mixin.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Mixin.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.Mixin.prototype.</span>constructor
            <span class="apidocSignatureSpan">(name, args, block, call)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.Mixin.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.MixinBlock">module jade.nodes.MixinBlock</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.MixinBlock.MixinBlock">
            function <span class="apidocSignatureSpan">jade.nodes.</span>MixinBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.MixinBlock.prototype">module jade.nodes.MixinBlock.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.MixinBlock.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.MixinBlock.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.MixinBlock.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Node">module jade.nodes.Node</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Node.Node">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Node
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Node.prototype">module jade.nodes.Node.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Node.prototype.clone">
            function <span class="apidocSignatureSpan">jade.nodes.Node.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.Node.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Tag">module jade.nodes.Tag</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Tag.Tag">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Tag
            <span class="apidocSignatureSpan">(name, block)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Tag.prototype">module jade.nodes.Tag.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Tag.prototype.canInline">
            function <span class="apidocSignatureSpan">jade.nodes.Tag.prototype.</span>canInline
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Tag.prototype.clone">
            function <span class="apidocSignatureSpan">jade.nodes.Tag.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Tag.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.Tag.prototype.</span>constructor
            <span class="apidocSignatureSpan">(name, block)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Tag.prototype.isInline">
            function <span class="apidocSignatureSpan">jade.nodes.Tag.prototype.</span>isInline
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.Tag.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Text">module jade.nodes.Text</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Text.Text">
            function <span class="apidocSignatureSpan">jade.nodes.</span>Text
            <span class="apidocSignatureSpan">(line)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.nodes.Text.prototype">module jade.nodes.Text.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">jade.nodes.Text.prototype.</span>isText</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.nodes.Text.prototype.constructor">
            function <span class="apidocSignatureSpan">jade.nodes.Text.prototype.</span>constructor
            <span class="apidocSignatureSpan">(line)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">jade.nodes.Text.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.runtime">module jade.runtime</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.runtime.DebugItem">
            function <span class="apidocSignatureSpan">jade.runtime.</span>DebugItem
            <span class="apidocSignatureSpan">(lineno, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.runtime.attr">
            function <span class="apidocSignatureSpan">jade.runtime.</span>attr
            <span class="apidocSignatureSpan">(key, val, escaped, terse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.runtime.attrs">
            function <span class="apidocSignatureSpan">jade.runtime.</span>attrs
            <span class="apidocSignatureSpan">(obj, terse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.runtime.cls">
            function <span class="apidocSignatureSpan">jade.runtime.</span>cls
            <span class="apidocSignatureSpan">(classes, escaped)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.runtime.escape">
            function <span class="apidocSignatureSpan">jade.runtime.</span>escape
            <span class="apidocSignatureSpan">(html)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.runtime.joinClasses">
            function <span class="apidocSignatureSpan">jade.runtime.</span>joinClasses
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.runtime.merge">
            function <span class="apidocSignatureSpan">jade.runtime.</span>merge
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.runtime.rethrow">
            function <span class="apidocSignatureSpan">jade.runtime.</span>rethrow
            <span class="apidocSignatureSpan">(err, filename, lineno, str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.runtime.style">
            function <span class="apidocSignatureSpan">jade.runtime.</span>style
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jade.utils">module jade.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.utils.merge">
            function <span class="apidocSignatureSpan">jade.utils.</span>merge
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.utils.stringify">
            function <span class="apidocSignatureSpan">jade.utils.</span>stringify
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jade.utils.walkAST">
            function <span class="apidocSignatureSpan">jade.utils.</span>walkAST
            <span class="apidocSignatureSpan">(ast, before, after)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade" id="apidoc.module.jade">module jade</a></h1>


    <h2>
        <a href="#apidoc.element.jade.Compiler" id="apidoc.element.jade.Compiler">
        function <span class="apidocSignatureSpan">jade.</span>Compiler
        <span class="apidocSignatureSpan">(node, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Compiler(node, options) {
  this.options = options = options || {};
  this.node = node;
  this.hasCompiledDoctype = false;
  this.hasCompiledTag = false;
  this.pp = options.pretty || false;
  if (this.pp &#x26;&#x26; typeof this.pp !== &#x27;string&#x27;) {
    this.pp = &#x27;  &#x27;;
  }
  this.debug = false !== options.compileDebug;
  this.indents = 0;
  this.parentIndents = 0;
  this.terse = false;
  this.mixins = {};
  this.dynamicMixins = false;
  if (options.doctype) this.setDoctype(options.doctype);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer" id="apidoc.element.jade.Lexer">
        function <span class="apidocSignatureSpan">jade.</span>Lexer
        <span class="apidocSignatureSpan">(str, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Lexer(str, filename) {
  this.input = str.replace(/\r\n|\r/g, &#x27;\n&#x27;);
  this.filename = filename;
  this.deferredTokens = [];
  this.lastIndents = 0;
  this.lineno = 1;
  this.stash = [];
  this.indentStack = [];
  this.indentRe = null;
  this.pipeless = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser" id="apidoc.element.jade.Parser">
        function <span class="apidocSignatureSpan">jade.</span>Parser
        <span class="apidocSignatureSpan">(str, filename, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(str, filename, options){
  //Strip any UTF-8 BOM off of the start of `str`, if it exists.
  this.input = str.replace(/^\uFEFF/, &#x27;&#x27;);
  this.lexer = new Lexer(this.input, filename);
  this.filename = filename;
  this.blocks = {};
  this.mixins = {};
  this.options = options;
  this.contexts = [this];
  this.inMixin = 0;
  this.dependencies = [];
  this.inBlock = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.__express" id="apidoc.element.jade.__express">
        function <span class="apidocSignatureSpan">jade.</span>__express
        <span class="apidocSignatureSpan">(path, options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__express = function (path, options, fn) {
  if(options.compileDebug == undefined &#x26;&#x26; process.env.NODE_ENV === &#x27;production&#x27;) {
    options.compileDebug = false;
  }
  exports.renderFile(path, options, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.compile" id="apidoc.element.jade.compile">
        function <span class="apidocSignatureSpan">jade.</span>compile
        <span class="apidocSignatureSpan">(str, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (str, options){
  var options = options || {}
    , filename = options.filename
      ? utils.stringify(options.filename)
      : &#x27;undefined&#x27;
    , fn;

  str = String(str);

  var parsed = parse(str, options);
  if (options.compileDebug !== false) {
    fn = [
        &#x27;var jade_debug = [ new jade.DebugItem( 1, &#x27; + filename + &#x27; ) ];&#x27;
      , &#x27;try {&#x27;
      , parsed.body
      , &#x27;} catch (err) {&#x27;
      , &#x27;  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno&#x27; + (options.compileDebug === true ? &#x27;,&#x27; + utils.stringify
(str) : &#x27;&#x27;) + &#x27;);&#x27;
      , &#x27;}&#x27;
    ].join(&#x27;\n&#x27;);
  } else {
    fn = parsed.body;
  }
  fn = new Function(&#x27;locals, jade&#x27;, fn)
  var res = function(locals){ return fn(locals, Object.create(runtime)) };
  if (options.client) {
    res.toString = function () {
      var err = new Error(&#x27;The `client` option is deprecated, use the `jade.compileClient` method instead&#x27;);
      err.name = &#x27;Warning&#x27;;
      console.error(err.stack || /* istanbul ignore next */ err.message);
      return exports.compileClient(str, options);
    };
  }
  res.dependencies = parsed.dependencies;
  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

For full API, see [jade-lang.com/api](http://jade-lang.com/api/)

```js
var jade = require(&#x27;jade&#x27;);

// compile
var fn = jade.<span class="apidocCodeKeywordSpan">compile</span>(&#x27;string of jade&#x27;, options);
var html = fn(locals);

// render
var html = jade.render(&#x27;string of jade&#x27;, merge(options, locals));

// renderFile
var html = jade.renderFile(&#x27;filename.jade&#x27;, merge(options, locals));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.compileClient" id="apidoc.element.jade.compileClient">
        function <span class="apidocSignatureSpan">jade.</span>compileClient
        <span class="apidocSignatureSpan">(str, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileClient = function (str, options) {
  return exports.compileClientWithDependenciesTracked(str, options).body;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  fn = new Function(&#x27;locals, jade&#x27;, fn)
  var res = function(locals){ return fn(locals, Object.create(runtime)) };
  if (options.client) {
    res.toString = function () {
      var err = new Error(&#x27;The `client` option is deprecated, use the `jade.compileClient` method instead&#x27;);
      err.name = &#x27;Warning&#x27;;
      console.error(err.stack || /* istanbul ignore next */ err.message);
      return exports.<span class="apidocCodeKeywordSpan">compileClient</span>(str, options);
    };
  }
  res.dependencies = parsed.dependencies;
  return res;
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.compileClientWithDependenciesTracked" id="apidoc.element.jade.compileClientWithDependenciesTracked">
        function <span class="apidocSignatureSpan">jade.</span>compileClientWithDependenciesTracked
        <span class="apidocSignatureSpan">(str, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileClientWithDependenciesTracked = function (str, options){
  var options = options || {};
  var name = options.name || &#x27;template&#x27;;
  var filename = options.filename ? utils.stringify(options.filename) : &#x27;undefined&#x27;;
  var fn;

  str = String(str);
  options.compileDebug = options.compileDebug ? true : false;
  var parsed = parse(str, options);
  if (options.compileDebug) {
    fn = [
        &#x27;var jade_debug = [ new jade.DebugItem( 1, &#x27; + filename + &#x27; ) ];&#x27;
      , &#x27;try {&#x27;
      , parsed.body
      , &#x27;} catch (err) {&#x27;
      , &#x27;  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno, &#x27; + utils.stringify(str) + &#x27;);&#x27;
      , &#x27;}&#x27;
    ].join(&#x27;\n&#x27;);
  } else {
    fn = parsed.body;
  }

  return {body: &#x27;function &#x27; + name + &#x27;(locals) {\n&#x27; + fn + &#x27;\n}&#x27;, dependencies: parsed.dependencies};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @param {String} str
* @param {Options} options
* @return {String}
* @api public
*/
exports.compileClient = function (str, options) {
 return exports.<span class="apidocCodeKeywordSpan">compileClientWithDependenciesTracked</span>(str, options).body;
};

/**
* Compile a `Function` representation of the given jade file.
*
* Options:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.compileFile" id="apidoc.element.jade.compileFile">
        function <span class="apidocSignatureSpan">jade.</span>compileFile
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileFile = function (path, options) {
  options = options || {};
  options.filename = path;
  return handleTemplateCache(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.compileFileClient" id="apidoc.element.jade.compileFileClient">
        function <span class="apidocSignatureSpan">jade.</span>compileFileClient
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileFileClient = function (path, options){
  var key = path + &#x27;:client&#x27;;
  options = options || {};

  options.filename = path;

  if (options.cache &#x26;&#x26; exports.cache[key]) {
    return exports.cache[key];
  }

  var str = fs.readFileSync(options.filename, &#x27;utf8&#x27;);
  var out = exports.compileClient(str, options);
  if (options.cache) exports.cache[key] = out;
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.filters" id="apidoc.element.jade.filters">
        function <span class="apidocSignatureSpan">jade.</span>filters
        <span class="apidocSignatureSpan">(name, str, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filter(name, str, options) {
  if (typeof filter[name] === &#x27;function&#x27;) {
    return filter[name](str, options);
  } else {
    var tr;
    try {
      tr = jstransformer(require(&#x27;jstransformer-&#x27; + name));
    } catch (ex) {}
    if (tr) {
      // TODO: we may want to add a way for people to separately specify &#x22;locals&#x22;
      var result = tr.render(str, options, options).body;
      if (options &#x26;&#x26; options.minify) {
        try {
          switch (tr.outputFormat) {
            case &#x27;js&#x27;:
              result = uglify.minify(result, {fromString: true}).code;
              break;
            case &#x27;css&#x27;:
              result = new CleanCSS().minify(result).styles;
              break;
          }
        } catch (ex) {
          // better to fail to minify than output nothing
        }
      }
      return result;
    } else if (transformers[name]) {
      if (!warned[name]) {
        warned[name] = true;
        if (name === &#x27;md&#x27; || name === &#x27;markdown&#x27;) {
          var implementation = getMarkdownImplementation();
          console.log(&#x27;Transformers.&#x27; + name + &#x27; is deprecated, you must replace the :&#x27; +
                      name + &#x27; jade filter, with :&#x27; +
                      implementation + &#x27; and install jstransformer-&#x27; +
                      implementation + &#x27; before you update to jade@2.0.0.&#x27;);
        } else if (alternatives[name]) {
          console.log(&#x27;Transformers.&#x27; + name + &#x27; is deprecated, you must replace the :&#x27; +
                      name + &#x27; jade filter, with :&#x27; +
                      alternatives[name] + &#x27; and install jstransformer-&#x27; +
                      alternatives[name] + &#x27; before you update to jade@2.0.0.&#x27;);
        } else {
          console.log(&#x27;Transformers.&#x27; + name + &#x27; is deprecated, to continue using the :&#x27; +
                      name + &#x27; jade filter after jade@2.0.0, you will need to install jstransformer-&#x27; +
                      name.toLowerCase() + &#x27;.&#x27;);
        }
      }
      return transformers[name].renderSync(str, options);
    } else {
      throw new Error(&#x27;unknown filter &#x22;:&#x27; + name + &#x27;&#x22;&#x27;);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Block" id="apidoc.element.jade.nodes.Block">
        function <span class="apidocSignatureSpan">jade.</span>nodes.Block
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Block(node){
  this.nodes = [];
  if (node) this.push(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.BlockComment" id="apidoc.element.jade.nodes.BlockComment">
        function <span class="apidocSignatureSpan">jade.</span>nodes.BlockComment
        <span class="apidocSignatureSpan">(val, block, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BlockComment(val, block, buffer) {
  this.block = block;
  this.val = val;
  this.buffer = buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Case" id="apidoc.element.jade.nodes.Case">
        function <span class="apidocSignatureSpan">jade.</span>nodes.Case
        <span class="apidocSignatureSpan">(expr, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Case(expr, block){
  this.expr = expr;
  this.block = block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Code" id="apidoc.element.jade.nodes.Code">
        function <span class="apidocSignatureSpan">jade.</span>nodes.Code
        <span class="apidocSignatureSpan">(val, buffer, escape)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Code(val, buffer, escape) {
  this.val = val;
  this.buffer = buffer;
  this.escape = escape;
  if (val.match(/^ *else/)) this.debug = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Comment" id="apidoc.element.jade.nodes.Comment">
        function <span class="apidocSignatureSpan">jade.</span>nodes.Comment
        <span class="apidocSignatureSpan">(val, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Comment(val, buffer) {
  this.val = val;
  this.buffer = buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Doctype" id="apidoc.element.jade.nodes.Doctype">
        function <span class="apidocSignatureSpan">jade.</span>nodes.Doctype
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Doctype(val) {
  this.val = val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Each" id="apidoc.element.jade.nodes.Each">
        function <span class="apidocSignatureSpan">jade.</span>nodes.Each
        <span class="apidocSignatureSpan">(obj, val, key, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Each(obj, val, key, block) {
  this.obj = obj;
  this.val = val;
  this.key = key;
  this.block = block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Filter" id="apidoc.element.jade.nodes.Filter">
        function <span class="apidocSignatureSpan">jade.</span>nodes.Filter
        <span class="apidocSignatureSpan">(name, block, attrs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Filter(name, block, attrs) {
  this.name = name;
  this.block = block;
  this.attrs = attrs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Literal" id="apidoc.element.jade.nodes.Literal">
        function <span class="apidocSignatureSpan">jade.</span>nodes.Literal
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Literal(str) {
  this.str = str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Mixin" id="apidoc.element.jade.nodes.Mixin">
        function <span class="apidocSignatureSpan">jade.</span>nodes.Mixin
        <span class="apidocSignatureSpan">(name, args, block, call)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Mixin(name, args, block, call){
  Attrs.call(this);
  this.name = name;
  this.args = args;
  this.block = block;
  this.call = call;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.MixinBlock" id="apidoc.element.jade.nodes.MixinBlock">
        function <span class="apidocSignatureSpan">jade.</span>nodes.MixinBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MixinBlock(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Node" id="apidoc.element.jade.nodes.Node">
        function <span class="apidocSignatureSpan">jade.</span>nodes.Node
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Node(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Tag" id="apidoc.element.jade.nodes.Tag">
        function <span class="apidocSignatureSpan">jade.</span>nodes.Tag
        <span class="apidocSignatureSpan">(name, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Tag(name, block) {
  Attrs.call(this);
  this.name = name;
  this.block = block || new Block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Text" id="apidoc.element.jade.nodes.Text">
        function <span class="apidocSignatureSpan">jade.</span>nodes.Text
        <span class="apidocSignatureSpan">(line)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Text(line) {
  this.val = line;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.render" id="apidoc.element.jade.render">
        function <span class="apidocSignatureSpan">jade.</span>render
        <span class="apidocSignatureSpan">(str, options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">render = function (str, options, fn){
  // support callback API
  if (&#x27;function&#x27; == typeof options) {
    fn = options, options = undefined;
  }
  if (typeof fn === &#x27;function&#x27;) {
    var res
    try {
      res = exports.render(str, options);
    } catch (ex) {
      return fn(ex);
    }
    return fn(null, res);
  }

  options = options || {};

  // cache requires .filename
  if (options.cache &#x26;&#x26; !options.filename) {
    throw new Error(&#x27;the &#x22;filename&#x22; option is required for caching&#x27;);
  }

  return handleTemplateCache(options, str)(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var jade = require(&#x27;jade&#x27;);

// compile
var fn = jade.compile(&#x27;string of jade&#x27;, options);
var html = fn(locals);

// render
var html = jade.<span class="apidocCodeKeywordSpan">render</span>(&#x27;string of jade&#x27;, merge(options, locals));

// renderFile
var html = jade.renderFile(&#x27;filename.jade&#x27;, merge(options, locals));
```

### Options
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.renderFile" id="apidoc.element.jade.renderFile">
        function <span class="apidocSignatureSpan">jade.</span>renderFile
        <span class="apidocSignatureSpan">(path, options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renderFile = function (path, options, fn){
  // support callback API
  if (&#x27;function&#x27; == typeof options) {
    fn = options, options = undefined;
  }
  if (typeof fn === &#x27;function&#x27;) {
    var res
    try {
      res = exports.renderFile(path, options);
    } catch (ex) {
      return fn(ex);
    }
    return fn(null, res);
  }

  options = options || {};

  options.filename = path;
  return handleTemplateCache(options)(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fn = jade.compile(&#x27;string of jade&#x27;, options);
var html = fn(locals);

// render
var html = jade.render(&#x27;string of jade&#x27;, merge(options, locals));

// renderFile
var html = jade.<span class="apidocCodeKeywordSpan">renderFile</span>(&#x27;filename.jade&#x27;, merge(options, locals));
```

### Options

- `filename`  Used in exceptions, and required when using includes
- `compileDebug`  When `false` no debug instrumentation is compiled
- `pretty`    Add pretty-indentation whitespace to output _(false by default)_
...</pre></li>
    </ul>




















































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.Compiler" id="apidoc.module.jade.Compiler">module jade.Compiler</a></h1>


    <h2>
        <a href="#apidoc.element.jade.Compiler.Compiler" id="apidoc.element.jade.Compiler.Compiler">
        function <span class="apidocSignatureSpan">jade.</span>Compiler
        <span class="apidocSignatureSpan">(node, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Compiler(node, options) {
  this.options = options = options || {};
  this.node = node;
  this.hasCompiledDoctype = false;
  this.hasCompiledTag = false;
  this.pp = options.pretty || false;
  if (this.pp &#x26;&#x26; typeof this.pp !== &#x27;string&#x27;) {
    this.pp = &#x27;  &#x27;;
  }
  this.debug = false !== options.compileDebug;
  this.indents = 0;
  this.parentIndents = 0;
  this.terse = false;
  this.mixins = {};
  this.dynamicMixins = false;
  if (options.doctype) this.setDoctype(options.doctype);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.Compiler.prototype" id="apidoc.module.jade.Compiler.prototype">module jade.Compiler.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.attrs" id="apidoc.element.jade.Compiler.prototype.attrs">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>attrs
        <span class="apidocSignatureSpan">(attrs, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attrs = function (attrs, buffer){
  var buf = [];
  var classes = [];
  var classEscaping = [];

  attrs.forEach(function(attr){
    var key = attr.name;
    var escaped = attr.escaped;

    if (key === &#x27;class&#x27;) {
      classes.push(attr.val);
      classEscaping.push(attr.escaped);
    } else if (isConstant(attr.val)) {
      if (buffer) {
        this.buffer(runtime.attr(key, toConstant(attr.val), escaped, this.terse));
      } else {
        var val = toConstant(attr.val);
        if (key === &#x27;style&#x27;) val = runtime.style(val);
        if (escaped &#x26;&#x26; !(key.indexOf(&#x27;data&#x27;) === 0 &#x26;&#x26; typeof val !== &#x27;string&#x27;)) {
          val = runtime.escape(val);
        }
        buf.push(utils.stringify(key) + &#x27;: &#x27; + utils.stringify(val));
      }
    } else {
      if (buffer) {
        this.bufferExpression(&#x27;jade.attr(&#x22;&#x27; + key + &#x27;&#x22;, &#x27; + attr.val + &#x27;, &#x27; + utils.stringify(escaped) + &#x27;, &#x27; + utils.stringify(
this.terse) + &#x27;)&#x27;);
      } else {
        var val = attr.val;
        if (key === &#x27;style&#x27;) {
          val = &#x27;jade.style(&#x27; + val + &#x27;)&#x27;;
        }
        if (escaped &#x26;&#x26; !(key.indexOf(&#x27;data&#x27;) === 0)) {
          val = &#x27;jade.escape(&#x27; + val + &#x27;)&#x27;;
        } else if (escaped) {
          val = &#x27;(typeof (jade_interp = &#x27; + val + &#x27;) == &#x22;string&#x22; ? jade.escape(jade_interp) : jade_interp)&#x27;;
        }
        buf.push(utils.stringify(key) + &#x27;: &#x27; + val);
      }
    }
  }.bind(this));
  if (buffer) {
    if (classes.every(isConstant)) {
      this.buffer(runtime.cls(classes.map(toConstant), classEscaping));
    } else {
      this.bufferExpression(&#x27;jade.cls([&#x27; + classes.join(&#x27;,&#x27;) + &#x27;], &#x27; + utils.stringify(classEscaping) + &#x27;)&#x27;);
    }
  } else if (classes.length) {
    if (classes.every(isConstant)) {
      classes = utils.stringify(runtime.joinClasses(classes.map(toConstant).map(runtime.joinClasses).map(function (cls, i) {
        return classEscaping[i] ? runtime.escape(cls) : cls;
      })));
    } else {
      classes = &#x27;(jade_interp = &#x27; + utils.stringify(classEscaping) + &#x27;,&#x27; +
        &#x27; jade.joinClasses([&#x27; + classes.join(&#x27;,&#x27;) + &#x27;].map(jade.joinClasses).map(function (cls, i) {&#x27; +
        &#x27;   return jade_interp[i] ? jade.escape(cls) : cls&#x27; +
        &#x27; }))&#x27; +
        &#x27;)&#x27;;
    }
    if (classes.length)
      buf.push(&#x27;&#x22;class&#x22;: &#x27; + classes);
  }
  return &#x27;{&#x27; + buf.join(&#x27;,&#x27;) + &#x27;}&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    this.buf.push(&#x27;}&#x27;);
  }
}

if (attrsBlocks.length) {
  if (attrs.length) {
    var val = this.<span class="apidocCodeKeywordSpan">attrs</span>(attrs);
    attrsBlocks.unshift(val);
  }
  this.buf.push(&#x27;attributes: jade.merge([&#x27; + attrsBlocks.join(&#x27;,&#x27;) + &#x27;])&#x27;);
} else if (attrs.length) {
  var val = this.attrs(attrs);
  this.buf.push(&#x27;attributes: &#x27; + val);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.buffer" id="apidoc.element.jade.Compiler.prototype.buffer">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>buffer
        <span class="apidocSignatureSpan">(str, interpolate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buffer = function (str, interpolate) {
  var self = this;
  if (interpolate) {
    var match = /(\\)?([#!]){((?:.|\n)*)$/.exec(str);
    if (match) {
      this.buffer(str.substr(0, match.index), false);
      if (match[1]) { // escape
        this.buffer(match[2] + &#x27;{&#x27;, false);
        this.buffer(match[3], true);
        return;
      } else {
        var rest = match[3];
        var range = parseJSExpression(rest);
        var code = (&#x27;!&#x27; == match[2] ? &#x27;&#x27; : &#x27;jade.escape&#x27;) + &#x22;((jade_interp = &#x22; + range.src + &#x22;) == null ? &#x27;&#x27; : jade_interp)&#x22;;
        this.bufferExpression(code);
        this.buffer(rest.substr(range.end + 1), true);
        return;
      }
    }
  }

  str = utils.stringify(str);
  str = str.substr(1, str.length - 2);

  if (this.lastBufferedIdx == this.buf.length) {
    if (this.lastBufferedType === &#x27;code&#x27;) this.lastBuffered += &#x27; + &#x22;&#x27;;
    this.lastBufferedType = &#x27;text&#x27;;
    this.lastBuffered += str;
    this.buf[this.lastBufferedIdx - 1] = &#x27;buf.push(&#x27; + this.bufferStartChar + this.lastBuffered + &#x27;&#x22;);&#x27;
  } else {
    this.buf.push(&#x27;buf.push(&#x22;&#x27; + str + &#x27;&#x22;);&#x27;);
    this.lastBufferedType = &#x27;text&#x27;;
    this.bufferStartChar = &#x27;&#x22;&#x27;;
    this.lastBuffered = str;
    this.lastBufferedIdx = this.buf.length;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */

buffer: function (str, interpolate) {
  var self = this;
  if (interpolate) {
    var match = /(\\)?([#!]){((?:.|\n)*)$/.exec(str);
    if (match) {
      this.<span class="apidocCodeKeywordSpan">buffer</span>(str.substr(0, match.index), false);
      if (match[1]) { // escape
        this.buffer(match[2] + &#x27;{&#x27;, false);
        this.buffer(match[3], true);
        return;
      } else {
        var rest = match[3];
        var range = parseJSExpression(rest);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.bufferExpression" id="apidoc.element.jade.Compiler.prototype.bufferExpression">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>bufferExpression
        <span class="apidocSignatureSpan">(src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferExpression = function (src) {
  if (isConstant(src)) {
    return this.buffer(toConstant(src) + &#x27;&#x27;, false)
  }
  if (this.lastBufferedIdx == this.buf.length) {
    if (this.lastBufferedType === &#x27;text&#x27;) this.lastBuffered += &#x27;&#x22;&#x27;;
    this.lastBufferedType = &#x27;code&#x27;;
    this.lastBuffered += &#x27; + (&#x27; + src + &#x27;)&#x27;;
    this.buf[this.lastBufferedIdx - 1] = &#x27;buf.push(&#x27; + this.bufferStartChar + this.lastBuffered + &#x27;);&#x27;
  } else {
    this.buf.push(&#x27;buf.push(&#x27; + src + &#x27;);&#x27;);
    this.lastBufferedType = &#x27;code&#x27;;
    this.bufferStartChar = &#x27;&#x27;;
    this.lastBuffered = &#x27;(&#x27; + src + &#x27;)&#x27;;
    this.lastBufferedIdx = this.buf.length;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      this.buffer(match[2] + &#x27;{&#x27;, false);
      this.buffer(match[3], true);
      return;
    } else {
      var rest = match[3];
      var range = parseJSExpression(rest);
      var code = (&#x27;!&#x27; == match[2] ? &#x27;&#x27; : &#x27;jade.escape&#x27;) + &#x22;((jade_interp = &#x22; + range.src
 + &#x22;) == null ? &#x27;&#x27; : jade_interp)&#x22;;
      this.<span class="apidocCodeKeywordSpan">bufferExpression</span>(code);
      this.buffer(rest.substr(range.end + 1), true);
      return;
    }
  }
}

str = utils.stringify(str);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.compile" id="apidoc.element.jade.Compiler.prototype.compile">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (){
  this.buf = [];
  if (this.pp) this.buf.push(&#x22;var jade_indent = [];&#x22;);
  this.lastBufferedIdx = -1;
  this.visit(this.node);
  if (!this.dynamicMixins) {
    // if there are no dynamic mixins we can remove any un-used mixins
    var mixinNames = Object.keys(this.mixins);
    for (var i = 0; i &#x3c; mixinNames.length; i++) {
      var mixin = this.mixins[mixinNames[i]];
      if (!mixin.used) {
        for (var x = 0; x &#x3c; mixin.instances.length; x++) {
          for (var y = mixin.instances[x].start; y &#x3c; mixin.instances[x].end; y++) {
            this.buf[y] = &#x27;&#x27;;
          }
        }
      }
    }
  }
  return this.buf.join(&#x27;\n&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

For full API, see [jade-lang.com/api](http://jade-lang.com/api/)

```js
var jade = require(&#x27;jade&#x27;);

// compile
var fn = jade.<span class="apidocCodeKeywordSpan">compile</span>(&#x27;string of jade&#x27;, options);
var html = fn(locals);

// render
var html = jade.render(&#x27;string of jade&#x27;, merge(options, locals));

// renderFile
var html = jade.renderFile(&#x27;filename.jade&#x27;, merge(options, locals));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.prettyIndent" id="apidoc.element.jade.Compiler.prototype.prettyIndent">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>prettyIndent
        <span class="apidocSignatureSpan">(offset, newline)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prettyIndent = function (offset, newline){
  offset = offset || 0;
  newline = newline ? &#x27;\n&#x27; : &#x27;&#x27;;
  this.buffer(newline + Array(this.indents + offset).join(this.pp));
  if (this.parentIndents)
    this.buf.push(&#x22;buf.push.apply(buf, jade_indent);&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  visitBlock: function(block){
    var len = block.nodes.length
, escape = this.escape
, pp = this.pp

    // Pretty print multi-line text
    if (pp &#x26;&#x26; len &#x3e; 1 &#x26;&#x26; !escape &#x26;&#x26; block.nodes[0].isText &#x26;&#x26; block.nodes[1].isText)
this.<span class="apidocCodeKeywordSpan">prettyIndent</span>(1, true);

    for (var i = 0; i &#x3c; len; ++i) {
// Pretty print text
if (pp &#x26;&#x26; i &#x3e; 0 &#x26;&#x26; !escape &#x26;&#x26; block.nodes[i].isText &#x26;&#x26; block.nodes[i-1].isText)
  this.prettyIndent(1, false);

this.visit(block.nodes[i]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.setDoctype" id="apidoc.element.jade.Compiler.prototype.setDoctype">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>setDoctype
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setDoctype = function (name){
  this.doctype = doctypes[name.toLowerCase()] || &#x27;&#x3c;!DOCTYPE &#x27; + name + &#x27;&#x3e;&#x27;;
  this.terse = this.doctype.toLowerCase() == &#x27;&#x3c;!doctype html&#x3e;&#x27;;
  this.xml = 0 == this.doctype.indexOf(&#x27;&#x3c;?xml&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  this.debug = false !== options.compileDebug;
  this.indents = 0;
  this.parentIndents = 0;
  this.terse = false;
  this.mixins = {};
  this.dynamicMixins = false;
  if (options.doctype) this.<span class="apidocCodeKeywordSpan">setDoctype</span>(options.doctype);
};

/**
 * Compiler prototype.
 */

Compiler.prototype = {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visit" id="apidoc.element.jade.Compiler.prototype.visit">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visit
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visit = function (node){
  var debug = this.debug;

  if (debug) {
    this.buf.push(&#x27;jade_debug.unshift(new jade.DebugItem( &#x27; + node.line
      + &#x27;, &#x27; + (node.filename
        ? utils.stringify(node.filename)
        : &#x27;jade_debug[0].filename&#x27;)
      + &#x27; ));&#x27;);
  }

  // Massive hack to fix our context
  // stack for - else[ if] etc
  if (false === node.debug &#x26;&#x26; this.debug) {
    this.buf.pop();
    this.buf.pop();
  }

  this.visitNode(node);

  if (debug) this.buf.push(&#x27;jade_debug.shift();&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @api public
 */

compile: function(){
  this.buf = [];
  if (this.pp) this.buf.push(&#x22;var jade_indent = [];&#x22;);
  this.lastBufferedIdx = -1;
  this.<span class="apidocCodeKeywordSpan">visit</span>(this.node);
  if (!this.dynamicMixins) {
    // if there are no dynamic mixins we can remove any un-used mixins
    var mixinNames = Object.keys(this.mixins);
    for (var i = 0; i &#x3c; mixinNames.length; i++) {
      var mixin = this.mixins[mixinNames[i]];
      if (!mixin.used) {
        for (var x = 0; x &#x3c; mixin.instances.length; x++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitAttributes" id="apidoc.element.jade.Compiler.prototype.visitAttributes">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitAttributes
        <span class="apidocSignatureSpan">(attrs, attributeBlocks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitAttributes = function (attrs, attributeBlocks){
  if (attributeBlocks.length) {
    if (attrs.length) {
      var val = this.attrs(attrs);
      attributeBlocks.unshift(val);
    }
    this.bufferExpression(&#x27;jade.attrs(jade.merge([&#x27; + attributeBlocks.join(&#x27;,&#x27;) + &#x27;]), &#x27; + utils.stringify(this.terse) + &#x27;)&#x27;);
  } else if (attrs.length) {
    this.attrs(attrs, true);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// pretty print
if (pp &#x26;&#x26; !tag.isInline())
  this.prettyIndent(0, true);

if (tag.selfClosing || (!this.xml &#x26;&#x26; selfClosing[tag.name])) {
  this.buffer(&#x27;&#x3c;&#x27;);
  bufferName();
  this.<span class="apidocCodeKeywordSpan">visitAttributes</span>(tag.attrs, tag.attributeBlocks.slice());
  this.terse
    ? this.buffer(&#x27;&#x3e;&#x27;)
    : this.buffer(&#x27;/&#x3e;&#x27;);
  // if it is non-empty throw an error
  if (tag.block &#x26;&#x26;
      !(tag.block.type === &#x27;Block&#x27; &#x26;&#x26; tag.block.nodes.length === 0) &#x26;&#x26;
      tag.block.nodes.some(function (tag) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitBlock" id="apidoc.element.jade.Compiler.prototype.visitBlock">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitBlock
        <span class="apidocSignatureSpan">(block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitBlock = function (block){
  var len = block.nodes.length
    , escape = this.escape
    , pp = this.pp

  // Pretty print multi-line text
  if (pp &#x26;&#x26; len &#x3e; 1 &#x26;&#x26; !escape &#x26;&#x26; block.nodes[0].isText &#x26;&#x26; block.nodes[1].isText)
    this.prettyIndent(1, true);

  for (var i = 0; i &#x3c; len; ++i) {
    // Pretty print text
    if (pp &#x26;&#x26; i &#x3e; 0 &#x26;&#x26; !escape &#x26;&#x26; block.nodes[i].isText &#x26;&#x26; block.nodes[i-1].isText)
      this.prettyIndent(1, false);

    this.visit(block.nodes[i]);
    // Multiple text nodes are separated by newlines
    if (block.nodes[i+1] &#x26;&#x26; block.nodes[i].isText &#x26;&#x26; block.nodes[i+1].isText)
      this.buffer(&#x27;\n&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitBlockComment" id="apidoc.element.jade.Compiler.prototype.visitBlockComment">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitBlockComment
        <span class="apidocSignatureSpan">(comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitBlockComment = function (comment){
  if (!comment.buffer) return;
  if (this.pp) this.prettyIndent(1, true);
  this.buffer(&#x27;&#x3c;!--&#x27; + comment.val);
  this.visit(comment.block);
  if (this.pp) this.prettyIndent(1, true);
  this.buffer(&#x27;--&#x3e;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitCase" id="apidoc.element.jade.Compiler.prototype.visitCase">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitCase
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitCase = function (node){
  var _ = this.withinCase;
  this.withinCase = true;
  this.buf.push(&#x27;switch (&#x27; + node.expr + &#x27;){&#x27;);
  this.visit(node.block);
  this.buf.push(&#x27;}&#x27;);
  this.withinCase = _;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitCode" id="apidoc.element.jade.Compiler.prototype.visitCode">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitCode
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitCode = function (code){
  // Wrap code blocks with {}.
  // we only wrap unbuffered code blocks ATM
  // since they are usually flow control

  // Buffer code
  if (code.buffer) {
    var val = code.val.trim();
    val = &#x27;null == (jade_interp = &#x27;+val+&#x27;) ? &#x22;&#x22; : jade_interp&#x27;;
    if (code.escape) val = &#x27;jade.escape(&#x27; + val + &#x27;)&#x27;;
    this.bufferExpression(val);
  } else {
    this.buf.push(code.val);
  }

  // Block support
  if (code.block) {
    if (!code.buffer) this.buf.push(&#x27;{&#x27;);
    this.visit(code.block);
    if (!code.buffer) this.buf.push(&#x27;}&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
    } else {
// Optimize attributes buffering
this.buffer(&#x27;&#x3c;&#x27;);
bufferName();
this.visitAttributes(tag.attrs, tag.attributeBlocks.slice());
this.buffer(&#x27;&#x3e;&#x27;);
if (tag.code) this.<span class="apidocCodeKeywordSpan">visitCode</span>(tag.code);
this.visit(tag.block);

// pretty print
if (pp &#x26;&#x26; !tag.isInline() &#x26;&#x26; &#x27;pre&#x27; != tag.name &#x26;&#x26; !tag.canInline())
  this.prettyIndent(0, true);

this.buffer(&#x27;&#x3c;/&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitComment" id="apidoc.element.jade.Compiler.prototype.visitComment">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitComment
        <span class="apidocSignatureSpan">(comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitComment = function (comment){
  if (!comment.buffer) return;
  if (this.pp) this.prettyIndent(1, true);
  this.buffer(&#x27;&#x3c;!--&#x27; + comment.val + &#x27;--&#x3e;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitDoctype" id="apidoc.element.jade.Compiler.prototype.visitDoctype">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitDoctype
        <span class="apidocSignatureSpan">(doctype)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitDoctype = function (doctype){
  if (doctype &#x26;&#x26; (doctype.val || !this.doctype)) {
    this.setDoctype(doctype.val || &#x27;default&#x27;);
  }

  if (this.doctype) this.buffer(this.doctype);
  this.hasCompiledDoctype = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  else self.buffer(name);
}

if (&#x27;pre&#x27; == tag.name) this.escape = true;

if (!this.hasCompiledTag) {
  if (!this.hasCompiledDoctype &#x26;&#x26; &#x27;html&#x27; == name) {
    this.<span class="apidocCodeKeywordSpan">visitDoctype</span>();
  }
  this.hasCompiledTag = true;
}

// pretty print
if (pp &#x26;&#x26; !tag.isInline())
  this.prettyIndent(0, true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitEach" id="apidoc.element.jade.Compiler.prototype.visitEach">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitEach
        <span class="apidocSignatureSpan">(each)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitEach = function (each){
  this.buf.push(&#x27;&#x27;
    + &#x27;// iterate &#x27; + each.obj + &#x27;\n&#x27;
    + &#x27;;(function(){\n&#x27;
    + &#x27;  var $$obj = &#x27; + each.obj + &#x27;;\n&#x27;
    + &#x27;  if (\&#x27;number\&#x27; == typeof $$obj.length) {\n&#x27;);

  if (each.alternative) {
    this.buf.push(&#x27;  if ($$obj.length) {&#x27;);
  }

  this.buf.push(&#x27;&#x27;
    + &#x27;    for (var &#x27; + each.key + &#x27; = 0, $$l = $$obj.length; &#x27; + each.key + &#x27; &#x3c; $$l; &#x27; + each.key + &#x27;++) {\n&#x27;
    + &#x27;      var &#x27; + each.val + &#x27; = $$obj[&#x27; + each.key + &#x27;];\n&#x27;);

  this.visit(each.block);

  this.buf.push(&#x27;    }\n&#x27;);

  if (each.alternative) {
    this.buf.push(&#x27;  } else {&#x27;);
    this.visit(each.alternative);
    this.buf.push(&#x27;  }&#x27;);
  }

  this.buf.push(&#x27;&#x27;
    + &#x27;  } else {\n&#x27;
    + &#x27;    var $$l = 0;\n&#x27;
    + &#x27;    for (var &#x27; + each.key + &#x27; in $$obj) {\n&#x27;
    + &#x27;      $$l++;&#x27;
    + &#x27;      var &#x27; + each.val + &#x27; = $$obj[&#x27; + each.key + &#x27;];\n&#x27;);

  this.visit(each.block);

  this.buf.push(&#x27;    }\n&#x27;);
  if (each.alternative) {
    this.buf.push(&#x27;    if ($$l === 0) {&#x27;);
    this.visit(each.alternative);
    this.buf.push(&#x27;    }&#x27;);
  }
  this.buf.push(&#x27;  }\n}).call(this);\n&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitFilter" id="apidoc.element.jade.Compiler.prototype.visitFilter">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitFilter
        <span class="apidocSignatureSpan">(filter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitFilter = function (filter){
  var text = filter.block.nodes.map(
    function(node){ return node.val; }
  ).join(&#x27;\n&#x27;);
  filter.attrs.filename = this.options.filename;
  try {
    this.buffer(filters(filter.name, text, filter.attrs), true);
  } catch (err) {
    throw errorAtNode(filter, err);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitLiteral" id="apidoc.element.jade.Compiler.prototype.visitLiteral">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitLiteral
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitLiteral = function (node){
  this.buffer(node.str);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitMixin" id="apidoc.element.jade.Compiler.prototype.visitMixin">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitMixin
        <span class="apidocSignatureSpan">(mixin)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitMixin = function (mixin){
  var name = &#x27;jade_mixins[&#x27;;
  var args = mixin.args || &#x27;&#x27;;
  var block = mixin.block;
  var attrs = mixin.attrs;
  var attrsBlocks = mixin.attributeBlocks.slice();
  var pp = this.pp;
  var dynamic = mixin.name[0]===&#x27;#&#x27;;
  var key = mixin.name;
  if (dynamic) this.dynamicMixins = true;
  name += (dynamic ? mixin.name.substr(2,mixin.name.length-3):&#x27;&#x22;&#x27;+mixin.name+&#x27;&#x22;&#x27;)+&#x27;]&#x27;;

  this.mixins[key] = this.mixins[key] || {used: false, instances: []};
  if (mixin.call) {
    this.mixins[key].used = true;
    if (pp) this.buf.push(&#x22;jade_indent.push(&#x27;&#x22; + Array(this.indents + 1).join(pp) + &#x22;&#x27;);&#x22;)
    if (block || attrs.length || attrsBlocks.length) {

      this.buf.push(name + &#x27;.call({&#x27;);

      if (block) {
        this.buf.push(&#x27;block: function(){&#x27;);

        // Render block with no indents, dynamically added when rendered
        this.parentIndents++;
        var _indents = this.indents;
        this.indents = 0;
        this.visit(mixin.block);
        this.indents = _indents;
        this.parentIndents--;

        if (attrs.length || attrsBlocks.length) {
          this.buf.push(&#x27;},&#x27;);
        } else {
          this.buf.push(&#x27;}&#x27;);
        }
      }

      if (attrsBlocks.length) {
        if (attrs.length) {
          var val = this.attrs(attrs);
          attrsBlocks.unshift(val);
        }
        this.buf.push(&#x27;attributes: jade.merge([&#x27; + attrsBlocks.join(&#x27;,&#x27;) + &#x27;])&#x27;);
      } else if (attrs.length) {
        var val = this.attrs(attrs);
        this.buf.push(&#x27;attributes: &#x27; + val);
      }

      if (args) {
        this.buf.push(&#x27;}, &#x27; + args + &#x27;);&#x27;);
      } else {
        this.buf.push(&#x27;});&#x27;);
      }

    } else {
      this.buf.push(name + &#x27;(&#x27; + args + &#x27;);&#x27;);
    }
    if (pp) this.buf.push(&#x22;jade_indent.pop();&#x22;)
  } else {
    var mixin_start = this.buf.length;
    args = args ? args.split(&#x27;,&#x27;) : [];
    var rest;
    if (args.length &#x26;&#x26; /^\.\.\./.test(args[args.length - 1].trim())) {
      rest = args.pop().trim().replace(/^\.\.\./, &#x27;&#x27;);
    }
    // we need use jade_interp here for v8: https://code.google.com/p/v8/issues/detail?id=4165
    // once fixed, use this: this.buf.push(name + &#x27; = function(&#x27; + args.join(&#x27;,&#x27;) + &#x27;){&#x27;);
    this.buf.push(name + &#x27; = jade_interp = function(&#x27; + args.join(&#x27;,&#x27;) + &#x27;){&#x27;);
    this.buf.push(&#x27;var block = (this &#x26;&#x26; this.block), attributes = (this &#x26;&#x26; this.attributes) || {};&#x27;);
    if (rest) {
      this.buf.push(&#x27;var &#x27; + rest + &#x27; = [];&#x27;);
      this.buf.push(&#x27;for (jade_interp = &#x27; + args.length + &#x27;; jade_interp &#x3c; arguments.length; jade_interp++) {&#x27;);
      this.buf.push(&#x27;  &#x27; + rest + &#x27;.push(arguments[jade_interp]);&#x27;);
      this.buf.push(&#x27;}&#x27;);
    }
    this.parentIndents++;
    this.visit(block);
    this.parentIndents--;
    this.buf.push(&#x27;};&#x27;);
    var mixin_end = this.buf.length;
    this.mixins[key].instances.push({start: mixin_start, end: mixin_end});
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitMixinBlock" id="apidoc.element.jade.Compiler.prototype.visitMixinBlock">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitMixinBlock
        <span class="apidocSignatureSpan">(block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitMixinBlock = function (block){
  if (this.pp) this.buf.push(&#x22;jade_indent.push(&#x27;&#x22; + Array(this.indents + 1).join(this.pp) + &#x22;&#x27;);&#x22;);
  this.buf.push(&#x27;block &#x26;&#x26; block();&#x27;);
  if (this.pp) this.buf.push(&#x22;jade_indent.pop();&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitNode" id="apidoc.element.jade.Compiler.prototype.visitNode">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitNode = function (node){
  return this[&#x27;visit&#x27; + node.type](node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Massive hack to fix our context
  // stack for - else[ if] etc
  if (false === node.debug &#x26;&#x26; this.debug) {
    this.buf.pop();
    this.buf.pop();
  }

  this.<span class="apidocCodeKeywordSpan">visitNode</span>(node);

  if (debug) this.buf.push(&#x27;jade_debug.shift();&#x27;);
},

/**
 * Visit `node`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitTag" id="apidoc.element.jade.Compiler.prototype.visitTag">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitTag
        <span class="apidocSignatureSpan">(tag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitTag = function (tag){
  this.indents++;
  var name = tag.name
    , pp = this.pp
    , self = this;

  function bufferName() {
    if (tag.buffer) self.bufferExpression(name);
    else self.buffer(name);
  }

  if (&#x27;pre&#x27; == tag.name) this.escape = true;

  if (!this.hasCompiledTag) {
    if (!this.hasCompiledDoctype &#x26;&#x26; &#x27;html&#x27; == name) {
      this.visitDoctype();
    }
    this.hasCompiledTag = true;
  }

  // pretty print
  if (pp &#x26;&#x26; !tag.isInline())
    this.prettyIndent(0, true);

  if (tag.selfClosing || (!this.xml &#x26;&#x26; selfClosing[tag.name])) {
    this.buffer(&#x27;&#x3c;&#x27;);
    bufferName();
    this.visitAttributes(tag.attrs, tag.attributeBlocks.slice());
    this.terse
      ? this.buffer(&#x27;&#x3e;&#x27;)
      : this.buffer(&#x27;/&#x3e;&#x27;);
    // if it is non-empty throw an error
    if (tag.block &#x26;&#x26;
        !(tag.block.type === &#x27;Block&#x27; &#x26;&#x26; tag.block.nodes.length === 0) &#x26;&#x26;
        tag.block.nodes.some(function (tag) {
          return tag.type !== &#x27;Text&#x27; || !/^\s*$/.test(tag.val)
        })) {
      throw errorAtNode(tag, new Error(name + &#x27; is self closing and should not have content.&#x27;));
    }
  } else {
    // Optimize attributes buffering
    this.buffer(&#x27;&#x3c;&#x27;);
    bufferName();
    this.visitAttributes(tag.attrs, tag.attributeBlocks.slice());
    this.buffer(&#x27;&#x3e;&#x27;);
    if (tag.code) this.visitCode(tag.code);
    this.visit(tag.block);

    // pretty print
    if (pp &#x26;&#x26; !tag.isInline() &#x26;&#x26; &#x27;pre&#x27; != tag.name &#x26;&#x26; !tag.canInline())
      this.prettyIndent(0, true);

    this.buffer(&#x27;&#x3c;/&#x27;);
    bufferName();
    this.buffer(&#x27;&#x3e;&#x27;);
  }

  if (&#x27;pre&#x27; == tag.name) this.escape = false;

  this.indents--;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitText" id="apidoc.element.jade.Compiler.prototype.visitText">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitText
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitText = function (text){
  this.buffer(text.val, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Compiler.prototype.visitWhen" id="apidoc.element.jade.Compiler.prototype.visitWhen">
        function <span class="apidocSignatureSpan">jade.Compiler.prototype.</span>visitWhen
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitWhen = function (node){
  if (&#x27;default&#x27; == node.expr) {
    this.buf.push(&#x27;default:&#x27;);
  } else {
    this.buf.push(&#x27;case &#x27; + node.expr + &#x27;:&#x27;);
  }
  if (node.block) {
    this.visit(node.block);
    this.buf.push(&#x27;  break;&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.Lexer" id="apidoc.module.jade.Lexer">module jade.Lexer</a></h1>


    <h2>
        <a href="#apidoc.element.jade.Lexer.Lexer" id="apidoc.element.jade.Lexer.Lexer">
        function <span class="apidocSignatureSpan">jade.</span>Lexer
        <span class="apidocSignatureSpan">(str, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Lexer(str, filename) {
  this.input = str.replace(/\r\n|\r/g, &#x27;\n&#x27;);
  this.filename = filename;
  this.deferredTokens = [];
  this.lastIndents = 0;
  this.lineno = 1;
  this.stash = [];
  this.indentStack = [];
  this.indentRe = null;
  this.pipeless = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.Lexer.prototype" id="apidoc.module.jade.Lexer.prototype">module jade.Lexer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.advance" id="apidoc.element.jade.Lexer.prototype.advance">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>advance
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">advance = function (){
  return this.stashed()
    || this.next();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Return the next token object.
 *
 * @return {Object}
 * @api private
 */

advance: function(){
  return this.lexer.<span class="apidocCodeKeywordSpan">advance</span>();
},

/**
 * Single token lookahead.
 *
 * @return {Object}
 * @api private
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.append" id="apidoc.element.jade.Lexer.prototype.append">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>append
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">append = function () {
  var captures;
  if (captures = /^append +([^\n]+)/.exec(this.input)) {
    this.consume(captures[0].length);
    var mode = &#x27;append&#x27;
      , name = captures[1]
      , tok = this.tok(&#x27;block&#x27;, name);
    tok.mode = mode;
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.yield()
|| this.doctype()
|| this.interpolation()
|| this[&#x22;case&#x22;]()
|| this.when()
|| this[&#x22;default&#x22;]()
|| this[&#x22;extends&#x22;]()
|| this.<span class="apidocCodeKeywordSpan">append</span>()
|| this.prepend()
|| this.block()
|| this.mixinBlock()
|| this.include()
|| this.includeFiltered()
|| this.mixin()
|| this.call()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.attributesBlock" id="apidoc.element.jade.Lexer.prototype.attributesBlock">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>attributesBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attributesBlock = function () {
  var captures;
  if (/^&#x26;attributes\b/.test(this.input)) {
    this.consume(11);
    var args = this.bracketExpression();
    this.consume(args.end + 1);
    return this.tok(&#x27;&#x26;attributes&#x27;, args.src);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.tag()
|| this.filter()
|| this.blockCode()
|| this.code()
|| this.id()
|| this.className()
|| this.attrs()
|| this.<span class="apidocCodeKeywordSpan">attributesBlock</span>()
|| this.indent()
|| this.text()
|| this.comment()
|| this.colon()
|| this.dot()
|| this.textFail()
|| this.fail();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.attrs" id="apidoc.element.jade.Lexer.prototype.attrs">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>attrs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attrs = function () {
  if (&#x27;(&#x27; == this.input.charAt(0)) {
    var index = this.bracketExpression().end
      , str = this.input.substr(1, index-1)
      , tok = this.tok(&#x27;attrs&#x27;);

    assertNestingCorrect(str);

    var quote = &#x27;&#x27;;
    var interpolate = function (attr) {
      return attr.replace(/(\\)?#\{(.+)/g, function(_, escape, expr){
        if (escape) return _;
        try {
          var range = characterParser.parseMax(expr);
          if (expr[range.end] !== &#x27;}&#x27;) return _.substr(0, 2) + interpolate(_.substr(2));
          assertExpression(range.src)
          return quote + &#x22; + (&#x22; + range.src + &#x22;) + &#x22; + quote + interpolate(expr.substr(range.end + 1));
        } catch (ex) {
          return _.substr(0, 2) + interpolate(_.substr(2));
        }
      });
    }

    this.consume(index + 1);
    tok.attrs = [];

    var escapedAttr = true
    var key = &#x27;&#x27;;
    var val = &#x27;&#x27;;
    var interpolatable = &#x27;&#x27;;
    var state = characterParser.defaultState();
    var loc = &#x27;key&#x27;;
    var isEndOfAttribute = function (i) {
      if (key.trim() === &#x27;&#x27;) return false;
      if (i === str.length) return true;
      if (loc === &#x27;key&#x27;) {
        if (str[i] === &#x27; &#x27; || str[i] === &#x27;\n&#x27;) {
          for (var x = i; x &#x3c; str.length; x++) {
            if (str[x] != &#x27; &#x27; &#x26;&#x26; str[x] != &#x27;\n&#x27;) {
              if (str[x] === &#x27;=&#x27; || str[x] === &#x27;!&#x27; || str[x] === &#x27;,&#x27;) return false;
              else return true;
            }
          }
        }
        return str[i] === &#x27;,&#x27;
      } else if (loc === &#x27;value&#x27; &#x26;&#x26; !state.isNesting()) {
        try {
          assertExpression(val);
          if (str[i] === &#x27; &#x27; || str[i] === &#x27;\n&#x27;) {
            for (var x = i; x &#x3c; str.length; x++) {
              if (str[x] != &#x27; &#x27; &#x26;&#x26; str[x] != &#x27;\n&#x27;) {
                if (characterParser.isPunctuator(str[x]) &#x26;&#x26; str[x] != &#x27;&#x22;&#x27; &#x26;&#x26; str[x] != &#x22;&#x27;&#x22;) return false;
                else return true;
              }
            }
          }
          return str[i] === &#x27;,&#x27;;
        } catch (ex) {
          return false;
        }
      }
    }

    this.lineno += str.split(&#x22;\n&#x22;).length - 1;

    for (var i = 0; i &#x3c;= str.length; i++) {
      if (isEndOfAttribute(i)) {
        val = val.trim();
        if (val) assertExpression(val)
        key = key.trim();
        key = key.replace(/^[&#x27;&#x22;]|[&#x27;&#x22;]$/g, &#x27;&#x27;);
        tok.attrs.push({
          name: key,
          val: &#x27;&#x27; == val ? true : val,
          escaped: escapedAttr
        });
        key = val = &#x27;&#x27;;
        loc = &#x27;key&#x27;;
        escapedAttr = false;
      } else {
        switch (loc) {
          case &#x27;key-char&#x27;:
            if (str[i] === quote) {
              loc = &#x27;key&#x27;;
              if (i + 1 &#x3c; str.length &#x26;&#x26; [&#x27; &#x27;, &#x27;,&#x27;, &#x27;!&#x27;, &#x27;=&#x27;, &#x27;\n&#x27;].indexOf(str[i + 1]) === -1)
                throw new Error(&#x27;Unexpected character &#x27; + str[i + 1] + &#x27; expected ` `, `\\n`, `,`, `!` or `=`&#x27;);
            } else {
              key += str[i];
            }
            break;
          case &#x27;key&#x27;:
            if (key === &#x27;&#x27; &#x26;&#x26; (str[i] === &#x27;&#x22;&#x27; || str[i] === &#x22;&#x27;&#x22;)) {
              loc = &#x27;key-char&#x27;;
              quote = str[i];
            } else if (str[i] === &#x27;!&#x27; || str[i] === &#x27;=&#x27;) {
              escapedAttr = str[i] !== &#x27;!&#x27;;
              if (str[i] === &#x27;!&#x27;) i++;
              if (str[i] !== &#x27;=&#x27;) throw new Error(&#x27;Unexpected character &#x27; + str[i] + &#x27; expected `=`&#x27;);
              loc = &#x27;value&#x27;;
              state = characterParser.defaultState();
            } else {
              key += str[i]
            }
            break;
          case &#x27;value&#x27;:
            state = characterParser.parseChar(str[i], state);
            if (state.isString()) {
              loc = &#x27;string&#x27;;
              quote = str[i];
              interpolatable = str[i];
            } else {
              val += str[i];
            }
            break;
          case &#x27;string&#x27;:
            state = characterParser.parseChar(str[i], state);
            interpolatable += str[i];
            if (!state.isString()) {
              loc = &#x27;value&#x27;;
              val += interpolate(interpolatable);
            }
            break;
        }
      }
    }

    if (&#x27;/&#x27; == this.input.char ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    this.buf.push(&#x27;}&#x27;);
  }
}

if (attrsBlocks.length) {
  if (attrs.length) {
    var val = this.<span class="apidocCodeKeywordSpan">attrs</span>(attrs);
    attrsBlocks.unshift(val);
  }
  this.buf.push(&#x27;attributes: jade.merge([&#x27; + attrsBlocks.join(&#x27;,&#x27;) + &#x27;])&#x27;);
} else if (attrs.length) {
  var val = this.attrs(attrs);
  this.buf.push(&#x27;attributes: &#x27; + val);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.blank" id="apidoc.element.jade.Lexer.prototype.blank">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>blank
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">blank = function () {
  var captures;
  if (captures = /^\n *\n/.exec(this.input)) {
    this.consume(captures[0].length - 1);
    ++this.lineno;
    if (this.pipeless) return this.tok(&#x27;text&#x27;, &#x27;&#x27;);
    return this.next();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @return {Object}
 * @api private
 */

next: function() {
  return this.deferred()
    || this.<span class="apidocCodeKeywordSpan">blank</span>()
    || this.eos()
    || this.pipelessText()
    || this.yield()
    || this.doctype()
    || this.interpolation()
    || this[&#x22;case&#x22;]()
    || this.when()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.block" id="apidoc.element.jade.Lexer.prototype.block">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>block
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block = function () {
  var captures;
  if (captures = /^block\b *(?:(prepend|append) +)?([^\n]+)/.exec(this.input)) {
    this.consume(captures[0].length);
    var mode = captures[1] || &#x27;replace&#x27;
      , name = captures[2]
      , tok = this.tok(&#x27;block&#x27;, name);

    tok.mode = mode;
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.interpolation()
|| this[&#x22;case&#x22;]()
|| this.when()
|| this[&#x22;default&#x22;]()
|| this[&#x22;extends&#x22;]()
|| this.append()
|| this.prepend()
|| this.<span class="apidocCodeKeywordSpan">block</span>()
|| this.mixinBlock()
|| this.include()
|| this.includeFiltered()
|| this.mixin()
|| this.call()
|| this.conditional()
|| this.each()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.blockCode" id="apidoc.element.jade.Lexer.prototype.blockCode">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>blockCode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">blockCode = function () {
  var captures;
  if (captures = /^-\n/.exec(this.input)) {
    this.consume(captures[0].length - 1);
    var tok = this.tok(&#x27;blockCode&#x27;);
    this.pipeless = true;
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.mixin()
|| this.call()
|| this.conditional()
|| this.each()
|| this[&#x22;while&#x22;]()
|| this.tag()
|| this.filter()
|| this.<span class="apidocCodeKeywordSpan">blockCode</span>()
|| this.code()
|| this.id()
|| this.className()
|| this.attrs()
|| this.attributesBlock()
|| this.indent()
|| this.text()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.bracketExpression" id="apidoc.element.jade.Lexer.prototype.bracketExpression">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>bracketExpression
        <span class="apidocSignatureSpan">(skip)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bracketExpression = function (skip){
  skip = skip || 0;
  var start = this.input[skip];
  if (start != &#x27;(&#x27; &#x26;&#x26; start != &#x27;{&#x27; &#x26;&#x26; start != &#x27;[&#x27;) throw new Error(&#x27;unrecognized start character&#x27;);
  var end = ({&#x27;(&#x27;: &#x27;)&#x27;, &#x27;{&#x27;: &#x27;}&#x27;, &#x27;[&#x27;: &#x27;]&#x27;})[start];
  var range = characterParser.parseMax(this.input, {start: skip + 1});
  if (this.input[range.end] !== end) throw new Error(&#x27;start character &#x27; + start + &#x27; does not match end character &#x27; + this.input[
range.end]);
  return range;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Interpolated tag.
 */

interpolation: function() {
  if (/^#\{/.test(this.input)) {
    var match = this.<span class="apidocCodeKeywordSpan">bracketExpression</span>(1);

    this.consume(match.end + 1);
    return this.tok(&#x27;interpolation&#x27;, match.src);
  }
},

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.call" id="apidoc.element.jade.Lexer.prototype.call">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>call
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">call = function (){

  var tok, captures;
  if (captures = /^\+(\s*)(([-\w]+)|(#\{))/.exec(this.input)) {
    // try to consume simple or interpolated call
    if (captures[3]) {
      // simple call
      this.consume(captures[0].length);
      tok = this.tok(&#x27;call&#x27;, captures[3]);
    } else {
      // interpolated call
      var match = this.bracketExpression(2 + captures[1].length);
      this.consume(match.end + 1);
      assertExpression(match.src);
      tok = this.tok(&#x27;call&#x27;, &#x27;#{&#x27;+match.src+&#x27;}&#x27;);
    }

    // Check for args (not attributes)
    if (captures = /^ *\(/.exec(this.input)) {
      var range = this.bracketExpression(captures[0].length - 1);
      if (!/^\s*[-\w]+ *=/.test(range.src)) { // not attributes
        this.consume(range.end + 1);
        tok.args = range.src;
      }
      if (tok.args) {
        assertExpression(&#x27;[&#x27; + tok.args + &#x27;]&#x27;);
      }
    }

    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...







(function(f){if(typeof exports===&#x22;object&#x22;&#x26;&#x26;typeof module!==&#x22;undefined&#x22;){module.exports=f()}else if
(typeof define===&#x22;function&#x22;&#x26;&#x26;define.amd){define([],f)}else{var g;if(typeof window!==&#x22;undefined&#x22;){g
=window}else if(typeof global!==&#x22;undefined&#x22;){g=global}else if(typeof self!==&#x22;undefined&#x22;){g=self}else{g=this}
g.jade = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof
require==&#x22;function&#x22;&#x26;&#x26;require;if(!u&#x26;&#x26;a)return a(o,!0);if(i)return i(o,!0);var f=new Error(&#x22;Cannot
 find module &#x27;&#x22;+o+&#x22;&#x27;&#x22;);throw f.code=&#x22;MODULE_NOT_FOUND&#x22;,f}var l=n[o]={exports:{}};t[o][0].<span
 class="apidocCodeKeywordSpan">call</span>(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n
[o].exports}var i=typeof require==&#x22;function&#x22;&#x26;&#x26;require;for(var o=0;o&#x3c;r.length;o++)s(r[o]);return s})({1:[
function(require,module,exports){
(function (process){
&#x27;use strict&#x27;;

/*!
* Jade
* Copyright(c) 2010 TJ Holowaychuk &#x3c;tj@vision-media.ca&#x3e;
* MIT Licensed
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.case" id="apidoc.element.jade.Lexer.prototype.case">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>case
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">case = function () {
  return this.scan(/^case +([^\n]+)/, &#x27;case&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.className" id="apidoc.element.jade.Lexer.prototype.className">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>className
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">className = function () {
  return this.scan(/^\.([\w-]+)/, &#x27;class&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.each()
|| this[&#x22;while&#x22;]()
|| this.tag()
|| this.filter()
|| this.blockCode()
|| this.code()
|| this.id()
|| this.<span class="apidocCodeKeywordSpan">className</span>()
|| this.attrs()
|| this.attributesBlock()
|| this.indent()
|| this.text()
|| this.comment()
|| this.colon()
|| this.dot()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.code" id="apidoc.element.jade.Lexer.prototype.code">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>code
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">code = function () {
  var captures;
  if (captures = /^(!?=|-)[ \t]*([^\n]+)/.exec(this.input)) {
    this.consume(captures[0].length);
    var flags = captures[1];
    captures[1] = captures[2];
    var tok = this.tok(&#x27;code&#x27;, captures[1]);
    tok.escape = flags.charAt(0) === &#x27;=&#x27;;
    tok.buffer = flags.charAt(0) === &#x27;=&#x27; || flags.charAt(1) === &#x27;=&#x27;;
    if (tok.buffer) assertExpression(captures[1])
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.call()
|| this.conditional()
|| this.each()
|| this[&#x22;while&#x22;]()
|| this.tag()
|| this.filter()
|| this.blockCode()
|| this.<span class="apidocCodeKeywordSpan">code</span>()
|| this.id()
|| this.className()
|| this.attrs()
|| this.attributesBlock()
|| this.indent()
|| this.text()
|| this.comment()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.colon" id="apidoc.element.jade.Lexer.prototype.colon">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>colon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">colon = function () {
  var good = /^: +/.test(this.input);
  var res = this.scan(/^: */, &#x27;:&#x27;);
  if (res &#x26;&#x26; !good) {
    console.warn(&#x27;Warning: space required after `:` on line &#x27; + this.lineno +
        &#x27; of jade file &#x22;&#x27; + this.filename + &#x27;&#x22;&#x27;);
  }
  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      || this.id()
      || this.className()
      || this.attrs()
      || this.attributesBlock()
      || this.indent()
      || this.text()
      || this.comment()
      || this.<span class="apidocCodeKeywordSpan">colon</span>()
      || this.dot()
      || this.textFail()
      || this.fail();
  }
};

},{&#x22;./utils&#x22;:25,&#x22;character-parser&#x22;:29}],7:[function(require,module,exports){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.comment" id="apidoc.element.jade.Lexer.prototype.comment">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>comment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comment = function () {
  var captures;
  if (captures = /^\/\/(-)?([^\n]*)/.exec(this.input)) {
    this.consume(captures[0].length);
    var tok = this.tok(&#x27;comment&#x27;, captures[2]);
    tok.buffer = &#x27;-&#x27; != captures[1];
    this.pipeless = true;
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      || this.code()
      || this.id()
      || this.className()
      || this.attrs()
      || this.attributesBlock()
      || this.indent()
      || this.text()
      || this.<span class="apidocCodeKeywordSpan">comment</span>()
      || this.colon()
      || this.dot()
      || this.textFail()
      || this.fail();
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.conditional" id="apidoc.element.jade.Lexer.prototype.conditional">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>conditional
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">conditional = function () {
  var captures;
  if (captures = /^(if|unless|else if|else)\b([^\n]*)/.exec(this.input)) {
    this.consume(captures[0].length);
    var type = captures[1]
    var js = captures[2];
    var isIf = false;
    var isElse = false;

    switch (type) {
      case &#x27;if&#x27;:
        assertExpression(js)
        js = &#x27;if (&#x27; + js + &#x27;)&#x27;;
        isIf = true;
        break;
      case &#x27;unless&#x27;:
        assertExpression(js)
        js = &#x27;if (!(&#x27; + js + &#x27;))&#x27;;
        isIf = true;
        break;
      case &#x27;else if&#x27;:
        assertExpression(js)
        js = &#x27;else if (&#x27; + js + &#x27;)&#x27;;
        isIf = true;
        isElse = true;
        break;
      case &#x27;else&#x27;:
        if (js &#x26;&#x26; js.trim()) {
          throw new Error(&#x27;`else` cannot have a condition, perhaps you meant `else if`&#x27;);
        }
        js = &#x27;else&#x27;;
        isElse = true;
        break;
    }
    var tok = this.tok(&#x27;code&#x27;, js);
    tok.isElse = isElse;
    tok.isIf = isIf;
    tok.requiresBlock = true;
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.prepend()
|| this.block()
|| this.mixinBlock()
|| this.include()
|| this.includeFiltered()
|| this.mixin()
|| this.call()
|| this.<span class="apidocCodeKeywordSpan">conditional</span>()
|| this.each()
|| this[&#x22;while&#x22;]()
|| this.tag()
|| this.filter()
|| this.blockCode()
|| this.code()
|| this.id()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.consume" id="apidoc.element.jade.Lexer.prototype.consume">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>consume
        <span class="apidocSignatureSpan">(len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">consume = function (len){
  this.input = this.input.substr(len);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {Object}
 * @api private
 */

scan: function(regexp, type){
  var captures;
  if (captures = regexp.exec(this.input)) {
    this.<span class="apidocCodeKeywordSpan">consume</span>(captures[0].length);
    return this.tok(type, captures[1]);
  }
},

/**
 * Defer the given `tok`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.default" id="apidoc.element.jade.Lexer.prototype.default">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>default
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">default = function () {
  return this.scan(/^default */, &#x27;default&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.defer" id="apidoc.element.jade.Lexer.prototype.defer">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>defer
        <span class="apidocSignatureSpan">(tok)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defer = function (tok){
  this.deferredTokens.push(tok);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var captures;
if (captures = /^(\w[-:\w]*)(\/?)/.exec(this.input)) {
  this.consume(captures[0].length);
  var tok, name = captures[1];
  if (&#x27;:&#x27; == name[name.length - 1]) {
    name = name.slice(0, -1);
    tok = this.tok(&#x27;tag&#x27;, name);
    this.<span class="apidocCodeKeywordSpan">defer</span>(this.tok(&#x27;:&#x27;));
    if (this.input[0] !== &#x27; &#x27;) {
      console.warn(&#x27;Warning: space required after `:` on line &#x27; + this.lineno +
          &#x27; of jade file &#x22;&#x27; + this.filename + &#x27;&#x22;&#x27;);
    }
    while (&#x27; &#x27; == this.input[0]) this.input = this.input.substr(1);
  } else {
    tok = this.tok(&#x27;tag&#x27;, name);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.deferred" id="apidoc.element.jade.Lexer.prototype.deferred">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>deferred
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deferred = function () {
  return this.deferredTokens.length
    &#x26;&#x26; this.deferredTokens.shift();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Return the next token object.
 *
 * @return {Object}
 * @api private
 */

next: function() {
  return this.<span class="apidocCodeKeywordSpan">deferred</span>()
    || this.blank()
    || this.eos()
    || this.pipelessText()
    || this.yield()
    || this.doctype()
    || this.interpolation()
    || this[&#x22;case&#x22;]()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.doctype" id="apidoc.element.jade.Lexer.prototype.doctype">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>doctype
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doctype = function () {
  if (this.scan(/^!!! *([^\n]+)?/, &#x27;doctype&#x27;)) {
    throw new Error(&#x27;`!!!` is deprecated, you must now use `doctype`&#x27;);
  }
  var node = this.scan(/^(?:doctype) *([^\n]+)?/, &#x27;doctype&#x27;);
  if (node &#x26;&#x26; node.val &#x26;&#x26; node.val.trim() === &#x27;5&#x27;) {
    throw new Error(&#x27;`doctype 5` is deprecated, you must now use `doctype html`&#x27;);
  }
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  next: function() {
return this.deferred()
  || this.blank()
  || this.eos()
  || this.pipelessText()
  || this.yield()
  || this.<span class="apidocCodeKeywordSpan">doctype</span>()
  || this.interpolation()
  || this[&#x22;case&#x22;]()
  || this.when()
  || this[&#x22;default&#x22;]()
  || this[&#x22;extends&#x22;]()
  || this.append()
  || this.prepend()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.dot" id="apidoc.element.jade.Lexer.prototype.dot">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>dot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dot = function () {
  var match;
  if (match = this.scan(/^\./, &#x27;dot&#x27;)) {
    this.pipeless = true;
    return match;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      || this.className()
      || this.attrs()
      || this.attributesBlock()
      || this.indent()
      || this.text()
      || this.comment()
      || this.colon()
      || this.<span class="apidocCodeKeywordSpan">dot</span>()
      || this.textFail()
      || this.fail();
  }
};

},{&#x22;./utils&#x22;:25,&#x22;character-parser&#x22;:29}],7:[function(require,module,exports){
&#x27;use strict&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.each" id="apidoc.element.jade.Lexer.prototype.each">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>each
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">each = function () {
  var captures;
  if (captures = /^(?:- *)?(?:each|for) +([a-zA-Z_$][\w$]*)(?: *, *([a-zA-Z_$][\w$]*))? * in *([^\n]+)/.exec(this.input)) {
    this.consume(captures[0].length);
    var tok = this.tok(&#x27;each&#x27;, captures[1]);
    tok.key = captures[2] || &#x27;$index&#x27;;
    assertExpression(captures[3])
    tok.code = captures[3];
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.block()
|| this.mixinBlock()
|| this.include()
|| this.includeFiltered()
|| this.mixin()
|| this.call()
|| this.conditional()
|| this.<span class="apidocCodeKeywordSpan">each</span>()
|| this[&#x22;while&#x22;]()
|| this.tag()
|| this.filter()
|| this.blockCode()
|| this.code()
|| this.id()
|| this.className()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.eos" id="apidoc.element.jade.Lexer.prototype.eos">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>eos
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eos = function () {
  if (this.input.length) return;
  if (this.indentStack.length) {
    this.indentStack.shift();
    return this.tok(&#x27;outdent&#x27;);
  } else {
    return this.tok(&#x27;eos&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {Object}
 * @api private
 */

next: function() {
  return this.deferred()
    || this.blank()
    || this.<span class="apidocCodeKeywordSpan">eos</span>()
    || this.pipelessText()
    || this.yield()
    || this.doctype()
    || this.interpolation()
    || this[&#x22;case&#x22;]()
    || this.when()
    || this[&#x22;default&#x22;]()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.extends" id="apidoc.element.jade.Lexer.prototype.extends">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>extends
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extends = function () {
  return this.scan(/^extends? +([^\n]+)/, &#x27;extends&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.fail" id="apidoc.element.jade.Lexer.prototype.fail">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>fail
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fail = function () {
  throw new Error(&#x27;unexpected text &#x27; + this.input.substr(0, 5));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      || this.attributesBlock()
      || this.indent()
      || this.text()
      || this.comment()
      || this.colon()
      || this.dot()
      || this.textFail()
      || this.<span class="apidocCodeKeywordSpan">fail</span>();
  }
};

},{&#x22;./utils&#x22;:25,&#x22;character-parser&#x22;:29}],7:[function(require,module,exports){
&#x27;use strict&#x27;;

var Node = require(&#x27;./node&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.filter" id="apidoc.element.jade.Lexer.prototype.filter">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>filter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function () {
  var tok = this.scan(/^:([\w\-]+)/, &#x27;filter&#x27;);
  if (tok) {
    this.pipeless = true;
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.includeFiltered()
|| this.mixin()
|| this.call()
|| this.conditional()
|| this.each()
|| this[&#x22;while&#x22;]()
|| this.tag()
|| this.<span class="apidocCodeKeywordSpan">filter</span>()
|| this.blockCode()
|| this.code()
|| this.id()
|| this.className()
|| this.attrs()
|| this.attributesBlock()
|| this.indent()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.id" id="apidoc.element.jade.Lexer.prototype.id">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>id
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">id = function () {
  return this.scan(/^#([\w-]+)/, &#x27;id&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.conditional()
|| this.each()
|| this[&#x22;while&#x22;]()
|| this.tag()
|| this.filter()
|| this.blockCode()
|| this.code()
|| this.<span class="apidocCodeKeywordSpan">id</span>()
|| this.className()
|| this.attrs()
|| this.attributesBlock()
|| this.indent()
|| this.text()
|| this.comment()
|| this.colon()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.include" id="apidoc.element.jade.Lexer.prototype.include">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>include
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">include = function () {
  return this.scan(/^include +([^\n]+)/, &#x27;include&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.when()
|| this[&#x22;default&#x22;]()
|| this[&#x22;extends&#x22;]()
|| this.append()
|| this.prepend()
|| this.block()
|| this.mixinBlock()
|| this.<span class="apidocCodeKeywordSpan">include</span>()
|| this.includeFiltered()
|| this.mixin()
|| this.call()
|| this.conditional()
|| this.each()
|| this[&#x22;while&#x22;]()
|| this.tag()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.includeFiltered" id="apidoc.element.jade.Lexer.prototype.includeFiltered">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>includeFiltered
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">includeFiltered = function () {
  var captures;
  if (captures = /^include:([\w\-]+)([\( ])/.exec(this.input)) {
    this.consume(captures[0].length - 1);
    var filter = captures[1];
    var attrs = captures[2] === &#x27;(&#x27; ? this.attrs() : null;
    if (!(captures[2] === &#x27; &#x27; || this.input[0] === &#x27; &#x27;)) {
      throw new Error(&#x27;expected space after include:filter but got &#x27; + utils.stringify(this.input[0]));
    }
    captures = /^ *([^\n]+)/.exec(this.input);
    if (!captures || captures[1].trim() === &#x27;&#x27;) {
      throw new Error(&#x27;missing path for include:filter&#x27;);
    }
    this.consume(captures[0].length);
    var path = captures[1];
    var tok = this.tok(&#x27;include&#x27;, path);
    tok.filter = filter;
    tok.attrs = attrs;
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this[&#x22;default&#x22;]()
|| this[&#x22;extends&#x22;]()
|| this.append()
|| this.prepend()
|| this.block()
|| this.mixinBlock()
|| this.include()
|| this.<span class="apidocCodeKeywordSpan">includeFiltered</span>()
|| this.mixin()
|| this.call()
|| this.conditional()
|| this.each()
|| this[&#x22;while&#x22;]()
|| this.tag()
|| this.filter()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.indent" id="apidoc.element.jade.Lexer.prototype.indent">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>indent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indent = function () {
  var captures, re;

  // established regexp
  if (this.indentRe) {
    captures = this.indentRe.exec(this.input);
  // determine regexp
  } else {
    // tabs
    re = /^\n(\t*) */;
    captures = re.exec(this.input);

    // spaces
    if (captures &#x26;&#x26; !captures[1].length) {
      re = /^\n( *)/;
      captures = re.exec(this.input);
    }

    // established
    if (captures &#x26;&#x26; captures[1].length) this.indentRe = re;
  }

  if (captures) {
    var tok
      , indents = captures[1].length;

    ++this.lineno;
    this.consume(indents + 1);

    if (&#x27; &#x27; == this.input[0] || &#x27;\t&#x27; == this.input[0]) {
      throw new Error(&#x27;Invalid indentation, you can use tabs or spaces but not both&#x27;);
    }

    // blank line
    if (&#x27;\n&#x27; == this.input[0]) {
      this.pipeless = false;
      return this.tok(&#x27;newline&#x27;);
    }

    // outdent
    if (this.indentStack.length &#x26;&#x26; indents &#x3c; this.indentStack[0]) {
      while (this.indentStack.length &#x26;&#x26; this.indentStack[0] &#x3e; indents) {
        this.stash.push(this.tok(&#x27;outdent&#x27;));
        this.indentStack.shift();
      }
      tok = this.stash.pop();
    // indent
    } else if (indents &#x26;&#x26; indents != this.indentStack[0]) {
      this.indentStack.unshift(indents);
      tok = this.tok(&#x27;indent&#x27;, indents);
    // newline
    } else {
      tok = this.tok(&#x27;newline&#x27;);
    }

    this.pipeless = false;
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    || this.filter()
    || this.blockCode()
    || this.code()
    || this.id()
    || this.className()
    || this.attrs()
    || this.attributesBlock()
    || this.<span class="apidocCodeKeywordSpan">indent</span>()
    || this.text()
    || this.comment()
    || this.colon()
    || this.dot()
    || this.textFail()
    || this.fail();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.interpolation" id="apidoc.element.jade.Lexer.prototype.interpolation">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>interpolation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interpolation = function () {
  if (/^#\{/.test(this.input)) {
    var match = this.bracketExpression(1);

    this.consume(match.end + 1);
    return this.tok(&#x27;interpolation&#x27;, match.src);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  next: function() {
return this.deferred()
  || this.blank()
  || this.eos()
  || this.pipelessText()
  || this.yield()
  || this.doctype()
  || this.<span class="apidocCodeKeywordSpan">interpolation</span>()
  || this[&#x22;case&#x22;]()
  || this.when()
  || this[&#x22;default&#x22;]()
  || this[&#x22;extends&#x22;]()
  || this.append()
  || this.prepend()
  || this.block()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.lookahead" id="apidoc.element.jade.Lexer.prototype.lookahead">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>lookahead
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookahead = function (n){
  var fetch = n - this.stash.length;
  while (fetch-- &#x3e; 0) this.stash.push(this.next());
  return this.stash[--n];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Single token lookahead.
 *
 * @return {Object}
 * @api private
 */

peek: function() {
  return this.<span class="apidocCodeKeywordSpan">lookahead</span>(1);
},

/**
 * Return lexer lineno.
 *
 * @return {Number}
 * @api private
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.mixin" id="apidoc.element.jade.Lexer.prototype.mixin">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>mixin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixin = function (){
  var captures;
  if (captures = /^mixin +([-\w]+)(?: *\((.*)\))? */.exec(this.input)) {
    this.consume(captures[0].length);
    var tok = this.tok(&#x27;mixin&#x27;, captures[1]);
    tok.args = captures[2];
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this[&#x22;extends&#x22;]()
|| this.append()
|| this.prepend()
|| this.block()
|| this.mixinBlock()
|| this.include()
|| this.includeFiltered()
|| this.<span class="apidocCodeKeywordSpan">mixin</span>()
|| this.call()
|| this.conditional()
|| this.each()
|| this[&#x22;while&#x22;]()
|| this.tag()
|| this.filter()
|| this.blockCode()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.mixinBlock" id="apidoc.element.jade.Lexer.prototype.mixinBlock">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>mixinBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixinBlock = function () {
  var captures;
  if (captures = /^block[ \t]*(\n|$)/.exec(this.input)) {
    this.consume(captures[0].length - captures[1].length);
    return this.tok(&#x27;mixin-block&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this[&#x22;case&#x22;]()
|| this.when()
|| this[&#x22;default&#x22;]()
|| this[&#x22;extends&#x22;]()
|| this.append()
|| this.prepend()
|| this.block()
|| this.<span class="apidocCodeKeywordSpan">mixinBlock</span>()
|| this.include()
|| this.includeFiltered()
|| this.mixin()
|| this.call()
|| this.conditional()
|| this.each()
|| this[&#x22;while&#x22;]()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.next" id="apidoc.element.jade.Lexer.prototype.next">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>next
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">next = function () {
  return this.deferred()
    || this.blank()
    || this.eos()
    || this.pipelessText()
    || this.yield()
    || this.doctype()
    || this.interpolation()
    || this[&#x22;case&#x22;]()
    || this.when()
    || this[&#x22;default&#x22;]()
    || this[&#x22;extends&#x22;]()
    || this.append()
    || this.prepend()
    || this.block()
    || this.mixinBlock()
    || this.include()
    || this.includeFiltered()
    || this.mixin()
    || this.call()
    || this.conditional()
    || this.each()
    || this[&#x22;while&#x22;]()
    || this.tag()
    || this.filter()
    || this.blockCode()
    || this.code()
    || this.id()
    || this.className()
    || this.attrs()
    || this.attributesBlock()
    || this.indent()
    || this.text()
    || this.comment()
    || this.colon()
    || this.dot()
    || this.textFail()
    || this.fail();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Number} n
 * @return {Object}
 * @api private
 */

lookahead: function(n){
  var fetch = n - this.stash.length;
  while (fetch-- &#x3e; 0) this.stash.push(this.<span class="apidocCodeKeywordSpan">next</span>());
  return this.stash[--n];
},

/**
 * Return the indexOf `(` or `{` or `[` / `)` or `}` or `]` delimiters.
 *
 * @return {Number}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.pipelessText" id="apidoc.element.jade.Lexer.prototype.pipelessText">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>pipelessText
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipelessText = function () {
  if (!this.pipeless) return;
  var captures, re;

  // established regexp
  if (this.indentRe) {
    captures = this.indentRe.exec(this.input);
  // determine regexp
  } else {
    // tabs
    re = /^\n(\t*) */;
    captures = re.exec(this.input);

    // spaces
    if (captures &#x26;&#x26; !captures[1].length) {
      re = /^\n( *)/;
      captures = re.exec(this.input);
    }

    // established
    if (captures &#x26;&#x26; captures[1].length) this.indentRe = re;
  }

  var indents = captures &#x26;&#x26; captures[1].length;
  if (indents &#x26;&#x26; (this.indentStack.length === 0 || indents &#x3e; this.indentStack[0])) {
    var indent = captures[1];
    var line;
    var tokens = [];
    var isMatch;
    do {
      // text has `\n` as a prefix
      var i = this.input.substr(1).indexOf(&#x27;\n&#x27;);
      if (-1 == i) i = this.input.length - 1;
      var str = this.input.substr(1, i);
      isMatch = str.substr(0, indent.length) === indent || !str.trim();
      if (isMatch) {
        // consume test along with `\n` prefix if match
        this.consume(str.length + 1);
        ++this.lineno;
        tokens.push(str.substr(indent.length));
      }
    } while(this.input.length &#x26;&#x26; isMatch);
    while (this.input.length === 0 &#x26;&#x26; tokens[tokens.length - 1] === &#x27;&#x27;) tokens.pop();
    return this.tok(&#x27;pipeless-text&#x27;, tokens);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @api private
 */

next: function() {
  return this.deferred()
    || this.blank()
    || this.eos()
    || this.<span class="apidocCodeKeywordSpan">pipelessText</span>()
    || this.yield()
    || this.doctype()
    || this.interpolation()
    || this[&#x22;case&#x22;]()
    || this.when()
    || this[&#x22;default&#x22;]()
    || this[&#x22;extends&#x22;]()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.prepend" id="apidoc.element.jade.Lexer.prototype.prepend">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>prepend
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepend = function () {
  var captures;
  if (captures = /^prepend +([^\n]+)/.exec(this.input)) {
    this.consume(captures[0].length);
    var mode = &#x27;prepend&#x27;
      , name = captures[1]
      , tok = this.tok(&#x27;block&#x27;, name);
    tok.mode = mode;
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.doctype()
|| this.interpolation()
|| this[&#x22;case&#x22;]()
|| this.when()
|| this[&#x22;default&#x22;]()
|| this[&#x22;extends&#x22;]()
|| this.append()
|| this.<span class="apidocCodeKeywordSpan">prepend</span>()
|| this.block()
|| this.mixinBlock()
|| this.include()
|| this.includeFiltered()
|| this.mixin()
|| this.call()
|| this.conditional()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.scan" id="apidoc.element.jade.Lexer.prototype.scan">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>scan
        <span class="apidocSignatureSpan">(regexp, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scan = function (regexp, type){
  var captures;
  if (captures = regexp.exec(this.input)) {
    this.consume(captures[0].length);
    return this.tok(type, captures[1]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

/**
 * Filter.
 */

filter: function() {
  var tok = this.<span class="apidocCodeKeywordSpan">scan</span>(/^:([\w\-]+)/, &#x27;filter&#x27;);
  if (tok) {
    this.pipeless = true;
    return tok;
  }
},

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.stashed" id="apidoc.element.jade.Lexer.prototype.stashed">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>stashed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stashed = function () {
  return this.stash.length
    &#x26;&#x26; this.stash.shift();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * previously stashed by lookahead.
 *
 * @return {Object}
 * @api private
 */

advance: function(){
  return this.<span class="apidocCodeKeywordSpan">stashed</span>()
    || this.next();
},

/**
 * Return the next token object.
 *
 * @return {Object}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.tag" id="apidoc.element.jade.Lexer.prototype.tag">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>tag
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tag = function () {
  var captures;
  if (captures = /^(\w[-:\w]*)(\/?)/.exec(this.input)) {
    this.consume(captures[0].length);
    var tok, name = captures[1];
    if (&#x27;:&#x27; == name[name.length - 1]) {
      name = name.slice(0, -1);
      tok = this.tok(&#x27;tag&#x27;, name);
      this.defer(this.tok(&#x27;:&#x27;));
      if (this.input[0] !== &#x27; &#x27;) {
        console.warn(&#x27;Warning: space required after `:` on line &#x27; + this.lineno +
            &#x27; of jade file &#x22;&#x27; + this.filename + &#x27;&#x22;&#x27;);
      }
      while (&#x27; &#x27; == this.input[0]) this.input = this.input.substr(1);
    } else {
      tok = this.tok(&#x27;tag&#x27;, name);
    }
    tok.selfClosing = !!captures[2];
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.include()
|| this.includeFiltered()
|| this.mixin()
|| this.call()
|| this.conditional()
|| this.each()
|| this[&#x22;while&#x22;]()
|| this.<span class="apidocCodeKeywordSpan">tag</span>()
|| this.filter()
|| this.blockCode()
|| this.code()
|| this.id()
|| this.className()
|| this.attrs()
|| this.attributesBlock()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.text" id="apidoc.element.jade.Lexer.prototype.text">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>text
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">text = function () {
  return this.scan(/^(?:\| ?| )([^\n]+)/, &#x27;text&#x27;) ||
    this.scan(/^\|?( )/, &#x27;text&#x27;) ||
    this.scan(/^(&#x3c;[^\n]*)/, &#x27;text&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      || this.blockCode()
      || this.code()
      || this.id()
      || this.className()
      || this.attrs()
      || this.attributesBlock()
      || this.indent()
      || this.<span class="apidocCodeKeywordSpan">text</span>()
      || this.comment()
      || this.colon()
      || this.dot()
      || this.textFail()
      || this.fail();
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.textFail" id="apidoc.element.jade.Lexer.prototype.textFail">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>textFail
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">textFail = function () {
  var tok;
  if (tok = this.scan(/^([^\.\n][^\n]+)/, &#x27;text&#x27;)) {
    console.warn(&#x27;Warning: missing space before text for line &#x27; + this.lineno +
        &#x27; of jade file &#x22;&#x27; + this.filename + &#x27;&#x22;&#x27;);
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      || this.attrs()
      || this.attributesBlock()
      || this.indent()
      || this.text()
      || this.comment()
      || this.colon()
      || this.dot()
      || this.<span class="apidocCodeKeywordSpan">textFail</span>()
      || this.fail();
  }
};

},{&#x22;./utils&#x22;:25,&#x22;character-parser&#x22;:29}],7:[function(require,module,exports){
&#x27;use strict&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.tok" id="apidoc.element.jade.Lexer.prototype.tok">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>tok
        <span class="apidocSignatureSpan">(type, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tok = function (type, val){
  return {
      type: type
    , line: this.lineno
    , val: val
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @api private
 */

scan: function(regexp, type){
  var captures;
  if (captures = regexp.exec(this.input)) {
    this.consume(captures[0].length);
    return this.<span class="apidocCodeKeywordSpan">tok</span>(type, captures[1]);
  }
},

/**
 * Defer the given `tok`.
 *
 * @param {Object} tok
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.when" id="apidoc.element.jade.Lexer.prototype.when">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>when
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">when = function () {
  return this.scan(/^when +([^:\n]+)/, &#x27;when&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.blank()
|| this.eos()
|| this.pipelessText()
|| this.yield()
|| this.doctype()
|| this.interpolation()
|| this[&#x22;case&#x22;]()
|| this.<span class="apidocCodeKeywordSpan">when</span>()
|| this[&#x22;default&#x22;]()
|| this[&#x22;extends&#x22;]()
|| this.append()
|| this.prepend()
|| this.block()
|| this.mixinBlock()
|| this.include()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.while" id="apidoc.element.jade.Lexer.prototype.while">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>while
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">while = function () {
  var captures;
  if (captures = /^while +([^\n]+)/.exec(this.input)) {
    this.consume(captures[0].length);
    assertExpression(captures[1])
    var tok = this.tok(&#x27;code&#x27;, &#x27;while (&#x27; + captures[1] + &#x27;)&#x27;);
    tok.requiresBlock = true;
    return tok;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Lexer.prototype.yield" id="apidoc.element.jade.Lexer.prototype.yield">
        function <span class="apidocSignatureSpan">jade.Lexer.prototype.</span>yield
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">yield = function () {
  return this.scan(/^yield */, &#x27;yield&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */

next: function() {
  return this.deferred()
    || this.blank()
    || this.eos()
    || this.pipelessText()
    || this.<span class="apidocCodeKeywordSpan">yield</span>()
    || this.doctype()
    || this.interpolation()
    || this[&#x22;case&#x22;]()
    || this.when()
    || this[&#x22;default&#x22;]()
    || this[&#x22;extends&#x22;]()
    || this.append()
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.Parser" id="apidoc.module.jade.Parser">module jade.Parser</a></h1>


    <h2>
        <a href="#apidoc.element.jade.Parser.Parser" id="apidoc.element.jade.Parser.Parser">
        function <span class="apidocSignatureSpan">jade.</span>Parser
        <span class="apidocSignatureSpan">(str, filename, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(str, filename, options){
  //Strip any UTF-8 BOM off of the start of `str`, if it exists.
  this.input = str.replace(/^\uFEFF/, &#x27;&#x27;);
  this.lexer = new Lexer(this.input, filename);
  this.filename = filename;
  this.blocks = {};
  this.mixins = {};
  this.options = options;
  this.contexts = [this];
  this.inMixin = 0;
  this.dependencies = [];
  this.inBlock = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.Parser.prototype" id="apidoc.module.jade.Parser.prototype">module jade.Parser.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.accept" id="apidoc.element.jade.Parser.prototype.accept">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>accept
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">accept = function (type){
  if (this.peek().type === type) {
    return this.advance();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
   * filter attrs? text-block
   */

  parseFilter: function(){
var tok = this.expect(&#x27;filter&#x27;);
var attrs = this.<span class="apidocCodeKeywordSpan">accept</span>(&#x27;attrs&#x27;);
var block;

block = this.parseTextBlock() || new nodes.Block();

var options = {};
if (attrs) {
  attrs.attrs.forEach(function (attribute) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.advance" id="apidoc.element.jade.Parser.prototype.advance">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>advance
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">advance = function (){
  return this.lexer.advance();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Return the next token object.
 *
 * @return {Object}
 * @api private
 */

advance: function(){
  return this.lexer.<span class="apidocCodeKeywordSpan">advance</span>();
},

/**
 * Single token lookahead.
 *
 * @return {Object}
 * @api private
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.block" id="apidoc.element.jade.Parser.prototype.block">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>block
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block = function (){
  var block = new nodes.Block;
  block.line = this.line();
  block.filename = this.filename;
  this.expect(&#x27;indent&#x27;);
  while (&#x27;outdent&#x27; != this.peek().type) {
    if (&#x27;newline&#x27; == this.peek().type) {
      this.advance();
    } else {
      var expr = this.parseExpr();
      expr.filename = this.filename;
      block.push(expr);
    }
  }
  this.expect(&#x27;outdent&#x27;);
  return block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.interpolation()
|| this[&#x22;case&#x22;]()
|| this.when()
|| this[&#x22;default&#x22;]()
|| this[&#x22;extends&#x22;]()
|| this.append()
|| this.prepend()
|| this.<span class="apidocCodeKeywordSpan">block</span>()
|| this.mixinBlock()
|| this.include()
|| this.includeFiltered()
|| this.mixin()
|| this.call()
|| this.conditional()
|| this.each()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.constructor" id="apidoc.element.jade.Parser.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>constructor
        <span class="apidocSignatureSpan">(str, filename, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(str, filename, options){
  //Strip any UTF-8 BOM off of the start of `str`, if it exists.
  this.input = str.replace(/^\uFEFF/, &#x27;&#x27;);
  this.lexer = new Lexer(this.input, filename);
  this.filename = filename;
  this.blocks = {};
  this.mixins = {};
  this.options = options;
  this.contexts = [this];
  this.inMixin = 0;
  this.dependencies = [];
  this.inBlock = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require(&#x27;fs&#x27;);

var path = this.resolvePath(this.expect(&#x27;extends&#x27;).val.trim(), &#x27;extends&#x27;);
if (&#x27;.jade&#x27; != path.substr(-5)) path += &#x27;.jade&#x27;;

this.dependencies.push(path);
var str = fs.readFileSync(path, &#x27;utf8&#x27;);
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.context" id="apidoc.element.jade.Parser.prototype.context">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>context
        <span class="apidocSignatureSpan">(parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">context = function (parser){
  if (parser) {
    this.contexts.push(parser);
  } else {
    return this.contexts.pop();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Parse
var parser = new (options.parser || Parser)(str, options.filename, options);
var tokens;
try {
  // Parse
  tokens = parser.parse();
} catch (err) {
  parser = parser.<span class="apidocCodeKeywordSpan">context</span>();
  runtime.rethrow(err, parser.filename, parser.lexer.lineno, parser.input);
}

// Compile
var compiler = new (options.compiler || Compiler)(tokens, options);
var js;
try {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.expect" id="apidoc.element.jade.Parser.prototype.expect">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>expect
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expect = function (type){
  if (this.peek().type === type) {
    return this.advance();
  } else {
    throw new Error(&#x27;expected &#x22;&#x27; + type + &#x27;&#x22;, but got &#x22;&#x27; + this.peek().type + &#x27;&#x22;&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

/**
 * Text
 */

parseText: function(){
  var tok = this.<span class="apidocCodeKeywordSpan">expect</span>(&#x27;text&#x27;);
  var tokens = this.parseInlineTagsInText(tok.val);
  if (tokens.length === 1) return tokens[0];
  var node = new nodes.Block;
  for (var i = 0; i &#x3c; tokens.length; i++) {
    node.push(tokens[i]);
  };
  return node;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.line" id="apidoc.element.jade.Parser.prototype.line">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>line
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">line = function () {
  return this.lexer.lineno;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
   * case
   */

  parseCase: function(){
var val = this.expect(&#x27;case&#x27;).val;
var node = new nodes.Case(val);
node.line = this.<span class="apidocCodeKeywordSpan">line</span>();

var block = new nodes.Block;
block.line = this.line();
block.filename = this.filename;
this.expect(&#x27;indent&#x27;);
while (&#x27;outdent&#x27; != this.peek().type) {
  switch (this.peek().type) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.lookahead" id="apidoc.element.jade.Parser.prototype.lookahead">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>lookahead
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookahead = function (n){
  return this.lexer.lookahead(n);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Single token lookahead.
 *
 * @return {Object}
 * @api private
 */

peek: function() {
  return this.<span class="apidocCodeKeywordSpan">lookahead</span>(1);
},

/**
 * Return lexer lineno.
 *
 * @return {Number}
 * @api private
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parse" id="apidoc.element.jade.Parser.prototype.parse">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (){
  var block = new nodes.Block, parser;
  block.line = 0;
  block.filename = this.filename;

  while (&#x27;eos&#x27; != this.peek().type) {
    if (&#x27;newline&#x27; == this.peek().type) {
      this.advance();
    } else {
      var next = this.peek();
      var expr = this.parseExpr();
      expr.filename = expr.filename || this.filename;
      expr.line = next.line;
      block.push(expr);
    }
  }

  if (parser = this.extending) {
    this.context(parser);
    var ast = parser.parse();
    this.context();

    // hoist mixins
    for (var name in this.mixins)
      ast.unshift(this.mixins[name]);
    return ast;
  }

  if (!this.extending &#x26;&#x26; !this.included &#x26;&#x26; Object.keys(this.blocks).length){
    var blocks = [];
    utils.walkAST(block, function (node) {
      if (node.type === &#x27;Block&#x27; &#x26;&#x26; node.name) {
        blocks.push(node.name);
      }
    });
    Object.keys(this.blocks).forEach(function (name) {
      if (blocks.indexOf(name) === -1 &#x26;&#x26; !this.blocks[name].isSubBlock) {
        console.warn(&#x27;Warning: Unexpected block &#x22;&#x27;
                     + name
                     + &#x27;&#x22; &#x27;
                     + &#x27; on line &#x27;
                     + this.blocks[name].line
                     + &#x27; of &#x27;
                     + (this.blocks[name].filename)
                     + &#x27;. This block is never used. This warning will be an error in v2.0.0&#x27;);
      }
    }.bind(this));
  }

  return block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// Parse
var parser = new (options.parser || Parser)(str, options.filename, options);
var tokens;
try {
  // Parse
  tokens = parser.<span class="apidocCodeKeywordSpan">parse</span>();
} catch (err) {
  parser = parser.context();
  runtime.rethrow(err, parser.filename, parser.lexer.lineno, parser.input);
}

// Compile
var compiler = new (options.compiler || Compiler)(tokens, options);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseBlock" id="apidoc.element.jade.Parser.prototype.parseBlock">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseBlock = function (){
  var block = this.expect(&#x27;block&#x27;);
  var mode = block.mode;
  var name = block.val.trim();

  var line = block.line;

  this.inBlock++;
  block = &#x27;indent&#x27; == this.peek().type
    ? this.block()
    : new nodes.Block(new nodes.Literal(&#x27;&#x27;));
  this.inBlock--;
  block.name = name;
  block.line = line;

  var prev = this.blocks[name] || {prepended: [], appended: []}
  if (prev.mode === &#x27;replace&#x27;) return this.blocks[name] = prev;

  var allNodes = prev.prepended.concat(block.nodes).concat(prev.appended);

  switch (mode) {
    case &#x27;append&#x27;:
      prev.appended = prev.parser === this ?
                      prev.appended.concat(block.nodes) :
                      block.nodes.concat(prev.appended);
      break;
    case &#x27;prepend&#x27;:
      prev.prepended = prev.parser === this ?
                       block.nodes.concat(prev.prepended) :
                       prev.prepended.concat(block.nodes);
      break;
  }
  block.nodes = allNodes;
  block.appended = prev.appended;
  block.prepended = prev.prepended;
  block.mode = mode;
  block.parser = this;

  block.isSubBlock = this.inBlock &#x3e; 0;

  return this.blocks[name] = block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  parseExpr: function(){
switch (this.peek().type) {
  case &#x27;tag&#x27;:
    return this.parseTag();
  case &#x27;mixin&#x27;:
    return this.parseMixin();
  case &#x27;block&#x27;:
    return this.<span class="apidocCodeKeywordSpan">parseBlock</span>();
  case &#x27;mixin-block&#x27;:
    return this.parseMixinBlock();
  case &#x27;case&#x27;:
    return this.parseCase();
  case &#x27;extends&#x27;:
    return this.parseExtends();
  case &#x27;include&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseBlockCode" id="apidoc.element.jade.Parser.prototype.parseBlockCode">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseBlockCode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseBlockCode = function (){
  var tok = this.expect(&#x27;blockCode&#x27;);
  var node;
  var body = this.peek();
  var text;
  if (body.type === &#x27;pipeless-text&#x27;) {
    this.advance();
    text = body.val.join(&#x27;\n&#x27;);
  } else {
    text = &#x27;&#x27;;
  }
    node = new nodes.Code(text, false, false);
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;text&#x27;:
  return this.parseText();
case &#x27;each&#x27;:
  return this.parseEach();
case &#x27;code&#x27;:
  return this.parseCode();
case &#x27;blockCode&#x27;:
  return this.<span class="apidocCodeKeywordSpan">parseBlockCode</span>();
case &#x27;call&#x27;:
  return this.parseCall();
case &#x27;interpolation&#x27;:
  return this.parseInterpolation();
case &#x27;yield&#x27;:
  this.advance();
  var block = new nodes.Block;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseBlockExpansion" id="apidoc.element.jade.Parser.prototype.parseBlockExpansion">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseBlockExpansion
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseBlockExpansion = function (){
  if (&#x27;:&#x27; == this.peek().type) {
    this.advance();
    return new nodes.Block(this.parseExpr());
  } else {
    return this.block();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * when
 */

parseWhen: function(){
  var val = this.expect(&#x27;when&#x27;).val;
  if (this.peek().type !== &#x27;newline&#x27;)
    return new nodes.Case.When(val, this.<span class="apidocCodeKeywordSpan">parseBlockExpansion</span>());
  else
    return new nodes.Case.When(val);
},

/**
 * default
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseCall" id="apidoc.element.jade.Parser.prototype.parseCall">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseCall
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseCall = function (){
  var tok = this.expect(&#x27;call&#x27;);
  var name = tok.val;
  var args = tok.args;
  var mixin = new nodes.Mixin(name, args, new nodes.Block, true);

  this.tag(mixin);
  if (mixin.code) {
    mixin.block.push(mixin.code);
    mixin.code = null;
  }
  if (mixin.block.isEmpty()) mixin.block = null;
  return mixin;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;each&#x27;:
  return this.parseEach();
case &#x27;code&#x27;:
  return this.parseCode();
case &#x27;blockCode&#x27;:
  return this.parseBlockCode();
case &#x27;call&#x27;:
  return this.<span class="apidocCodeKeywordSpan">parseCall</span>();
case &#x27;interpolation&#x27;:
  return this.parseInterpolation();
case &#x27;yield&#x27;:
  this.advance();
  var block = new nodes.Block;
  block.yield = true;
  return block;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseCase" id="apidoc.element.jade.Parser.prototype.parseCase">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseCase
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseCase = function (){
  var val = this.expect(&#x27;case&#x27;).val;
  var node = new nodes.Case(val);
  node.line = this.line();

  var block = new nodes.Block;
  block.line = this.line();
  block.filename = this.filename;
  this.expect(&#x27;indent&#x27;);
  while (&#x27;outdent&#x27; != this.peek().type) {
    switch (this.peek().type) {
      case &#x27;comment&#x27;:
      case &#x27;newline&#x27;:
        this.advance();
        break;
      case &#x27;when&#x27;:
        block.push(this.parseWhen());
        break;
      case &#x27;default&#x27;:
        block.push(this.parseDefault());
        break;
      default:
        throw new Error(&#x27;Unexpected token &#x22;&#x27; + this.peek().type
                        + &#x27;&#x22;, expected &#x22;when&#x22;, &#x22;default&#x22; or &#x22;newline&#x22;&#x27;);
    }
  }
  this.expect(&#x27;outdent&#x27;);

  node.block = block;

  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;mixin&#x27;:
  return this.parseMixin();
case &#x27;block&#x27;:
  return this.parseBlock();
case &#x27;mixin-block&#x27;:
  return this.parseMixinBlock();
case &#x27;case&#x27;:
  return this.<span class="apidocCodeKeywordSpan">parseCase</span>();
case &#x27;extends&#x27;:
  return this.parseExtends();
case &#x27;include&#x27;:
  return this.parseInclude();
case &#x27;doctype&#x27;:
  return this.parseDoctype();
case &#x27;filter&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseCode" id="apidoc.element.jade.Parser.prototype.parseCode">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseCode
        <span class="apidocSignatureSpan">(afterIf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseCode = function (afterIf){
  var tok = this.expect(&#x27;code&#x27;);
  var node = new nodes.Code(tok.val, tok.buffer, tok.escape);
  var block;
  node.line = this.line();

  // throw an error if an else does not have an if
  if (tok.isElse &#x26;&#x26; !tok.hasIf) {
    throw new Error(&#x27;Unexpected else without if&#x27;);
  }

  // handle block
  block = &#x27;indent&#x27; == this.peek().type;
  if (block) {
    node.block = this.block();
  }

  // handle missing block
  if (tok.requiresBlock &#x26;&#x26; !block) {
    node.block = new nodes.Block();
  }

  // mark presense of if for future elses
  if (tok.isIf &#x26;&#x26; this.peek().isElse) {
    this.peek().hasIf = true;
  } else if (tok.isIf &#x26;&#x26; this.peek().type === &#x27;newline&#x27; &#x26;&#x26; this.lookahead(2).isElse) {
    this.lookahead(2).hasIf = true;
  }

  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;comment&#x27;:
  return this.parseComment();
case &#x27;text&#x27;:
  return this.parseText();
case &#x27;each&#x27;:
  return this.parseEach();
case &#x27;code&#x27;:
  return this.<span class="apidocCodeKeywordSpan">parseCode</span>();
case &#x27;blockCode&#x27;:
  return this.parseBlockCode();
case &#x27;call&#x27;:
  return this.parseCall();
case &#x27;interpolation&#x27;:
  return this.parseInterpolation();
case &#x27;yield&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseComment" id="apidoc.element.jade.Parser.prototype.parseComment">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseComment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseComment = function (){
  var tok = this.expect(&#x27;comment&#x27;);
  var node;

  var block;
  if (block = this.parseTextBlock()) {
    node = new nodes.BlockComment(tok.val, block, tok.buffer);
  } else {
    node = new nodes.Comment(tok.val, tok.buffer);
  }

  node.line = this.line();
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;include&#x27;:
  return this.parseInclude();
case &#x27;doctype&#x27;:
  return this.parseDoctype();
case &#x27;filter&#x27;:
  return this.parseFilter();
case &#x27;comment&#x27;:
  return this.<span class="apidocCodeKeywordSpan">parseComment</span>();
case &#x27;text&#x27;:
  return this.parseText();
case &#x27;each&#x27;:
  return this.parseEach();
case &#x27;code&#x27;:
  return this.parseCode();
case &#x27;blockCode&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseDefault" id="apidoc.element.jade.Parser.prototype.parseDefault">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseDefault
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseDefault = function (){
  this.expect(&#x27;default&#x27;);
  return new nodes.Case.When(&#x27;default&#x27;, this.parseBlockExpansion());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    case &#x27;newline&#x27;:
      this.advance();
      break;
    case &#x27;when&#x27;:
      block.push(this.parseWhen());
      break;
    case &#x27;default&#x27;:
      block.push(this.<span class="apidocCodeKeywordSpan">parseDefault</span>());
      break;
    default:
      throw new Error(&#x27;Unexpected token &#x22;&#x27; + this.peek().type
                      + &#x27;&#x22;, expected &#x22;when&#x22;, &#x22;default&#x22; or &#x22;newline&#x22;&#x27;);
  }
}
this.expect(&#x27;outdent&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseDoctype" id="apidoc.element.jade.Parser.prototype.parseDoctype">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseDoctype
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseDoctype = function (){
  var tok = this.expect(&#x27;doctype&#x27;);
  var node = new nodes.Doctype(tok.val);
  node.line = this.line();
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;case&#x27;:
  return this.parseCase();
case &#x27;extends&#x27;:
  return this.parseExtends();
case &#x27;include&#x27;:
  return this.parseInclude();
case &#x27;doctype&#x27;:
  return this.<span class="apidocCodeKeywordSpan">parseDoctype</span>();
case &#x27;filter&#x27;:
  return this.parseFilter();
case &#x27;comment&#x27;:
  return this.parseComment();
case &#x27;text&#x27;:
  return this.parseText();
case &#x27;each&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseEach" id="apidoc.element.jade.Parser.prototype.parseEach">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseEach
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseEach = function (){
  var tok = this.expect(&#x27;each&#x27;);
  var node = new nodes.Each(tok.code, tok.val, tok.key);
  node.line = this.line();
  node.block = this.block();
  if (this.peek().type == &#x27;code&#x27; &#x26;&#x26; this.peek().val == &#x27;else&#x27;) {
    this.advance();
    node.alternative = this.block();
  }
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;filter&#x27;:
  return this.parseFilter();
case &#x27;comment&#x27;:
  return this.parseComment();
case &#x27;text&#x27;:
  return this.parseText();
case &#x27;each&#x27;:
  return this.<span class="apidocCodeKeywordSpan">parseEach</span>();
case &#x27;code&#x27;:
  return this.parseCode();
case &#x27;blockCode&#x27;:
  return this.parseBlockCode();
case &#x27;call&#x27;:
  return this.parseCall();
case &#x27;interpolation&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseExpr" id="apidoc.element.jade.Parser.prototype.parseExpr">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseExpr
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseExpr = function (){
  switch (this.peek().type) {
    case &#x27;tag&#x27;:
      return this.parseTag();
    case &#x27;mixin&#x27;:
      return this.parseMixin();
    case &#x27;block&#x27;:
      return this.parseBlock();
    case &#x27;mixin-block&#x27;:
      return this.parseMixinBlock();
    case &#x27;case&#x27;:
      return this.parseCase();
    case &#x27;extends&#x27;:
      return this.parseExtends();
    case &#x27;include&#x27;:
      return this.parseInclude();
    case &#x27;doctype&#x27;:
      return this.parseDoctype();
    case &#x27;filter&#x27;:
      return this.parseFilter();
    case &#x27;comment&#x27;:
      return this.parseComment();
    case &#x27;text&#x27;:
      return this.parseText();
    case &#x27;each&#x27;:
      return this.parseEach();
    case &#x27;code&#x27;:
      return this.parseCode();
    case &#x27;blockCode&#x27;:
      return this.parseBlockCode();
    case &#x27;call&#x27;:
      return this.parseCall();
    case &#x27;interpolation&#x27;:
      return this.parseInterpolation();
    case &#x27;yield&#x27;:
      this.advance();
      var block = new nodes.Block;
      block.yield = true;
      return block;
    case &#x27;id&#x27;:
    case &#x27;class&#x27;:
      var tok = this.advance();
      this.lexer.defer(this.lexer.tok(&#x27;tag&#x27;, &#x27;div&#x27;));
      this.lexer.defer(tok);
      return this.parseExpr();
    default:
      throw new Error(&#x27;unexpected token &#x22;&#x27; + this.peek().type + &#x27;&#x22;&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
block.filename = this.filename;

while (&#x27;eos&#x27; != this.peek().type) {
  if (&#x27;newline&#x27; == this.peek().type) {
    this.advance();
  } else {
    var next = this.peek();
    var expr = this.<span class="apidocCodeKeywordSpan">parseExpr</span>();
    expr.filename = expr.filename || this.filename;
    expr.line = next.line;
    block.push(expr);
  }
}

if (parser = this.extending) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseExtends" id="apidoc.element.jade.Parser.prototype.parseExtends">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseExtends
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseExtends = function (){
  var fs = require(&#x27;fs&#x27;);

  var path = this.resolvePath(this.expect(&#x27;extends&#x27;).val.trim(), &#x27;extends&#x27;);
  if (&#x27;.jade&#x27; != path.substr(-5)) path += &#x27;.jade&#x27;;

  this.dependencies.push(path);
  var str = fs.readFileSync(path, &#x27;utf8&#x27;);
  var parser = new this.constructor(str, path, this.options);
  parser.dependencies = this.dependencies;

  parser.blocks = this.blocks;
  parser.included = this.included;
  parser.contexts = this.contexts;
  this.extending = parser;

  // TODO: null node
  return new nodes.Literal(&#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;block&#x27;:
  return this.parseBlock();
case &#x27;mixin-block&#x27;:
  return this.parseMixinBlock();
case &#x27;case&#x27;:
  return this.parseCase();
case &#x27;extends&#x27;:
  return this.<span class="apidocCodeKeywordSpan">parseExtends</span>();
case &#x27;include&#x27;:
  return this.parseInclude();
case &#x27;doctype&#x27;:
  return this.parseDoctype();
case &#x27;filter&#x27;:
  return this.parseFilter();
case &#x27;comment&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseFilter" id="apidoc.element.jade.Parser.prototype.parseFilter">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseFilter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseFilter = function (){
  var tok = this.expect(&#x27;filter&#x27;);
  var attrs = this.accept(&#x27;attrs&#x27;);
  var block;

  block = this.parseTextBlock() || new nodes.Block();

  var options = {};
  if (attrs) {
    attrs.attrs.forEach(function (attribute) {
      options[attribute.name] = constantinople.toConstant(attribute.val);
    });
  }

  var node = new nodes.Filter(tok.val, block, options);
  node.line = this.line();
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;extends&#x27;:
  return this.parseExtends();
case &#x27;include&#x27;:
  return this.parseInclude();
case &#x27;doctype&#x27;:
  return this.parseDoctype();
case &#x27;filter&#x27;:
  return this.<span class="apidocCodeKeywordSpan">parseFilter</span>();
case &#x27;comment&#x27;:
  return this.parseComment();
case &#x27;text&#x27;:
  return this.parseText();
case &#x27;each&#x27;:
  return this.parseEach();
case &#x27;code&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseInclude" id="apidoc.element.jade.Parser.prototype.parseInclude">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseInclude
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseInclude = function (){
  var fs = require(&#x27;fs&#x27;);
  var tok = this.expect(&#x27;include&#x27;);

  var path = this.resolvePath(tok.val.trim(), &#x27;include&#x27;);
  this.dependencies.push(path);
  // has-filter
  if (tok.filter) {
    var str = fs.readFileSync(path, &#x27;utf8&#x27;).replace(/\r/g, &#x27;&#x27;);
    var options = {filename: path};
    if (tok.attrs) {
      tok.attrs.attrs.forEach(function (attribute) {
        options[attribute.name] = constantinople.toConstant(attribute.val);
      });
    }
    str = filters(tok.filter, str, options);
    return new nodes.Literal(str);
  }

  // non-jade
  if (&#x27;.jade&#x27; != path.substr(-5)) {
    var str = fs.readFileSync(path, &#x27;utf8&#x27;).replace(/\r/g, &#x27;&#x27;);
    return new nodes.Literal(str);
  }

  var str = fs.readFileSync(path, &#x27;utf8&#x27;);
  var parser = new this.constructor(str, path, this.options);
  parser.dependencies = this.dependencies;

  parser.blocks = utils.merge({}, this.blocks);
  parser.included = true;

  parser.mixins = this.mixins;

  this.context(parser);
  var ast = parser.parse();
  this.context();
  ast.filename = path;

  if (&#x27;indent&#x27; == this.peek().type) {
    ast.includeBlock().push(this.block());
  }

  return ast;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;mixin-block&#x27;:
  return this.parseMixinBlock();
case &#x27;case&#x27;:
  return this.parseCase();
case &#x27;extends&#x27;:
  return this.parseExtends();
case &#x27;include&#x27;:
  return this.<span class="apidocCodeKeywordSpan">parseInclude</span>();
case &#x27;doctype&#x27;:
  return this.parseDoctype();
case &#x27;filter&#x27;:
  return this.parseFilter();
case &#x27;comment&#x27;:
  return this.parseComment();
case &#x27;text&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseInlineTagsInText" id="apidoc.element.jade.Parser.prototype.parseInlineTagsInText">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseInlineTagsInText
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseInlineTagsInText = function (str) {
  var line = this.line();

  var match = /(\\)?#\[((?:.|\n)*)$/.exec(str);
  if (match) {
    if (match[1]) { // escape
      var text = new nodes.Text(str.substr(0, match.index) + &#x27;#[&#x27;);
      text.line = line;
      var rest = this.parseInlineTagsInText(match[2]);
      if (rest[0].type === &#x27;Text&#x27;) {
        text.val += rest[0].val;
        rest.shift();
      }
      return [text].concat(rest);
    } else {
      var text = new nodes.Text(str.substr(0, match.index));
      text.line = line;
      var buffer = [text];
      var rest = match[2];
      var range = parseJSExpression(rest);
      var inner = new Parser(range.src, this.filename, this.options);
      buffer.push(inner.parse());
      return buffer.concat(this.parseInlineTagsInText(rest.substr(range.end + 1)));
    }
  } else {
    var text = new nodes.Text(str);
    text.line = line;
    return [text];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Text
 */

parseText: function(){
  var tok = this.expect(&#x27;text&#x27;);
  var tokens = this.<span class="apidocCodeKeywordSpan">parseInlineTagsInText</span>(tok.val);
  if (tokens.length === 1) return tokens[0];
  var node = new nodes.Block;
  for (var i = 0; i &#x3c; tokens.length; i++) {
    node.push(tokens[i]);
  };
  return node;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseInterpolation" id="apidoc.element.jade.Parser.prototype.parseInterpolation">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseInterpolation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseInterpolation = function (){
  var tok = this.advance();
  var tag = new nodes.Tag(tok.val);
  tag.buffer = true;
  return this.tag(tag);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;code&#x27;:
  return this.parseCode();
case &#x27;blockCode&#x27;:
  return this.parseBlockCode();
case &#x27;call&#x27;:
  return this.parseCall();
case &#x27;interpolation&#x27;:
  return this.<span class="apidocCodeKeywordSpan">parseInterpolation</span>();
case &#x27;yield&#x27;:
  this.advance();
  var block = new nodes.Block;
  block.yield = true;
  return block;
case &#x27;id&#x27;:
case &#x27;class&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseMixin" id="apidoc.element.jade.Parser.prototype.parseMixin">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseMixin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseMixin = function (){
  var tok = this.expect(&#x27;mixin&#x27;);
  var name = tok.val;
  var args = tok.args;
  var mixin;

  // definition
  if (&#x27;indent&#x27; == this.peek().type) {
    this.inMixin++;
    mixin = new nodes.Mixin(name, args, this.block(), false);
    this.mixins[name] = mixin;
    this.inMixin--;
    return mixin;
  // call
  } else {
    return new nodes.Mixin(name, args, null, true);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */

parseExpr: function(){
  switch (this.peek().type) {
    case &#x27;tag&#x27;:
      return this.parseTag();
    case &#x27;mixin&#x27;:
      return this.<span class="apidocCodeKeywordSpan">parseMixin</span>();
    case &#x27;block&#x27;:
      return this.parseBlock();
    case &#x27;mixin-block&#x27;:
      return this.parseMixinBlock();
    case &#x27;case&#x27;:
      return this.parseCase();
    case &#x27;extends&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseMixinBlock" id="apidoc.element.jade.Parser.prototype.parseMixinBlock">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseMixinBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseMixinBlock = function () {
  var block = this.expect(&#x27;mixin-block&#x27;);
  if (!this.inMixin) {
    throw new Error(&#x27;Anonymous blocks are not allowed unless they are part of a mixin.&#x27;);
  }
  return new nodes.MixinBlock();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;tag&#x27;:
  return this.parseTag();
case &#x27;mixin&#x27;:
  return this.parseMixin();
case &#x27;block&#x27;:
  return this.parseBlock();
case &#x27;mixin-block&#x27;:
  return this.<span class="apidocCodeKeywordSpan">parseMixinBlock</span>();
case &#x27;case&#x27;:
  return this.parseCase();
case &#x27;extends&#x27;:
  return this.parseExtends();
case &#x27;include&#x27;:
  return this.parseInclude();
case &#x27;doctype&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseTag" id="apidoc.element.jade.Parser.prototype.parseTag">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseTag
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseTag = function (){
  var tok = this.advance();
  var tag = new nodes.Tag(tok.val);

  tag.selfClosing = tok.selfClosing;

  return this.tag(tag);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * | class
 * | interpolation
 */

parseExpr: function(){
  switch (this.peek().type) {
    case &#x27;tag&#x27;:
      return this.<span class="apidocCodeKeywordSpan">parseTag</span>();
    case &#x27;mixin&#x27;:
      return this.parseMixin();
    case &#x27;block&#x27;:
      return this.parseBlock();
    case &#x27;mixin-block&#x27;:
      return this.parseMixinBlock();
    case &#x27;case&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseText" id="apidoc.element.jade.Parser.prototype.parseText">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseText
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseText = function (){
  var tok = this.expect(&#x27;text&#x27;);
  var tokens = this.parseInlineTagsInText(tok.val);
  if (tokens.length === 1) return tokens[0];
  var node = new nodes.Block;
  for (var i = 0; i &#x3c; tokens.length; i++) {
    node.push(tokens[i]);
  };
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;doctype&#x27;:
  return this.parseDoctype();
case &#x27;filter&#x27;:
  return this.parseFilter();
case &#x27;comment&#x27;:
  return this.parseComment();
case &#x27;text&#x27;:
  return this.<span class="apidocCodeKeywordSpan">parseText</span>();
case &#x27;each&#x27;:
  return this.parseEach();
case &#x27;code&#x27;:
  return this.parseCode();
case &#x27;blockCode&#x27;:
  return this.parseBlockCode();
case &#x27;call&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseTextBlock" id="apidoc.element.jade.Parser.prototype.parseTextBlock">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseTextBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseTextBlock = function (){
  var block = new nodes.Block;
  block.line = this.line();
  var body = this.peek();
  if (body.type !== &#x27;pipeless-text&#x27;) return;
  this.advance();
  block.nodes = body.val.reduce(function (accumulator, text) {
    return accumulator.concat(this.parseInlineTagsInText(text));
  }.bind(this), []);
  return block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   */

  parseComment: function(){
var tok = this.expect(&#x27;comment&#x27;);
var node;

var block;
if (block = this.<span class="apidocCodeKeywordSpan">parseTextBlock</span>()) {
  node = new nodes.BlockComment(tok.val, block, tok.buffer);
} else {
  node = new nodes.Comment(tok.val, tok.buffer);
}

node.line = this.line();
return node;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.parseWhen" id="apidoc.element.jade.Parser.prototype.parseWhen">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>parseWhen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseWhen = function (){
  var val = this.expect(&#x27;when&#x27;).val;
  if (this.peek().type !== &#x27;newline&#x27;)
    return new nodes.Case.When(val, this.parseBlockExpansion());
  else
    return new nodes.Case.When(val);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    while (&#x27;outdent&#x27; != this.peek().type) {
switch (this.peek().type) {
  case &#x27;comment&#x27;:
  case &#x27;newline&#x27;:
    this.advance();
    break;
  case &#x27;when&#x27;:
    block.push(this.<span class="apidocCodeKeywordSpan">parseWhen</span>());
    break;
  case &#x27;default&#x27;:
    block.push(this.parseDefault());
    break;
  default:
    throw new Error(&#x27;Unexpected token &#x22;&#x27; + this.peek().type
                    + &#x27;&#x22;, expected &#x22;when&#x22;, &#x22;default&#x22; or &#x22;newline&#x22;&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.peek" id="apidoc.element.jade.Parser.prototype.peek">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>peek
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">peek = function () {
  return this.lookahead(1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   */

  parse: function(){
var block = new nodes.Block, parser;
block.line = 0;
block.filename = this.filename;

while (&#x27;eos&#x27; != this.<span class="apidocCodeKeywordSpan">peek</span>().type) {
  if (&#x27;newline&#x27; == this.peek().type) {
    this.advance();
  } else {
    var next = this.peek();
    var expr = this.parseExpr();
    expr.filename = expr.filename || this.filename;
    expr.line = next.line;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.resolvePath" id="apidoc.element.jade.Parser.prototype.resolvePath">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>resolvePath
        <span class="apidocSignatureSpan">(path, purpose)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolvePath = function (path, purpose) {
  var p = require(&#x27;path&#x27;);
  var dirname = p.dirname;
  var basename = p.basename;
  var join = p.join;

  if (path[0] !== &#x27;/&#x27; &#x26;&#x26; !this.filename)
    throw new Error(&#x27;the &#x22;filename&#x22; option is required to use &#x22;&#x27; + purpose + &#x27;&#x22; with &#x22;relative&#x22; paths&#x27;);

  if (path[0] === &#x27;/&#x27; &#x26;&#x26; !this.options.basedir)
    throw new Error(&#x27;the &#x22;basedir&#x22; option is required to use &#x22;&#x27; + purpose + &#x27;&#x22; with &#x22;absolute&#x22; paths&#x27;);

  path = join(path[0] === &#x27;/&#x27; ? this.options.basedir : dirname(this.filename), path);

  if (basename(path).indexOf(&#x27;.&#x27;) === -1) path += &#x27;.jade&#x27;;

  return path;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
   * &#x27;extends&#x27; name
   */

  parseExtends: function(){
var fs = require(&#x27;fs&#x27;);

var path = this.<span class="apidocCodeKeywordSpan">resolvePath</span>(this.expect(&#x27;extends&#x27;).val.trim(), &#x27;extends
&#x27;);
if (&#x27;.jade&#x27; != path.substr(-5)) path += &#x27;.jade&#x27;;

this.dependencies.push(path);
var str = fs.readFileSync(path, &#x27;utf8&#x27;);
var parser = new this.constructor(str, path, this.options);
parser.dependencies = this.dependencies;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.Parser.prototype.tag" id="apidoc.element.jade.Parser.prototype.tag">
        function <span class="apidocSignatureSpan">jade.Parser.prototype.</span>tag
        <span class="apidocSignatureSpan">(tag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tag = function (tag){
  tag.line = this.line();

  var seenAttrs = false;
  // (attrs | class | id)*
  out:
    while (true) {
      switch (this.peek().type) {
        case &#x27;id&#x27;:
        case &#x27;class&#x27;:
          var tok = this.advance();
          tag.setAttribute(tok.type, &#x22;&#x27;&#x22; + tok.val + &#x22;&#x27;&#x22;);
          continue;
        case &#x27;attrs&#x27;:
          if (seenAttrs) {
            console.warn(this.filename + &#x27;, line &#x27; + this.peek().line + &#x27;:\nYou should not have jade tags with multiple attributes
.&#x27;);
          }
          seenAttrs = true;
          var tok = this.advance();
          var attrs = tok.attrs;

          if (tok.selfClosing) tag.selfClosing = true;

          for (var i = 0; i &#x3c; attrs.length; i++) {
            tag.setAttribute(attrs[i].name, attrs[i].val, attrs[i].escaped);
          }
          continue;
        case &#x27;&#x26;attributes&#x27;:
          var tok = this.advance();
          tag.addAttributes(tok.val);
          break;
        default:
          break out;
      }
    }

  // check immediate &#x27;.&#x27;
  if (&#x27;dot&#x27; == this.peek().type) {
    tag.textOnly = true;
    this.advance();
  }

  // (text | code | &#x27;:&#x27;)?
  switch (this.peek().type) {
    case &#x27;text&#x27;:
      tag.block.push(this.parseText());
      break;
    case &#x27;code&#x27;:
      tag.code = this.parseCode();
      break;
    case &#x27;:&#x27;:
      this.advance();
      tag.block = new nodes.Block;
      tag.block.push(this.parseExpr());
      break;
    case &#x27;newline&#x27;:
    case &#x27;indent&#x27;:
    case &#x27;outdent&#x27;:
    case &#x27;eos&#x27;:
    case &#x27;pipeless-text&#x27;:
      break;
    default:
      throw new Error(&#x27;Unexpected token `&#x27; + this.peek().type + &#x27;` expected `text`, `code`, `:`, `newline` or `eos`&#x27;)
  }

  // newline*
  while (&#x27;newline&#x27; == this.peek().type) this.advance();

  // block?
  if (tag.textOnly) {
    tag.block = this.parseTextBlock() || new nodes.Block();
  } else if (&#x27;indent&#x27; == this.peek().type) {
    var block = this.block();
    for (var i = 0, len = block.nodes.length; i &#x3c; len; ++i) {
      tag.block.push(block.nodes[i]);
    }
  }

  return tag;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|| this.include()
|| this.includeFiltered()
|| this.mixin()
|| this.call()
|| this.conditional()
|| this.each()
|| this[&#x22;while&#x22;]()
|| this.<span class="apidocCodeKeywordSpan">tag</span>()
|| this.filter()
|| this.blockCode()
|| this.code()
|| this.id()
|| this.className()
|| this.attrs()
|| this.attributesBlock()
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.jade" id="apidoc.module.jade.jade">module jade.jade</a></h1>


    <h2>
        <a href="#apidoc.element.jade.jade.Compiler" id="apidoc.element.jade.jade.Compiler">
        function <span class="apidocSignatureSpan">jade.jade.</span>Compiler
        <span class="apidocSignatureSpan">(node, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Compiler(node, options) {
  this.options = options = options || {};
  this.node = node;
  this.hasCompiledDoctype = false;
  this.hasCompiledTag = false;
  this.pp = options.pretty || false;
  if (this.pp &#x26;&#x26; typeof this.pp !== &#x27;string&#x27;) {
    this.pp = &#x27;  &#x27;;
  }
  this.debug = false !== options.compileDebug;
  this.indents = 0;
  this.parentIndents = 0;
  this.terse = false;
  this.mixins = {};
  this.dynamicMixins = false;
  if (options.doctype) this.setDoctype(options.doctype);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.jade.Lexer" id="apidoc.element.jade.jade.Lexer">
        function <span class="apidocSignatureSpan">jade.jade.</span>Lexer
        <span class="apidocSignatureSpan">(str, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Lexer(str, filename) {
  this.input = str.replace(/\r\n|\r/g, &#x27;\n&#x27;);
  this.filename = filename;
  this.deferredTokens = [];
  this.lastIndents = 0;
  this.lineno = 1;
  this.stash = [];
  this.indentStack = [];
  this.indentRe = null;
  this.pipeless = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.jade.Parser" id="apidoc.element.jade.jade.Parser">
        function <span class="apidocSignatureSpan">jade.jade.</span>Parser
        <span class="apidocSignatureSpan">(str, filename, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(str, filename, options){
  //Strip any UTF-8 BOM off of the start of `str`, if it exists.
  this.input = str.replace(/^\uFEFF/, &#x27;&#x27;);
  this.lexer = new Lexer(this.input, filename);
  this.filename = filename;
  this.blocks = {};
  this.mixins = {};
  this.options = options;
  this.contexts = [this];
  this.inMixin = 0;
  this.dependencies = [];
  this.inBlock = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.jade.__express" id="apidoc.element.jade.jade.__express">
        function <span class="apidocSignatureSpan">jade.jade.</span>__express
        <span class="apidocSignatureSpan">(path, options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__express = function (path, options, fn) {
  if(options.compileDebug == undefined &#x26;&#x26; process.env.NODE_ENV === &#x27;production&#x27;) {
    options.compileDebug = false;
  }
  exports.renderFile(path, options, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.jade.compile" id="apidoc.element.jade.jade.compile">
        function <span class="apidocSignatureSpan">jade.jade.</span>compile
        <span class="apidocSignatureSpan">(str, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (str, options){
  var options = options || {}
    , filename = options.filename
      ? utils.stringify(options.filename)
      : &#x27;undefined&#x27;
    , fn;

  str = String(str);

  var parsed = parse(str, options);
  if (options.compileDebug !== false) {
    fn = [
        &#x27;var jade_debug = [ new jade.DebugItem( 1, &#x27; + filename + &#x27; ) ];&#x27;
      , &#x27;try {&#x27;
      , parsed.body
      , &#x27;} catch (err) {&#x27;
      , &#x27;  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno&#x27; + (options.compileDebug === true ? &#x27;,&#x27; + utils.stringify
(str) : &#x27;&#x27;) + &#x27;);&#x27;
      , &#x27;}&#x27;
    ].join(&#x27;\n&#x27;);
  } else {
    fn = parsed.body;
  }
  fn = new Function(&#x27;locals, jade&#x27;, fn)
  var res = function(locals){ return fn(locals, Object.create(runtime)) };
  if (options.client) {
    res.toString = function () {
      var err = new Error(&#x27;The `client` option is deprecated, use the `jade.compileClient` method instead&#x27;);
      err.name = &#x27;Warning&#x27;;
      console.error(err.stack || /* istanbul ignore next */ err.message);
      return exports.compileClient(str, options);
    };
  }
  res.dependencies = parsed.dependencies;
  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

For full API, see [jade-lang.com/api](http://jade-lang.com/api/)

```js
var jade = require(&#x27;jade&#x27;);

// compile
var fn = jade.<span class="apidocCodeKeywordSpan">compile</span>(&#x27;string of jade&#x27;, options);
var html = fn(locals);

// render
var html = jade.render(&#x27;string of jade&#x27;, merge(options, locals));

// renderFile
var html = jade.renderFile(&#x27;filename.jade&#x27;, merge(options, locals));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.jade.compileClient" id="apidoc.element.jade.jade.compileClient">
        function <span class="apidocSignatureSpan">jade.jade.</span>compileClient
        <span class="apidocSignatureSpan">(str, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileClient = function (str, options) {
  return exports.compileClientWithDependenciesTracked(str, options).body;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  fn = new Function(&#x27;locals, jade&#x27;, fn)
  var res = function(locals){ return fn(locals, Object.create(runtime)) };
  if (options.client) {
    res.toString = function () {
      var err = new Error(&#x27;The `client` option is deprecated, use the `jade.compileClient` method instead&#x27;);
      err.name = &#x27;Warning&#x27;;
      console.error(err.stack || /* istanbul ignore next */ err.message);
      return exports.<span class="apidocCodeKeywordSpan">compileClient</span>(str, options);
    };
  }
  res.dependencies = parsed.dependencies;
  return res;
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.jade.compileClientWithDependenciesTracked" id="apidoc.element.jade.jade.compileClientWithDependenciesTracked">
        function <span class="apidocSignatureSpan">jade.jade.</span>compileClientWithDependenciesTracked
        <span class="apidocSignatureSpan">(str, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileClientWithDependenciesTracked = function (str, options){
  var options = options || {};
  var name = options.name || &#x27;template&#x27;;
  var filename = options.filename ? utils.stringify(options.filename) : &#x27;undefined&#x27;;
  var fn;

  str = String(str);
  options.compileDebug = options.compileDebug ? true : false;
  var parsed = parse(str, options);
  if (options.compileDebug) {
    fn = [
        &#x27;var jade_debug = [ new jade.DebugItem( 1, &#x27; + filename + &#x27; ) ];&#x27;
      , &#x27;try {&#x27;
      , parsed.body
      , &#x27;} catch (err) {&#x27;
      , &#x27;  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno, &#x27; + utils.stringify(str) + &#x27;);&#x27;
      , &#x27;}&#x27;
    ].join(&#x27;\n&#x27;);
  } else {
    fn = parsed.body;
  }

  return {body: &#x27;function &#x27; + name + &#x27;(locals) {\n&#x27; + fn + &#x27;\n}&#x27;, dependencies: parsed.dependencies};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @param {String} str
* @param {Options} options
* @return {String}
* @api public
*/
exports.compileClient = function (str, options) {
 return exports.<span class="apidocCodeKeywordSpan">compileClientWithDependenciesTracked</span>(str, options).body;
};

/**
* Compile a `Function` representation of the given jade file.
*
* Options:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.jade.compileFile" id="apidoc.element.jade.jade.compileFile">
        function <span class="apidocSignatureSpan">jade.jade.</span>compileFile
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileFile = function (path, options) {
  options = options || {};
  options.filename = path;
  return handleTemplateCache(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.jade.compileFileClient" id="apidoc.element.jade.jade.compileFileClient">
        function <span class="apidocSignatureSpan">jade.jade.</span>compileFileClient
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileFileClient = function (path, options){
  var key = path + &#x27;:client&#x27;;
  options = options || {};

  options.filename = path;

  if (options.cache &#x26;&#x26; exports.cache[key]) {
    return exports.cache[key];
  }

  var str = fs.readFileSync(options.filename, &#x27;utf8&#x27;);
  var out = exports.compileClient(str, options);
  if (options.cache) exports.cache[key] = out;
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.jade.filters" id="apidoc.element.jade.jade.filters">
        function <span class="apidocSignatureSpan">jade.jade.</span>filters
        <span class="apidocSignatureSpan">(name, str, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filter(name, str, options) {
  if (typeof filter[name] === &#x27;function&#x27;) {
    return filter[name](str, options);
  } else {
    throw new Error(&#x27;unknown filter &#x22;:&#x27; + name + &#x27;&#x22;&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.jade.render" id="apidoc.element.jade.jade.render">
        function <span class="apidocSignatureSpan">jade.jade.</span>render
        <span class="apidocSignatureSpan">(str, options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">render = function (str, options, fn){
  // support callback API
  if (&#x27;function&#x27; == typeof options) {
    fn = options, options = undefined;
  }
  if (typeof fn === &#x27;function&#x27;) {
    var res
    try {
      res = exports.render(str, options);
    } catch (ex) {
      return fn(ex);
    }
    return fn(null, res);
  }

  options = options || {};

  // cache requires .filename
  if (options.cache &#x26;&#x26; !options.filename) {
    throw new Error(&#x27;the &#x22;filename&#x22; option is required for caching&#x27;);
  }

  return handleTemplateCache(options, str)(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var jade = require(&#x27;jade&#x27;);

// compile
var fn = jade.compile(&#x27;string of jade&#x27;, options);
var html = fn(locals);

// render
var html = jade.<span class="apidocCodeKeywordSpan">render</span>(&#x27;string of jade&#x27;, merge(options, locals));

// renderFile
var html = jade.renderFile(&#x27;filename.jade&#x27;, merge(options, locals));
```

### Options
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.jade.renderFile" id="apidoc.element.jade.jade.renderFile">
        function <span class="apidocSignatureSpan">jade.jade.</span>renderFile
        <span class="apidocSignatureSpan">(path, options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renderFile = function (path, options, fn){
  // support callback API
  if (&#x27;function&#x27; == typeof options) {
    fn = options, options = undefined;
  }
  if (typeof fn === &#x27;function&#x27;) {
    var res
    try {
      res = exports.renderFile(path, options);
    } catch (ex) {
      return fn(ex);
    }
    return fn(null, res);
  }

  options = options || {};

  options.filename = path;
  return handleTemplateCache(options)(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fn = jade.compile(&#x27;string of jade&#x27;, options);
var html = fn(locals);

// render
var html = jade.render(&#x27;string of jade&#x27;, merge(options, locals));

// renderFile
var html = jade.<span class="apidocCodeKeywordSpan">renderFile</span>(&#x27;filename.jade&#x27;, merge(options, locals));
```

### Options

- `filename`  Used in exceptions, and required when using includes
- `compileDebug`  When `false` no debug instrumentation is compiled
- `pretty`    Add pretty-indentation whitespace to output _(false by default)_
...</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes" id="apidoc.module.jade.nodes">module jade.nodes</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Block" id="apidoc.element.jade.nodes.Block">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Block
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Block(node){
  this.nodes = [];
  if (node) this.push(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *   &#x27;:&#x27; expr
 * | block
 */

parseBlockExpansion: function(){
  if (&#x27;:&#x27; == this.peek().type) {
    this.advance();
    return new nodes.<span class="apidocCodeKeywordSpan">Block</span>(this.parseExpr());
  } else {
    return this.block();
  }
},

/**
 * case
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.BlockComment" id="apidoc.element.jade.nodes.BlockComment">
        function <span class="apidocSignatureSpan">jade.nodes.</span>BlockComment
        <span class="apidocSignatureSpan">(val, block, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BlockComment(val, block, buffer) {
  this.block = block;
  this.val = val;
  this.buffer = buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

parseComment: function(){
  var tok = this.expect(&#x27;comment&#x27;);
  var node;

  var block;
  if (block = this.parseTextBlock()) {
    node = new nodes.<span class="apidocCodeKeywordSpan">BlockComment</span>(tok.val, block, tok.buffer);
  } else {
    node = new nodes.Comment(tok.val, tok.buffer);
  }

  node.line = this.line();
  return node;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Case" id="apidoc.element.jade.nodes.Case">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Case
        <span class="apidocSignatureSpan">(expr, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Case(expr, block){
  this.expr = expr;
  this.block = block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
   * case
   */

  parseCase: function(){
var val = this.expect(&#x27;case&#x27;).val;
var node = new nodes.<span class="apidocCodeKeywordSpan">Case</span>(val);
node.line = this.line();

var block = new nodes.Block;
block.line = this.line();
block.filename = this.filename;
this.expect(&#x27;indent&#x27;);
while (&#x27;outdent&#x27; != this.peek().type) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Code" id="apidoc.element.jade.nodes.Code">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Code
        <span class="apidocSignatureSpan">(val, buffer, escape)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Code(val, buffer, escape) {
  this.val = val;
  this.buffer = buffer;
  this.escape = escape;
  if (val.match(/^ *else/)) this.debug = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
   * code
   */

  parseCode: function(afterIf){
var tok = this.expect(&#x27;code&#x27;);
var node = new nodes.<span class="apidocCodeKeywordSpan">Code</span>(tok.val, tok.buffer, tok.escape);
var block;
node.line = this.line();

// throw an error if an else does not have an if
if (tok.isElse &#x26;&#x26; !tok.hasIf) {
  throw new Error(&#x27;Unexpected else without if&#x27;);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Comment" id="apidoc.element.jade.nodes.Comment">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Comment
        <span class="apidocSignatureSpan">(val, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Comment(val, buffer) {
  this.val = val;
  this.buffer = buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var tok = this.expect(&#x27;comment&#x27;);
  var node;

  var block;
  if (block = this.parseTextBlock()) {
    node = new nodes.BlockComment(tok.val, block, tok.buffer);
  } else {
    node = new nodes.<span class="apidocCodeKeywordSpan">Comment</span>(tok.val, tok.buffer);
  }

  node.line = this.line();
  return node;
},

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Doctype" id="apidoc.element.jade.nodes.Doctype">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Doctype
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Doctype(val) {
  this.val = val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * doctype
 */

parseDoctype: function(){
  var tok = this.expect(&#x27;doctype&#x27;);
  var node = new nodes.<span class="apidocCodeKeywordSpan">Doctype</span>(tok.val);
  node.line = this.line();
  return node;
},

/**
 * filter attrs? text-block
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Each" id="apidoc.element.jade.nodes.Each">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Each
        <span class="apidocSignatureSpan">(obj, val, key, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Each(obj, val, key, block) {
  this.obj = obj;
  this.val = val;
  this.key = key;
  this.block = block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * each block
 */

parseEach: function(){
  var tok = this.expect(&#x27;each&#x27;);
  var node = new nodes.<span class="apidocCodeKeywordSpan">Each</span>(tok.code, tok.val, tok.key);
  node.line = this.line();
  node.block = this.block();
  if (this.peek().type == &#x27;code&#x27; &#x26;&#x26; this.peek().val == &#x27;else&#x27;) {
    this.advance();
    node.alternative = this.block();
  }
  return node;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Filter" id="apidoc.element.jade.nodes.Filter">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Filter
        <span class="apidocSignatureSpan">(name, block, attrs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Filter(name, block, attrs) {
  this.name = name;
  this.block = block;
  this.attrs = attrs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var options = {};
  if (attrs) {
    attrs.attrs.forEach(function (attribute) {
      options[attribute.name] = constantinople.toConstant(attribute.val);
    });
  }

  var node = new nodes.<span class="apidocCodeKeywordSpan">Filter</span>(tok.val, block, options);
  node.line = this.line();
  return node;
},

/**
 * each block
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Literal" id="apidoc.element.jade.nodes.Literal">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Literal
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Literal(str) {
  this.str = str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  parser.blocks = this.blocks;
  parser.included = this.included;
  parser.contexts = this.contexts;
  this.extending = parser;

  // TODO: null node
  return new nodes.<span class="apidocCodeKeywordSpan">Literal</span>(&#x27;&#x27;);
},

/**
 * &#x27;block&#x27; name block
 */

parseBlock: function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Mixin" id="apidoc.element.jade.nodes.Mixin">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Mixin
        <span class="apidocSignatureSpan">(name, args, block, call)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Mixin(name, args, block, call){
  Attrs.call(this);
  this.name = name;
  this.args = args;
  this.block = block;
  this.call = call;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * call ident block
   */

  parseCall: function(){
var tok = this.expect(&#x27;call&#x27;);
var name = tok.val;
var args = tok.args;
var mixin = new nodes.<span class="apidocCodeKeywordSpan">Mixin</span>(name, args, new nodes.Block, true);

this.tag(mixin);
if (mixin.code) {
  mixin.block.push(mixin.code);
  mixin.code = null;
}
if (mixin.block.isEmpty()) mixin.block = null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.MixinBlock" id="apidoc.element.jade.nodes.MixinBlock">
        function <span class="apidocSignatureSpan">jade.nodes.</span>MixinBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MixinBlock(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

parseMixinBlock: function () {
  var block = this.expect(&#x27;mixin-block&#x27;);
  if (!this.inMixin) {
    throw new Error(&#x27;Anonymous blocks are not allowed unless they are part of a mixin.&#x27;);
  }
  return new nodes.<span class="apidocCodeKeywordSpan">MixinBlock</span>();
},

/**
 * include block?
 */

parseInclude: function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Node" id="apidoc.element.jade.nodes.Node">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Node
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Node(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Tag" id="apidoc.element.jade.nodes.Tag">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Tag
        <span class="apidocSignatureSpan">(name, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Tag(name, block) {
  Attrs.call(this);
  this.name = name;
  this.block = block || new Block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * interpolation (attrs | class | id)* (text | code | &#x27;:&#x27;)? newline* block?
 */

parseInterpolation: function(){
  var tok = this.advance();
  var tag = new nodes.<span class="apidocCodeKeywordSpan">Tag</span>(tok.val);
  tag.buffer = true;
  return this.tag(tag);
},

/**
 * tag (attrs | class | id)* (text | code | &#x27;:&#x27;)? newline* block?
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Text" id="apidoc.element.jade.nodes.Text">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Text
        <span class="apidocSignatureSpan">(line)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Text(line) {
  this.val = line;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  parseInlineTagsInText: function (str) {
var line = this.line();

var match = /(\\)?#\[((?:.|\n)*)$/.exec(str);
if (match) {
  if (match[1]) { // escape
    var text = new nodes.<span class="apidocCodeKeywordSpan">Text</span>(str.substr(0, match.index) + &#x27;#[&#x27;);
    text.line = line;
    var rest = this.parseInlineTagsInText(match[2]);
    if (rest[0].type === &#x27;Text&#x27;) {
      text.val += rest[0].val;
      rest.shift();
    }
    return [text].concat(rest);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Block" id="apidoc.module.jade.nodes.Block">module jade.nodes.Block</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Block.Block" id="apidoc.element.jade.nodes.Block.Block">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Block
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Block(node){
  this.nodes = [];
  if (node) this.push(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *   &#x27;:&#x27; expr
 * | block
 */

parseBlockExpansion: function(){
  if (&#x27;:&#x27; == this.peek().type) {
    this.advance();
    return new nodes.<span class="apidocCodeKeywordSpan">Block</span>(this.parseExpr());
  } else {
    return this.block();
  }
},

/**
 * case
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Block.prototype" id="apidoc.module.jade.nodes.Block.prototype">module jade.nodes.Block.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.jade.nodes.Block.prototype.clone" id="apidoc.element.jade.nodes.Block.prototype.clone">
        function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function (){
  var err = new Error(&#x27;block.clone is deprecated and will be removed in v2.0.0&#x27;);
  console.warn(err.stack);

  var clone = new Block;
  for (var i = 0, len = this.nodes.length; i &#x3c; len; ++i) {
    clone.push(this.nodes[i].clone());
  }
  return clone;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Block.prototype.clone = function(){
  var err = new Error(&#x27;block.clone is deprecated and will be removed in v2.0.0&#x27;);
  console.warn(err.stack);

  var clone = new Block;
  for (var i = 0, len = this.nodes.length; i &#x3c; len; ++i) {
    clone.push(this.nodes[i].<span class="apidocCodeKeywordSpan">clone</span>());
  }
  return clone;
};

},{&#x22;./node&#x22;:20}],10:[function(require,module,exports){
&#x27;use strict&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Block.prototype.constructor" id="apidoc.element.jade.nodes.Block.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>constructor
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Block(node){
  this.nodes = [];
  if (node) this.push(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require(&#x27;fs&#x27;);

var path = this.resolvePath(this.expect(&#x27;extends&#x27;).val.trim(), &#x27;extends&#x27;);
if (&#x27;.jade&#x27; != path.substr(-5)) path += &#x27;.jade&#x27;;

this.dependencies.push(path);
var str = fs.readFileSync(path, &#x27;utf8&#x27;);
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Block.prototype.includeBlock" id="apidoc.element.jade.nodes.Block.prototype.includeBlock">
        function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>includeBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">includeBlock = function (){
  var ret = this
    , node;

  for (var i = 0, len = this.nodes.length; i &#x3c; len; ++i) {
    node = this.nodes[i];
    if (node.yield) return node;
    else if (node.textOnly) continue;
    else if (node.includeBlock) ret = node.includeBlock();
    else if (node.block &#x26;&#x26; !node.block.isEmpty()) ret = node.block.includeBlock();
    if (ret.yield) return ret;
  }

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var ret = this
    , node;

  for (var i = 0, len = this.nodes.length; i &#x3c; len; ++i) {
    node = this.nodes[i];
    if (node.yield) return node;
    else if (node.textOnly) continue;
    else if (node.includeBlock) ret = node.<span class="apidocCodeKeywordSpan">includeBlock</span>();
    else if (node.block &#x26;&#x26; !node.block.isEmpty()) ret = node.block.includeBlock();
    if (ret.yield) return ret;
  }

  return ret;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Block.prototype.isEmpty" id="apidoc.element.jade.nodes.Block.prototype.isEmpty">
        function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmpty = function (){
  return 0 == this.nodes.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    , node;

  for (var i = 0, len = this.nodes.length; i &#x3c; len; ++i) {
    node = this.nodes[i];
    if (node.yield) return node;
    else if (node.textOnly) continue;
    else if (node.includeBlock) ret = node.includeBlock();
    else if (node.block &#x26;&#x26; !node.block.<span class="apidocCodeKeywordSpan">isEmpty</span>()) ret = node.block.includeBlock
();
    if (ret.yield) return ret;
  }

  return ret;
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Block.prototype.push" id="apidoc.element.jade.nodes.Block.prototype.push">
        function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>push
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (node){
  return this.nodes.push(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var globals = [];

if (options.globals) {
  globals = options.globals.slice();
}

globals.<span class="apidocCodeKeywordSpan">push</span>(&#x27;jade&#x27;);
globals.push(&#x27;jade_mixins&#x27;);
globals.push(&#x27;jade_interp&#x27;);
globals.push(&#x27;jade_debug&#x27;);
globals.push(&#x27;buf&#x27;);

var body = &#x27;&#x27;
  + &#x27;var buf = [];\n&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Block.prototype.replace" id="apidoc.element.jade.nodes.Block.prototype.replace">
        function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>replace
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (other){
  var err = new Error(&#x27;block.replace is deprecated and will be removed in v2.0.0&#x27;);
  console.warn(err.stack);

  other.nodes = this.nodes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    throw err;
  }
}

// Debug compiler
if (options.debug) {
  console.error(&#x27;\nCompiled Function:\n\n\u001b[90m%s\u001b[0m&#x27;, js.<span class="apidocCodeKeywordSpan">replace</span>(/^/
gm, &#x27;  &#x27;));
}

var globals = [];

if (options.globals) {
  globals = options.globals.slice();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Block.prototype.unshift" id="apidoc.element.jade.nodes.Block.prototype.unshift">
        function <span class="apidocSignatureSpan">jade.nodes.Block.prototype.</span>unshift
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unshift = function (node){
  return this.nodes.unshift(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @api public
   */

  visit: function(node){
var debug = this.debug;

if (debug) {
  this.buf.push(&#x27;jade_debug.<span class="apidocCodeKeywordSpan">unshift</span>(new jade.DebugItem( &#x27; + node.line
    + &#x27;, &#x27; + (node.filename
      ? utils.stringify(node.filename)
      : &#x27;jade_debug[0].filename&#x27;)
    + &#x27; ));&#x27;);
}

// Massive hack to fix our context
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.BlockComment" id="apidoc.module.jade.nodes.BlockComment">module jade.nodes.BlockComment</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.BlockComment.BlockComment" id="apidoc.element.jade.nodes.BlockComment.BlockComment">
        function <span class="apidocSignatureSpan">jade.nodes.</span>BlockComment
        <span class="apidocSignatureSpan">(val, block, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BlockComment(val, block, buffer) {
  this.block = block;
  this.val = val;
  this.buffer = buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

parseComment: function(){
  var tok = this.expect(&#x27;comment&#x27;);
  var node;

  var block;
  if (block = this.parseTextBlock()) {
    node = new nodes.<span class="apidocCodeKeywordSpan">BlockComment</span>(tok.val, block, tok.buffer);
  } else {
    node = new nodes.Comment(tok.val, tok.buffer);
  }

  node.line = this.line();
  return node;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.BlockComment.prototype" id="apidoc.module.jade.nodes.BlockComment.prototype">module jade.nodes.BlockComment.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.BlockComment.prototype.constructor" id="apidoc.element.jade.nodes.BlockComment.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.BlockComment.prototype.</span>constructor
        <span class="apidocSignatureSpan">(val, block, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BlockComment(val, block, buffer) {
  this.block = block;
  this.val = val;
  this.buffer = buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require(&#x27;fs&#x27;);

var path = this.resolvePath(this.expect(&#x27;extends&#x27;).val.trim(), &#x27;extends&#x27;);
if (&#x27;.jade&#x27; != path.substr(-5)) path += &#x27;.jade&#x27;;

this.dependencies.push(path);
var str = fs.readFileSync(path, &#x27;utf8&#x27;);
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Case" id="apidoc.module.jade.nodes.Case">module jade.nodes.Case</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Case.Case" id="apidoc.element.jade.nodes.Case.Case">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Case
        <span class="apidocSignatureSpan">(expr, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Case(expr, block){
  this.expr = expr;
  this.block = block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
   * case
   */

  parseCase: function(){
var val = this.expect(&#x27;case&#x27;).val;
var node = new nodes.<span class="apidocCodeKeywordSpan">Case</span>(val);
node.line = this.line();

var block = new nodes.Block;
block.line = this.line();
block.filename = this.filename;
this.expect(&#x27;indent&#x27;);
while (&#x27;outdent&#x27; != this.peek().type) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Case.When" id="apidoc.element.jade.nodes.Case.When">
        function <span class="apidocSignatureSpan">jade.nodes.Case.</span>When
        <span class="apidocSignatureSpan">(expr, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function When(expr, block){
  this.expr = expr;
  this.block = block;
  this.debug = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * when
 */

parseWhen: function(){
  var val = this.expect(&#x27;when&#x27;).val;
  if (this.peek().type !== &#x27;newline&#x27;)
    return new nodes.Case.<span class="apidocCodeKeywordSpan">When</span>(val, this.parseBlockExpansion());
  else
    return new nodes.Case.When(val);
},

/**
 * default
 */
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Case.When.prototype" id="apidoc.module.jade.nodes.Case.When.prototype">module jade.nodes.Case.When.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Case.When.prototype.constructor" id="apidoc.element.jade.nodes.Case.When.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.Case.When.prototype.</span>constructor
        <span class="apidocSignatureSpan">(expr, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function When(expr, block){
  this.expr = expr;
  this.block = block;
  this.debug = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require(&#x27;fs&#x27;);

var path = this.resolvePath(this.expect(&#x27;extends&#x27;).val.trim(), &#x27;extends&#x27;);
if (&#x27;.jade&#x27; != path.substr(-5)) path += &#x27;.jade&#x27;;

this.dependencies.push(path);
var str = fs.readFileSync(path, &#x27;utf8&#x27;);
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Case.prototype" id="apidoc.module.jade.nodes.Case.prototype">module jade.nodes.Case.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Case.prototype.constructor" id="apidoc.element.jade.nodes.Case.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.Case.prototype.</span>constructor
        <span class="apidocSignatureSpan">(expr, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Case(expr, block){
  this.expr = expr;
  this.block = block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require(&#x27;fs&#x27;);

var path = this.resolvePath(this.expect(&#x27;extends&#x27;).val.trim(), &#x27;extends&#x27;);
if (&#x27;.jade&#x27; != path.substr(-5)) path += &#x27;.jade&#x27;;

this.dependencies.push(path);
var str = fs.readFileSync(path, &#x27;utf8&#x27;);
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Code" id="apidoc.module.jade.nodes.Code">module jade.nodes.Code</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Code.Code" id="apidoc.element.jade.nodes.Code.Code">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Code
        <span class="apidocSignatureSpan">(val, buffer, escape)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Code(val, buffer, escape) {
  this.val = val;
  this.buffer = buffer;
  this.escape = escape;
  if (val.match(/^ *else/)) this.debug = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
   * code
   */

  parseCode: function(afterIf){
var tok = this.expect(&#x27;code&#x27;);
var node = new nodes.<span class="apidocCodeKeywordSpan">Code</span>(tok.val, tok.buffer, tok.escape);
var block;
node.line = this.line();

// throw an error if an else does not have an if
if (tok.isElse &#x26;&#x26; !tok.hasIf) {
  throw new Error(&#x27;Unexpected else without if&#x27;);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Code.prototype" id="apidoc.module.jade.nodes.Code.prototype">module jade.nodes.Code.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Code.prototype.constructor" id="apidoc.element.jade.nodes.Code.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.Code.prototype.</span>constructor
        <span class="apidocSignatureSpan">(val, buffer, escape)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Code(val, buffer, escape) {
  this.val = val;
  this.buffer = buffer;
  this.escape = escape;
  if (val.match(/^ *else/)) this.debug = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require(&#x27;fs&#x27;);

var path = this.resolvePath(this.expect(&#x27;extends&#x27;).val.trim(), &#x27;extends&#x27;);
if (&#x27;.jade&#x27; != path.substr(-5)) path += &#x27;.jade&#x27;;

this.dependencies.push(path);
var str = fs.readFileSync(path, &#x27;utf8&#x27;);
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Comment" id="apidoc.module.jade.nodes.Comment">module jade.nodes.Comment</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Comment.Comment" id="apidoc.element.jade.nodes.Comment.Comment">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Comment
        <span class="apidocSignatureSpan">(val, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Comment(val, buffer) {
  this.val = val;
  this.buffer = buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var tok = this.expect(&#x27;comment&#x27;);
  var node;

  var block;
  if (block = this.parseTextBlock()) {
    node = new nodes.BlockComment(tok.val, block, tok.buffer);
  } else {
    node = new nodes.<span class="apidocCodeKeywordSpan">Comment</span>(tok.val, tok.buffer);
  }

  node.line = this.line();
  return node;
},

/**
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Comment.prototype" id="apidoc.module.jade.nodes.Comment.prototype">module jade.nodes.Comment.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Comment.prototype.constructor" id="apidoc.element.jade.nodes.Comment.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.Comment.prototype.</span>constructor
        <span class="apidocSignatureSpan">(val, buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Comment(val, buffer) {
  this.val = val;
  this.buffer = buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require(&#x27;fs&#x27;);

var path = this.resolvePath(this.expect(&#x27;extends&#x27;).val.trim(), &#x27;extends&#x27;);
if (&#x27;.jade&#x27; != path.substr(-5)) path += &#x27;.jade&#x27;;

this.dependencies.push(path);
var str = fs.readFileSync(path, &#x27;utf8&#x27;);
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Doctype" id="apidoc.module.jade.nodes.Doctype">module jade.nodes.Doctype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Doctype.Doctype" id="apidoc.element.jade.nodes.Doctype.Doctype">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Doctype
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Doctype(val) {
  this.val = val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * doctype
 */

parseDoctype: function(){
  var tok = this.expect(&#x27;doctype&#x27;);
  var node = new nodes.<span class="apidocCodeKeywordSpan">Doctype</span>(tok.val);
  node.line = this.line();
  return node;
},

/**
 * filter attrs? text-block
 */
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Doctype.prototype" id="apidoc.module.jade.nodes.Doctype.prototype">module jade.nodes.Doctype.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Doctype.prototype.constructor" id="apidoc.element.jade.nodes.Doctype.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.Doctype.prototype.</span>constructor
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Doctype(val) {
  this.val = val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require(&#x27;fs&#x27;);

var path = this.resolvePath(this.expect(&#x27;extends&#x27;).val.trim(), &#x27;extends&#x27;);
if (&#x27;.jade&#x27; != path.substr(-5)) path += &#x27;.jade&#x27;;

this.dependencies.push(path);
var str = fs.readFileSync(path, &#x27;utf8&#x27;);
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Each" id="apidoc.module.jade.nodes.Each">module jade.nodes.Each</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Each.Each" id="apidoc.element.jade.nodes.Each.Each">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Each
        <span class="apidocSignatureSpan">(obj, val, key, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Each(obj, val, key, block) {
  this.obj = obj;
  this.val = val;
  this.key = key;
  this.block = block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * each block
 */

parseEach: function(){
  var tok = this.expect(&#x27;each&#x27;);
  var node = new nodes.<span class="apidocCodeKeywordSpan">Each</span>(tok.code, tok.val, tok.key);
  node.line = this.line();
  node.block = this.block();
  if (this.peek().type == &#x27;code&#x27; &#x26;&#x26; this.peek().val == &#x27;else&#x27;) {
    this.advance();
    node.alternative = this.block();
  }
  return node;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Each.prototype" id="apidoc.module.jade.nodes.Each.prototype">module jade.nodes.Each.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Each.prototype.constructor" id="apidoc.element.jade.nodes.Each.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.Each.prototype.</span>constructor
        <span class="apidocSignatureSpan">(obj, val, key, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Each(obj, val, key, block) {
  this.obj = obj;
  this.val = val;
  this.key = key;
  this.block = block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require(&#x27;fs&#x27;);

var path = this.resolvePath(this.expect(&#x27;extends&#x27;).val.trim(), &#x27;extends&#x27;);
if (&#x27;.jade&#x27; != path.substr(-5)) path += &#x27;.jade&#x27;;

this.dependencies.push(path);
var str = fs.readFileSync(path, &#x27;utf8&#x27;);
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Filter" id="apidoc.module.jade.nodes.Filter">module jade.nodes.Filter</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Filter.Filter" id="apidoc.element.jade.nodes.Filter.Filter">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Filter
        <span class="apidocSignatureSpan">(name, block, attrs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Filter(name, block, attrs) {
  this.name = name;
  this.block = block;
  this.attrs = attrs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var options = {};
  if (attrs) {
    attrs.attrs.forEach(function (attribute) {
      options[attribute.name] = constantinople.toConstant(attribute.val);
    });
  }

  var node = new nodes.<span class="apidocCodeKeywordSpan">Filter</span>(tok.val, block, options);
  node.line = this.line();
  return node;
},

/**
 * each block
 */
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Filter.prototype" id="apidoc.module.jade.nodes.Filter.prototype">module jade.nodes.Filter.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Filter.prototype.constructor" id="apidoc.element.jade.nodes.Filter.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.Filter.prototype.</span>constructor
        <span class="apidocSignatureSpan">(name, block, attrs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Filter(name, block, attrs) {
  this.name = name;
  this.block = block;
  this.attrs = attrs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require(&#x27;fs&#x27;);

var path = this.resolvePath(this.expect(&#x27;extends&#x27;).val.trim(), &#x27;extends&#x27;);
if (&#x27;.jade&#x27; != path.substr(-5)) path += &#x27;.jade&#x27;;

this.dependencies.push(path);
var str = fs.readFileSync(path, &#x27;utf8&#x27;);
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Literal" id="apidoc.module.jade.nodes.Literal">module jade.nodes.Literal</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Literal.Literal" id="apidoc.element.jade.nodes.Literal.Literal">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Literal
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Literal(str) {
  this.str = str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  parser.blocks = this.blocks;
  parser.included = this.included;
  parser.contexts = this.contexts;
  this.extending = parser;

  // TODO: null node
  return new nodes.<span class="apidocCodeKeywordSpan">Literal</span>(&#x27;&#x27;);
},

/**
 * &#x27;block&#x27; name block
 */

parseBlock: function(){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Literal.prototype" id="apidoc.module.jade.nodes.Literal.prototype">module jade.nodes.Literal.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Literal.prototype.constructor" id="apidoc.element.jade.nodes.Literal.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.Literal.prototype.</span>constructor
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Literal(str) {
  this.str = str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require(&#x27;fs&#x27;);

var path = this.resolvePath(this.expect(&#x27;extends&#x27;).val.trim(), &#x27;extends&#x27;);
if (&#x27;.jade&#x27; != path.substr(-5)) path += &#x27;.jade&#x27;;

this.dependencies.push(path);
var str = fs.readFileSync(path, &#x27;utf8&#x27;);
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Mixin" id="apidoc.module.jade.nodes.Mixin">module jade.nodes.Mixin</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Mixin.Mixin" id="apidoc.element.jade.nodes.Mixin.Mixin">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Mixin
        <span class="apidocSignatureSpan">(name, args, block, call)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Mixin(name, args, block, call){
  Attrs.call(this);
  this.name = name;
  this.args = args;
  this.block = block;
  this.call = call;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * call ident block
   */

  parseCall: function(){
var tok = this.expect(&#x27;call&#x27;);
var name = tok.val;
var args = tok.args;
var mixin = new nodes.<span class="apidocCodeKeywordSpan">Mixin</span>(name, args, new nodes.Block, true);

this.tag(mixin);
if (mixin.code) {
  mixin.block.push(mixin.code);
  mixin.code = null;
}
if (mixin.block.isEmpty()) mixin.block = null;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Mixin.prototype" id="apidoc.module.jade.nodes.Mixin.prototype">module jade.nodes.Mixin.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Mixin.prototype.constructor" id="apidoc.element.jade.nodes.Mixin.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.Mixin.prototype.</span>constructor
        <span class="apidocSignatureSpan">(name, args, block, call)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Mixin(name, args, block, call){
  Attrs.call(this);
  this.name = name;
  this.args = args;
  this.block = block;
  this.call = call;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require(&#x27;fs&#x27;);

var path = this.resolvePath(this.expect(&#x27;extends&#x27;).val.trim(), &#x27;extends&#x27;);
if (&#x27;.jade&#x27; != path.substr(-5)) path += &#x27;.jade&#x27;;

this.dependencies.push(path);
var str = fs.readFileSync(path, &#x27;utf8&#x27;);
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.MixinBlock" id="apidoc.module.jade.nodes.MixinBlock">module jade.nodes.MixinBlock</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.MixinBlock.MixinBlock" id="apidoc.element.jade.nodes.MixinBlock.MixinBlock">
        function <span class="apidocSignatureSpan">jade.nodes.</span>MixinBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MixinBlock(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

parseMixinBlock: function () {
  var block = this.expect(&#x27;mixin-block&#x27;);
  if (!this.inMixin) {
    throw new Error(&#x27;Anonymous blocks are not allowed unless they are part of a mixin.&#x27;);
  }
  return new nodes.<span class="apidocCodeKeywordSpan">MixinBlock</span>();
},

/**
 * include block?
 */

parseInclude: function(){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.MixinBlock.prototype" id="apidoc.module.jade.nodes.MixinBlock.prototype">module jade.nodes.MixinBlock.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.MixinBlock.prototype.constructor" id="apidoc.element.jade.nodes.MixinBlock.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.MixinBlock.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MixinBlock(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require(&#x27;fs&#x27;);

var path = this.resolvePath(this.expect(&#x27;extends&#x27;).val.trim(), &#x27;extends&#x27;);
if (&#x27;.jade&#x27; != path.substr(-5)) path += &#x27;.jade&#x27;;

this.dependencies.push(path);
var str = fs.readFileSync(path, &#x27;utf8&#x27;);
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Node" id="apidoc.module.jade.nodes.Node">module jade.nodes.Node</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Node.Node" id="apidoc.element.jade.nodes.Node.Node">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Node
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Node(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Node.prototype" id="apidoc.module.jade.nodes.Node.prototype">module jade.nodes.Node.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Node.prototype.clone" id="apidoc.element.jade.nodes.Node.prototype.clone">
        function <span class="apidocSignatureSpan">jade.nodes.Node.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function (){
  var err = new Error(&#x27;node.clone is deprecated and will be removed in v2.0.0&#x27;);
  console.warn(err.stack);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Block.prototype.clone = function(){
  var err = new Error(&#x27;block.clone is deprecated and will be removed in v2.0.0&#x27;);
  console.warn(err.stack);

  var clone = new Block;
  for (var i = 0, len = this.nodes.length; i &#x3c; len; ++i) {
    clone.push(this.nodes[i].<span class="apidocCodeKeywordSpan">clone</span>());
  }
  return clone;
};

},{&#x22;./node&#x22;:20}],10:[function(require,module,exports){
&#x27;use strict&#x27;;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Tag" id="apidoc.module.jade.nodes.Tag">module jade.nodes.Tag</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Tag.Tag" id="apidoc.element.jade.nodes.Tag.Tag">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Tag
        <span class="apidocSignatureSpan">(name, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Tag(name, block) {
  Attrs.call(this);
  this.name = name;
  this.block = block || new Block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * interpolation (attrs | class | id)* (text | code | &#x27;:&#x27;)? newline* block?
 */

parseInterpolation: function(){
  var tok = this.advance();
  var tag = new nodes.<span class="apidocCodeKeywordSpan">Tag</span>(tok.val);
  tag.buffer = true;
  return this.tag(tag);
},

/**
 * tag (attrs | class | id)* (text | code | &#x27;:&#x27;)? newline* block?
 */
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Tag.prototype" id="apidoc.module.jade.nodes.Tag.prototype">module jade.nodes.Tag.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Tag.prototype.canInline" id="apidoc.element.jade.nodes.Tag.prototype.canInline">
        function <span class="apidocSignatureSpan">jade.nodes.Tag.prototype.</span>canInline
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">canInline = function (){
  var nodes = this.block.nodes;

  function isInline(node){
    // Recurse if the node is a block
    if (node.isBlock) return node.nodes.every(isInline);
    return node.isText || (node.isInline &#x26;&#x26; node.isInline());
  }

  // Empty tag
  if (!nodes.length) return true;

  // Text-only or inline-only tag
  if (1 == nodes.length) return isInline(nodes[0]);

  // Multi-line inline-only tag
  if (this.block.nodes.every(isInline)) {
    for (var i = 1, len = nodes.length; i &#x3c; len; ++i) {
      if (nodes[i-1].isText &#x26;&#x26; nodes[i].isText)
        return false;
    }
    return true;
  }

  // Mixed tag
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  bufferName();
  this.visitAttributes(tag.attrs, tag.attributeBlocks.slice());
  this.buffer(&#x27;&#x3e;&#x27;);
  if (tag.code) this.visitCode(tag.code);
  this.visit(tag.block);

  // pretty print
  if (pp &#x26;&#x26; !tag.isInline() &#x26;&#x26; &#x27;pre&#x27; != tag.name &#x26;&#x26; !tag.<span class="apidocCodeKeywordSpan
">canInline</span>())
    this.prettyIndent(0, true);

  this.buffer(&#x27;&#x3c;/&#x27;);
  bufferName();
  this.buffer(&#x27;&#x3e;&#x27;);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Tag.prototype.clone" id="apidoc.element.jade.nodes.Tag.prototype.clone">
        function <span class="apidocSignatureSpan">jade.nodes.Tag.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function (){
  var err = new Error(&#x27;tag.clone is deprecated and will be removed in v2.0.0&#x27;);
  console.warn(err.stack);

  var clone = new Tag(this.name, this.block.clone());
  clone.line = this.line;
  clone.attrs = this.attrs;
  clone.textOnly = this.textOnly;
  return clone;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Block.prototype.clone = function(){
  var err = new Error(&#x27;block.clone is deprecated and will be removed in v2.0.0&#x27;);
  console.warn(err.stack);

  var clone = new Block;
  for (var i = 0, len = this.nodes.length; i &#x3c; len; ++i) {
    clone.push(this.nodes[i].<span class="apidocCodeKeywordSpan">clone</span>());
  }
  return clone;
};

},{&#x22;./node&#x22;:20}],10:[function(require,module,exports){
&#x27;use strict&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Tag.prototype.constructor" id="apidoc.element.jade.nodes.Tag.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.Tag.prototype.</span>constructor
        <span class="apidocSignatureSpan">(name, block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Tag(name, block) {
  Attrs.call(this);
  this.name = name;
  this.block = block || new Block;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require(&#x27;fs&#x27;);

var path = this.resolvePath(this.expect(&#x27;extends&#x27;).val.trim(), &#x27;extends&#x27;);
if (&#x27;.jade&#x27; != path.substr(-5)) path += &#x27;.jade&#x27;;

this.dependencies.push(path);
var str = fs.readFileSync(path, &#x27;utf8&#x27;);
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.nodes.Tag.prototype.isInline" id="apidoc.element.jade.nodes.Tag.prototype.isInline">
        function <span class="apidocSignatureSpan">jade.nodes.Tag.prototype.</span>isInline
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInline = function (){
  return ~inlineTags.indexOf(this.name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!this.hasCompiledDoctype &#x26;&#x26; &#x27;html&#x27; == name) {
    this.visitDoctype();
  }
  this.hasCompiledTag = true;
}

// pretty print
if (pp &#x26;&#x26; !tag.<span class="apidocCodeKeywordSpan">isInline</span>())
  this.prettyIndent(0, true);

if (tag.selfClosing || (!this.xml &#x26;&#x26; selfClosing[tag.name])) {
  this.buffer(&#x27;&#x3c;&#x27;);
  bufferName();
  this.visitAttributes(tag.attrs, tag.attributeBlocks.slice());
  this.terse
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Text" id="apidoc.module.jade.nodes.Text">module jade.nodes.Text</a></h1>


    <h2>
        <a href="#apidoc.element.jade.nodes.Text.Text" id="apidoc.element.jade.nodes.Text.Text">
        function <span class="apidocSignatureSpan">jade.nodes.</span>Text
        <span class="apidocSignatureSpan">(line)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Text(line) {
  this.val = line;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  parseInlineTagsInText: function (str) {
var line = this.line();

var match = /(\\)?#\[((?:.|\n)*)$/.exec(str);
if (match) {
  if (match[1]) { // escape
    var text = new nodes.<span class="apidocCodeKeywordSpan">Text</span>(str.substr(0, match.index) + &#x27;#[&#x27;);
    text.line = line;
    var rest = this.parseInlineTagsInText(match[2]);
    if (rest[0].type === &#x27;Text&#x27;) {
      text.val += rest[0].val;
      rest.shift();
    }
    return [text].concat(rest);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.nodes.Text.prototype" id="apidoc.module.jade.nodes.Text.prototype">module jade.nodes.Text.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.jade.nodes.Text.prototype.constructor" id="apidoc.element.jade.nodes.Text.prototype.constructor">
        function <span class="apidocSignatureSpan">jade.nodes.Text.prototype.</span>constructor
        <span class="apidocSignatureSpan">(line)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Text(line) {
  this.val = line;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs = require(&#x27;fs&#x27;);

var path = this.resolvePath(this.expect(&#x27;extends&#x27;).val.trim(), &#x27;extends&#x27;);
if (&#x27;.jade&#x27; != path.substr(-5)) path += &#x27;.jade&#x27;;

this.dependencies.push(path);
var str = fs.readFileSync(path, &#x27;utf8&#x27;);
var parser = new this.<span class="apidocCodeKeywordSpan">constructor</span>(str, path, this.options);
parser.dependencies = this.dependencies;

parser.blocks = this.blocks;
parser.included = this.included;
parser.contexts = this.contexts;
this.extending = parser;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.runtime" id="apidoc.module.jade.runtime">module jade.runtime</a></h1>


    <h2>
        <a href="#apidoc.element.jade.runtime.DebugItem" id="apidoc.element.jade.runtime.DebugItem">
        function <span class="apidocSignatureSpan">jade.runtime.</span>DebugItem
        <span class="apidocSignatureSpan">(lineno, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DebugItem(lineno, filename) {
  this.lineno = lineno;
  this.filename = filename;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  , fn;

str = String(str);

var parsed = parse(str, options);
if (options.compileDebug !== false) {
  fn = [
      &#x27;var jade_debug = [ new jade.<span class="apidocCodeKeywordSpan">DebugItem</span>( 1, &#x27; + filename + &#x27; ) ];&#
x27;
    , &#x27;try {&#x27;
    , parsed.body
    , &#x27;} catch (err) {&#x27;
    , &#x27;  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno&#x27; + (options.compileDebug === true ? &#x27;,&#x27
; + utils.stringify(str) : &#x27;&#x27;) + &#x27;);&#x27;
    , &#x27;}&#x27;
  ].join(&#x27;\n&#x27;);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.runtime.attr" id="apidoc.element.jade.runtime.attr">
        function <span class="apidocSignatureSpan">jade.runtime.</span>attr
        <span class="apidocSignatureSpan">(key, val, escaped, terse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function attr(key, val, escaped, terse) {
  if (key === &#x27;style&#x27;) {
    val = exports.style(val);
  }
  if (&#x27;boolean&#x27; == typeof val || null == val) {
    if (val) {
      return &#x27; &#x27; + (terse ? key : key + &#x27;=&#x22;&#x27; + key + &#x27;&#x22;&#x27;);
    } else {
      return &#x27;&#x27;;
    }
  } else if (0 == key.indexOf(&#x27;data&#x27;) &#x26;&#x26; &#x27;string&#x27; != typeof val) {
    if (JSON.stringify(val).indexOf(&#x27;&#x26;&#x27;) !== -1) {
      console.warn(&#x27;Since Jade 2.0.0, ampersands (`&#x26;`) in data attributes &#x27; +
                   &#x27;will be escaped to `&#x26;amp;`&#x27;);
    };
    if (val &#x26;&#x26; typeof val.toISOString === &#x27;function&#x27;) {
      console.warn(&#x27;Jade will eliminate the double quotes around dates in &#x27; +
                   &#x27;ISO form after 2.0.0&#x27;);
    }
    return &#x27; &#x27; + key + &#x22;=&#x27;&#x22; + JSON.stringify(val).replace(/&#x27;/g, &#x27;&#x26;apos;&#x27;) + &#x22;&#x27;&#x22;;
  } else if (escaped) {
    if (val &#x26;&#x26; typeof val.toISOString === &#x27;function&#x27;) {
      console.warn(&#x27;Jade will stringify dates in ISO form after 2.0.0&#x27;);
    }
    return &#x27; &#x27; + key + &#x27;=&#x22;&#x27; + exports.escape(val) + &#x27;&#x22;&#x27;;
  } else {
    if (val &#x26;&#x26; typeof val.toISOString === &#x27;function&#x27;) {
      console.warn(&#x27;Jade will stringify dates in ISO form after 2.0.0&#x27;);
    }
    return &#x27; &#x27; + key + &#x27;=&#x22;&#x27; + val + &#x27;&#x22;&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var escaped = attr.escaped;

if (key === &#x27;class&#x27;) {
  classes.push(attr.val);
  classEscaping.push(attr.escaped);
} else if (isConstant(attr.val)) {
  if (buffer) {
    this.buffer(runtime.<span class="apidocCodeKeywordSpan">attr</span>(key, toConstant(attr.val), escaped, this.terse));
  } else {
    var val = toConstant(attr.val);
    if (key === &#x27;style&#x27;) val = runtime.style(val);
    if (escaped &#x26;&#x26; !(key.indexOf(&#x27;data&#x27;) === 0 &#x26;&#x26; typeof val !== &#x27;string&#x27;)) {
      val = runtime.escape(val);
    }
    buf.push(utils.stringify(key) + &#x27;: &#x27; + utils.stringify(val));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.runtime.attrs" id="apidoc.element.jade.runtime.attrs">
        function <span class="apidocSignatureSpan">jade.runtime.</span>attrs
        <span class="apidocSignatureSpan">(obj, terse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function attrs(obj, terse){
  var buf = [];

  var keys = Object.keys(obj);

  if (keys.length) {
    for (var i = 0; i &#x3c; keys.length; ++i) {
      var key = keys[i]
        , val = obj[key];

      if (&#x27;class&#x27; == key) {
        if (val = joinClasses(val)) {
          buf.push(&#x27; &#x27; + key + &#x27;=&#x22;&#x27; + val + &#x27;&#x22;&#x27;);
        }
      } else {
        buf.push(exports.attr(key, val, false, terse));
      }
    }
  }

  return buf.join(&#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    this.buf.push(&#x27;}&#x27;);
  }
}

if (attrsBlocks.length) {
  if (attrs.length) {
    var val = this.<span class="apidocCodeKeywordSpan">attrs</span>(attrs);
    attrsBlocks.unshift(val);
  }
  this.buf.push(&#x27;attributes: jade.merge([&#x27; + attrsBlocks.join(&#x27;,&#x27;) + &#x27;])&#x27;);
} else if (attrs.length) {
  var val = this.attrs(attrs);
  this.buf.push(&#x27;attributes: &#x27; + val);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.runtime.cls" id="apidoc.element.jade.runtime.cls">
        function <span class="apidocSignatureSpan">jade.runtime.</span>cls
        <span class="apidocSignatureSpan">(classes, escaped)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cls(classes, escaped) {
  var buf = [];
  for (var i = 0; i &#x3c; classes.length; i++) {
    if (escaped &#x26;&#x26; escaped[i]) {
      buf.push(exports.escape(joinClasses([classes[i]])));
    } else {
      buf.push(joinClasses(classes[i]));
    }
  }
  var text = joinClasses(buf);
  if (text.length) {
    return &#x27; class=&#x22;&#x27; + text + &#x27;&#x22;&#x27;;
  } else {
    return &#x27;&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      buf.push(utils.stringify(key) + &#x27;: &#x27; + val);
    }
  }
}.bind(this));
if (buffer) {
  if (classes.every(isConstant)) {
    this.buffer(runtime.<span class="apidocCodeKeywordSpan">cls</span>(classes.map(toConstant), classEscaping));
  } else {
    this.bufferExpression(&#x27;jade.cls([&#x27; + classes.join(&#x27;,&#x27;) + &#x27;], &#x27; + utils.stringify(classEscaping
) + &#x27;)&#x27;);
  }
} else if (classes.length) {
  if (classes.every(isConstant)) {
    classes = utils.stringify(runtime.joinClasses(classes.map(toConstant).map(runtime.joinClasses).map(function (cls, i) {
      return classEscaping[i] ? runtime.escape(cls) : cls;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.runtime.escape" id="apidoc.element.jade.runtime.escape">
        function <span class="apidocSignatureSpan">jade.runtime.</span>escape
        <span class="apidocSignatureSpan">(html)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function jade_escape(html){
  var result = String(html).replace(jade_match_html, jade_encode_char);
  if (result === &#x27;&#x27; + html) return html;
  else return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// we only wrap unbuffered code blocks ATM
// since they are usually flow control

// Buffer code
if (code.buffer) {
  var val = code.val.trim();
  val = &#x27;null == (jade_interp = &#x27;+val+&#x27;) ? &#x22;&#x22; : jade_interp&#x27;;
  if (code.escape) val = &#x27;jade.<span class="apidocCodeKeywordSpan">escape</span>(&#x27; + val + &#x27;)&#x27;;
  this.bufferExpression(val);
} else {
  this.buf.push(code.val);
}

// Block support
if (code.block) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.runtime.joinClasses" id="apidoc.element.jade.runtime.joinClasses">
        function <span class="apidocSignatureSpan">jade.runtime.</span>joinClasses
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function joinClasses(val) {
  return (Array.isArray(val) ? val.map(joinClasses) :
    (val &#x26;&#x26; typeof val === &#x27;object&#x27;) ? Object.keys(val).filter(function (key) { return val[key]; }) :
    [val]).filter(nulls).join(&#x27; &#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (classes.every(isConstant)) {
    this.buffer(runtime.cls(classes.map(toConstant), classEscaping));
  } else {
    this.bufferExpression(&#x27;jade.cls([&#x27; + classes.join(&#x27;,&#x27;) + &#x27;], &#x27; + utils.stringify(classEscaping
) + &#x27;)&#x27;);
  }
} else if (classes.length) {
  if (classes.every(isConstant)) {
    classes = utils.stringify(runtime.<span class="apidocCodeKeywordSpan">joinClasses</span>(classes.map(toConstant).map(runtime
.joinClasses).map(function (cls, i) {
      return classEscaping[i] ? runtime.escape(cls) : cls;
    })));
  } else {
    classes = &#x27;(jade_interp = &#x27; + utils.stringify(classEscaping) + &#x27;,&#x27; +
      &#x27; jade.joinClasses([&#x27; + classes.join(&#x27;,&#x27;) + &#x27;].map(jade.joinClasses).map(function (cls, i) {&#x27
; +
      &#x27;   return jade_interp[i] ? jade.escape(cls) : cls&#x27; +
      &#x27; }))&#x27; +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.runtime.merge" id="apidoc.element.jade.runtime.merge">
        function <span class="apidocSignatureSpan">jade.runtime.</span>merge
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function merge(a, b) {
  if (arguments.length === 1) {
    var attrs = a[0];
    for (var i = 1; i &#x3c; a.length; i++) {
      attrs = merge(attrs, a[i]);
    }
    return attrs;
  }
  var ac = a[&#x27;class&#x27;];
  var bc = b[&#x27;class&#x27;];

  if (ac || bc) {
    ac = ac || [];
    bc = bc || [];
    if (!Array.isArray(ac)) ac = [ac];
    if (!Array.isArray(bc)) bc = [bc];
    a[&#x27;class&#x27;] = ac.concat(bc).filter(nulls);
  }

  for (var key in b) {
    if (key != &#x27;class&#x27;) {
      a[key] = b[key];
    }
  }

  return a;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (attrsBlocks.length) {
  if (attrs.length) {
    var val = this.attrs(attrs);
    attrsBlocks.unshift(val);
  }
  this.buf.push(&#x27;attributes: jade.<span class="apidocCodeKeywordSpan">merge</span>([&#x27; + attrsBlocks.join(&#x27;,&#x27;) + &#
x27;])&#x27;);
} else if (attrs.length) {
  var val = this.attrs(attrs);
  this.buf.push(&#x27;attributes: &#x27; + val);
}

if (args) {
  this.buf.push(&#x27;}, &#x27; + args + &#x27;);&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.runtime.rethrow" id="apidoc.element.jade.runtime.rethrow">
        function <span class="apidocSignatureSpan">jade.runtime.</span>rethrow
        <span class="apidocSignatureSpan">(err, filename, lineno, str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rethrow(err, filename, lineno, str){
  if (!(err instanceof Error)) throw err;
  if ((typeof window != &#x27;undefined&#x27; || !filename) &#x26;&#x26; !str) {
    err.message += &#x27; on line &#x27; + lineno;
    throw err;
  }
  try {
    str = str || require(&#x27;fs&#x27;).readFileSync(filename, &#x27;utf8&#x27;)
  } catch (ex) {
    rethrow(err, null, lineno)
  }
  var context = 3
    , lines = str.split(&#x27;\n&#x27;)
    , start = Math.max(lineno - context, 0)
    , end = Math.min(lines.length, lineno + context);

  // Error context
  var context = lines.slice(start, end).map(function(line, i){
    var curr = i + start + 1;
    return (curr == lineno ? &#x27;  &#x3e; &#x27; : &#x27;    &#x27;)
      + curr
      + &#x27;| &#x27;
      + line;
  }).join(&#x27;\n&#x27;);

  // Alter exception message
  err.path = filename;
  err.message = (filename || &#x27;Jade&#x27;) + &#x27;:&#x27; + lineno
    + &#x27;\n&#x27; + context + &#x27;\n\n&#x27; + err.message;
  throw err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var parser = new (options.parser || Parser)(str, options.filename, options);
var tokens;
try {
  // Parse
  tokens = parser.parse();
} catch (err) {
  parser = parser.context();
  runtime.<span class="apidocCodeKeywordSpan">rethrow</span>(err, parser.filename, parser.lexer.lineno, parser.input);
}

// Compile
var compiler = new (options.compiler || Compiler)(tokens, options);
var js;
try {
  js = compiler.compile();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.runtime.style" id="apidoc.element.jade.runtime.style">
        function <span class="apidocSignatureSpan">jade.runtime.</span>style
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">style = function (val) {
  if (val &#x26;&#x26; typeof val === &#x27;object&#x27;) {
    return Object.keys(val).map(function (style) {
      return style + &#x27;:&#x27; + val[style];
    }).join(&#x27;;&#x27;);
  } else {
    return val;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  classes.push(attr.val);
  classEscaping.push(attr.escaped);
} else if (isConstant(attr.val)) {
  if (buffer) {
    this.buffer(runtime.attr(key, toConstant(attr.val), escaped, this.terse));
  } else {
    var val = toConstant(attr.val);
    if (key === &#x27;style&#x27;) val = runtime.<span class="apidocCodeKeywordSpan">style</span>(val);
    if (escaped &#x26;&#x26; !(key.indexOf(&#x27;data&#x27;) === 0 &#x26;&#x26; typeof val !== &#x27;string&#x27;)) {
      val = runtime.escape(val);
    }
    buf.push(utils.stringify(key) + &#x27;: &#x27; + utils.stringify(val));
  }
} else {
  if (buffer) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jade.utils" id="apidoc.module.jade.utils">module jade.utils</a></h1>


    <h2>
        <a href="#apidoc.element.jade.utils.merge" id="apidoc.element.jade.utils.merge">
        function <span class="apidocSignatureSpan">jade.utils.</span>merge
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function (a, b) {
  for (var key in b) a[key] = b[key];
  return a;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (attrsBlocks.length) {
  if (attrs.length) {
    var val = this.attrs(attrs);
    attrsBlocks.unshift(val);
  }
  this.buf.push(&#x27;attributes: jade.<span class="apidocCodeKeywordSpan">merge</span>([&#x27; + attrsBlocks.join(&#x27;,&#x27;) + &#
x27;])&#x27;);
} else if (attrs.length) {
  var val = this.attrs(attrs);
  this.buf.push(&#x27;attributes: &#x27; + val);
}

if (args) {
  this.buf.push(&#x27;}, &#x27; + args + &#x27;);&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.utils.stringify" id="apidoc.element.jade.utils.stringify">
        function <span class="apidocSignatureSpan">jade.utils.</span>stringify
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringify = function (str) {
  return JSON.stringify(str)
             .replace(/\u2028/g, &#x27;\\u2028&#x27;)
             .replace(/\u2029/g, &#x27;\\u2029&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {Function}
 * @api public
 */

exports.compile = function(str, options){
var options = options || {}
  , filename = options.filename
    ? utils.<span class="apidocCodeKeywordSpan">stringify</span>(options.filename)
    : &#x27;undefined&#x27;
  , fn;

str = String(str);

var parsed = parse(str, options);
if (options.compileDebug !== false) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jade.utils.walkAST" id="apidoc.element.jade.utils.walkAST">
        function <span class="apidocSignatureSpan">jade.utils.</span>walkAST
        <span class="apidocSignatureSpan">(ast, before, after)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkAST(ast, before, after) {
  before &#x26;&#x26; before(ast);
  switch (ast.type) {
    case &#x27;Block&#x27;:
      ast.nodes.forEach(function (node) {
        walkAST(node, before, after);
      });
      break;
    case &#x27;Case&#x27;:
    case &#x27;Each&#x27;:
    case &#x27;Mixin&#x27;:
    case &#x27;Tag&#x27;:
    case &#x27;When&#x27;:
    case &#x27;Code&#x27;:
      ast.block &#x26;&#x26; walkAST(ast.block, before, after);
      break;
    case &#x27;Attrs&#x27;:
    case &#x27;BlockComment&#x27;:
    case &#x27;Comment&#x27;:
    case &#x27;Doctype&#x27;:
    case &#x27;Filter&#x27;:
    case &#x27;Literal&#x27;:
    case &#x27;MixinBlock&#x27;:
    case &#x27;Text&#x27;:
      break;
    default:
      throw new Error(&#x27;Unexpected node type &#x27; + ast.type);
      break;
  }
  after &#x26;&#x26; after(ast);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  for (var name in this.mixins)
    ast.unshift(this.mixins[name]);
  return ast;
}

if (!this.extending &#x26;&#x26; !this.included &#x26;&#x26; Object.keys(this.blocks).length){
  var blocks = [];
  utils.<span class="apidocCodeKeywordSpan">walkAST</span>(block, function (node) {
    if (node.type === &#x27;Block&#x27; &#x26;&#x26; node.name) {
      blocks.push(node.name);
    }
  });
  Object.keys(this.blocks).forEach(function (name) {
    if (blocks.indexOf(name) === -1 &#x26;&#x26; !this.blocks[name].isSubBlock) {
      console.warn(&#x27;Warning: Unexpected block &#x22;&#x27;
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
